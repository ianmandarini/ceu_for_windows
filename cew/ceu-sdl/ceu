#!/usr/bin/env lua

--[[
-- This file is automatically generated.
-- Check the github repository for a readable version:
-- http://github.com/fsantanna/ceu
--
-- Céu is distributed under the MIT License:
--

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--
--]]

FILES = {
    ceu_types_h =
        [====[
#ifndef _CEU_TYPES_H
#define _CEU_TYPES_H

#include <stdint.h>

#ifdef __LP64__
typedef unsigned long word;
#else
typedef unsigned int  word;
#endif
typedef unsigned int  uint;
typedef unsigned char byte;
#ifndef __cplusplus
typedef unsigned char bool;
#endif

typedef int64_t  s64;
typedef int32_t  s32;
typedef int16_t  s16;
typedef int8_t    s8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t   u8;

typedef float    f32;
typedef double   f64;

#endif
]====],
    template_h =
        [====[
#ifndef === DEFS_H ===
#define === DEFS_H ===

#include "ceu_types.h"

=== DEFINES ===     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef === TCEU_NLBL === tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef === TCEU_NCLS === tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS === CEU_NTRAILS ===

#include "ceu_os.h"

=== EVENTS ===      /* CEU_IN_, CEU_OUT_ */
=== FUNCTIONS ===   /* CEU_FUN_ */
=== TUPLES ===

/* class definitions */
/*
// TODO: host language to have access to classes
=== CLSS_DEFS ===
*/

#endif
]====],
    template_c =
        [====[
#line 1 "=== FILENAME ==="

=== OUT_H ===
#include "ceu_os.h"

#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* fprintf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif
#ifdef CEU_THREADS
#include <assert.h>
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                      \
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex); \
                f                                             \
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

#ifdef CEU_NEWS_POOL
#include "ceu_pool.h"
#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (=== CEU_NCLS ===)
#endif

/* native code from the Main class */
=== NATIVE ===

/* class definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */
=== CLSS_DEFS ===

/* goto labels */
enum {
=== LABELS_ENUM ===
};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][=== IFCS_NIFCS ===];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][=== IFCS_NFLDS ===];
    u16       ifcs_evts[CEU_NCLS][=== IFCS_NEVTS ===];
    void*     ifcs_funs[CEU_NCLS][=== IFCS_NFUNS ===];
    tceu_ntrl ifcs_trls[CEU_NCLS][=== IFCS_NTRLS ===];
#endif
} _tceu_app;

/* TODO: remove from RAM */
static _tceu_app _CEU_APP = {
#ifdef CEU_IFCS
#ifdef CEU_OS
#error remove from RAM!
#endif
    {
=== IFCS_CLSS ===
    },
    {
=== IFCS_FLDS ===
    },
    {
=== IFCS_EVTS ===
    },
    {
=== IFCS_FUNS ===
    },
    {
=== IFCS_TRLS ===
    }
#endif
};

/**********************************************************************/

#ifndef CEU_OS
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    fprintf(stderr, "SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    fprintf(stderr, "SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS
=== PRES_C ===
#endif

#ifdef CEU_ORGS
=== CONSTRS_C ===
#endif

#ifdef CEU_THREADS
/* THREADS_C */
=== THREADS_C ===
#endif

/* FUNCTIONS_C */
=== FUNCTIONS_C ===

#ifdef CEU_OS
static tceu_evtp ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, tceu_evtp param) {
    switch (evt) {
        /* STUBS */
        === STUBS ===
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
#ifndef CEU_OS
            fprintf(stderr, "invalid call %d\n", evt);
#endif
#endif
    }
    return CEU_EVTP((void*)NULL);
}
#endif

static int ceu_app_go (tceu_app* _ceu_app, tceu_go* _ceu_go)
{
#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS
#ifdef CEU_ORGS
    _ceu_app->lst.org = _ceu_go->org;
#endif
    _ceu_app->lst.trl = _ceu_go->trl;
    _ceu_app->lst.lbl = _ceu_go->lbl;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "TRK: o.%p / l.%d\n", _ceu_go->org, _ceu_go->lbl);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_ceu_go->lbl) {
        === CODE ===
    }
    return RET_HALT;    /* TODO: should never be reached anyways */
}

static void ceu_app_init (tceu_app* app)
{
    app->seqno = 0;
#if defined(CEU_RET) || defined(CEU_OS)
    app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    app->pendingAsyncs = 1;
#endif
#ifdef CEU_RET
    app->ret = 0;
#endif
#ifdef CEU_WCLOCKS
    app->wclk_late = 0;
    app->wclk_min = CEU_WCLOCK_INACTIVE;
    app->wclk_min_tmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    app->wclk_late_ = 0;
    app->wclk_min_ = CEU_WCLOCK_INACTIVE;
    app->wclk_min_tmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&app->threads_mutex, NULL);
    /*PTHREAD_COND_INITIALIZER,*/
    app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
#ifdef CEU_LUA
    app->lua = luaL_newstate();
    /* TODO: lua_close(CEU_L); */
    assert(app->lua != NULL);
    luaL_openlibs(app->lua);
    lua_atpanic(app->lua, ceu_lua_atpanic);
#endif

#ifdef CEU_OS

#ifdef __AVR
    app->code  = (__typeof__(ceu_app_go)*)    (((word)app->addr>>1) + &ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (((word)app->addr>>1) + &ceu_app_calls);
#else
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#endif

#else   /* !CEU_OS */

    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);

#endif  /* CEU_OS */

#ifndef CEU_OS
#ifdef CEU_DEBUG
    CEU_APP_SIG = app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org(app, app->data, CEU_NTRAILS, Class_Main, 0,
#ifdef CEU_NEWS
                0,
#endif
                NULL, 0);
    ceu_out_go(app, CEU_IN__INIT, CEU_EVTP((void*)NULL));
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
}
#endif
]====],
    ceu_os_h =
        [====[
#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#if defined(CEU_OS) && defined(__AVR)
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#ifdef __cplusplus
#define CEU_EVTP(v) (tceu_evtp(v))
#else
#define CEU_EVTP(v) ((tceu_evtp)v)
#endif

#ifdef CEU_OS
    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    #define CEU_PSES
    #define CEU_NEWS
    #define CEU_NEWS_MALLOC
    #define CEU_NEWS_POOL
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__INIT        252
    #define CEU_IN__CLEAR       251
    #define CEU_IN__WCLOCK      250
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              244
#endif

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

    #define ceu_out_malloc(size) \
        ((__typeof__(ceu_sys_malloc)*)((_ceu_app)->sys_vec[CEU_SYS_MALLOC]))(size)
    #define ceu_out_free(ptr) \
        ((__typeof__(ceu_sys_free)*)((_ceu_app)->sys_vec[CEU_SYS_FREE]))(ptr)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_clear(go,start,stop) \
        ((__typeof__(ceu_sys_clear)*)((_ceu_app)->sys_vec[CEU_SYS_CLEAR]))(go,start,stop)

    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,seqno,isDyn,par_org,par_trl)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_SPAWN]))(go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit_buf(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,CEU_EVTP((void*)NULL),sz,buf)

    #define ceu_out_emit_val(app,id,param) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,param,0,NULL)

    #define ceu_out_call_val(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS */
    #define ceu_out_malloc(size) \
            ceu_sys_malloc(size)
    #define ceu_out_free(ptr) \
            ceu_sys_free(ptr)
    #define ceu_out_req() \
            ceu_sys_req()
#ifdef CEU_CLEAR
    #define ceu_out_clear(go,start,stop) \
            ceu_sys_clear(go,start,stop)
#endif
#ifdef CEU_NEWS
    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,isDyn,par_org,par_trl)
#else
    #define ceu_out_org(app,org,n,lbl,seqno,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,par_org,par_trl)
#endif
#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(go, lbl_cnt, org, lbl_org)
#endif
/*#ifdef ceu_out_emit_val*/
    #define ceu_out_emit_buf(app,id,sz,buf) \
            ceu_out_emit_val(app,id,CEU_EVTP((void*)buf))
/*#endif*/
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
#endif

#define ceu_in_emit_val(app,id,param) \
    ceu_out_go(app,id,param)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#ifdef __ANDROID__
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };

    /* IN__STK */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif
} tceu_trl;

/* TCEU_EVTP */

typedef union tceu_evtp {
    int   v;
    void* ptr;
    s32   dt;
#ifdef CEU_THREADS
    CEU_THREADS_T thread;
#endif
#ifdef __cplusplus
    tceu_evtp () {}
    tceu_evtp (void* vv) : ptr(vv) {}
    tceu_evtp (s32   vv) : dt(vv)  {}
    /*tceu_evtp (int   vv) : v(vv)   {}*/
#endif
} tceu_evtp;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS
#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Two purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             */
#ifdef CEU_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
    struct tceu_org* nxt_free;  /* "to free" list (only on reaction end) */
#endif
#endif  /* CEU_ORGS */

#ifdef CEU_NEWS_POOL
    void*  pool;            /* TODO(ram): opt, traverse lst of cls pools */
#endif

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_GO */

typedef struct tceu_go {
    int         evt;
    tceu_evtp   evtp;

#ifdef CEU_INTS
#ifdef CEU_ORGS
    tceu_org* evto;       /* org that emitted current event */
#endif
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
#ifdef __AVR
    #define CEU_MAX_STACK   32
#else
    #define CEU_MAX_STACK   32768
#endif
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk stk[CEU_MAX_STACK];
#else
    tceu_stk stk[CEU_NTRAILS];
#endif

    /* current traversal state */
    int        stki;   /* points to next */
    tceu_trl*  trl;
    tceu_nlbl  lbl;
    tceu_org* org;

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* stop;     /* stop at this trl/org */
#endif
} tceu_go;

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:         2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_RET
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_;
    s32         wclk_min_tmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#ifdef CEU_LUA
    lua_State*  lua;
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    tceu_evtp   (*calls) (struct tceu_app*,tceu_nevt,tceu_evtp);
    void**      sys_vec;
    void*       addr;
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* RET_* */

enum {
    RET_HALT = 0,
    RET_END
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_ORGS)
    , RET_ORG
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_TRL
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, tceu_evtp evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
    tceu_evtp param;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_init      (void);
int  ceu_scheduler (s32(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void*     ceu_sys_malloc    (size_t size);
void      ceu_sys_free      (void* ptr);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
int       ceu_sys_clear     (tceu_go* go, int start, void* stop);
void      ceu_sys_org       (tceu_org* org, int n, int lbl, int seqno, int isDyn, tceu_org* par_org, int par_trl);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, tceu_evtp param, int sz, byte* buf);
tceu_evtp ceu_sys_call      (tceu_app* app, tceu_nevt evt, tceu_evtp param);

enum {
    CEU_SYS_MALLOC = 0,
    CEU_SYS_FREE,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
    CEU_SYS_CLEAR,
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */
]====],
    ceu_os_c =
        [====[
/* TODO: #ifdef CEU_INTS: seqno, stki, CEU_STK */

#include "ceu_os.h"

#ifdef CEU_OS
#ifdef __AVR
#include <avr/pgmspace.h>
void* CEU_APP_ADDR = NULL;
#endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* fprintf */
#include <assert.h>
#endif

#if defined(CEU_OS) || defined(CEU_DEBUG)
#include <stdlib.h>     /* malloc/free, exit */
#endif

#ifdef CEU_NEWS_POOL
#include "ceu_pool.h"
#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic (lua_State* lua) {
#ifdef CEU_DEBUG
    fprintf(stderr, "LUA_ATPANIC: %s\n",
            lua_tostring(lua,-1));
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS)
void* ceu_sys_malloc (size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (_ceu_dyns_ >= CEU_MAX_DYNS)
        return NULL;
    _ceu_dyns_++;           /* assumes no malloc fails */
#endif
#endif
    return malloc(size);
}

void ceu_sys_free (void* ptr) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (ptr != NULL)
        _ceu_dyns_--;
#endif
#endif
    free(ptr);
}
#endif

/**********************************************************************/

/* TODO: ifndef CEU_OS? */
int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

/**********************************************************************/

/* TODO: CEU_OS */
#ifdef CEU_ORGS

void ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk) {
    org->trls[idx].evt  = CEU_IN__ORG;
    org->trls[idx].lnks = lnk;
    lnk[0].nxt = (tceu_org*) &lnk[1];
    lnk[1].prv = (tceu_org*) &lnk[0];
    lnk[1].nxt =  org;
    lnk[1].n   =  0;    /* marks end of linked list */
    lnk[1].lnk =  idx+1;
}

int ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org) {
    /* hold current blk trail: set to my continuation */
    _ceu_go->trl->evt = CEU_IN__STK;
    _ceu_go->trl->lbl = lbl_cnt;
    _ceu_go->trl->stk = _ceu_go->stki;

    _ceu_go->stk[_ceu_go->stki  ].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    _ceu_go->stk[_ceu_go->stki  ].evto = _ceu_go->evto;
#endif
#endif
    _ceu_go->stk[_ceu_go->stki++].evt  = _ceu_go->evt;

    /* switch to ORG */

    org->trls[0].evt = CEU_IN__STK;
    org->trls[0].lbl = lbl_org;
    org->trls[0].stk = _ceu_go->stki;

    _ceu_go->org  = org;
#ifdef CEU_CLEAR
    _ceu_go->stop = &_ceu_go->org->trls[_ceu_go->org->n]; /* don't follow the up link */
#endif
    return RET_ORG;
}

#endif

void ceu_sys_org (tceu_org* org, int n, int lbl, int seqno,
#ifdef CEU_NEWS
                  int isDyn,
#endif
                  tceu_org* par_org, int par_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));

#if defined(CEU_ORGS) || defined(CEU_OS)
    org->n = n;
    org->isAlive = 1;
#endif
#ifdef CEU_NEWS
    org->isDyn = isDyn;
#endif

    /* org.trls[0] == org.blk.trails[1] */
    org->trls[0].evt   = CEU_IN__STK;
    org->trls[0].lbl   = lbl;
    org->trls[0].seqno = seqno;

#ifdef CEU_ORGS
    if (par_org == NULL) {
        return;             /* main class */
    }

    /* re-link */
    {
        tceu_org_lnk* lst = &par_org->trls[par_trl].lnks[1];
        lst->prv->nxt = org;
        org->prv = lst->prv;
        org->nxt = (tceu_org*)lst;
        lst->prv = org;
    }
#endif  /* CEU_ORGS */
}
#ifndef CEU_ORGS
#define ceu_sys_org(a,b,c,d,e,f) ceu_sys_org(a,b,c,d,NULL,0)
#endif

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_tmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* track expiring time to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if (t>app->wclk_min_tmp || t>dt) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    if (app->wclk_min > t) {
        app->wclk_min = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* track expiring time to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late_;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if (t>app->wclk_min_tmp_ || t>dt) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    if (app->wclk_min_ > t) {
        app->wclk_min_ = t;
#ifdef ceu_out_wclock_set_
        ceu_out_wclock_set_(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG)
                trl->evt = CEU_IN__ORG_PSED;
        } else {
            if (trl->evt == CEU_IN__ORG_PSED)
                trl->evt = CEU_IN__ORG;
        }
        if ( trl->evt == CEU_IN__ORG
        ||   trl->evt == CEU_IN__ORG_PSED ) {
            trl += 2;       /* jump [fst|lst] */
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

#ifdef CEU_CLEAR
/* TODO: CEU_OS map (ceu_out_* )*/
int ceu_sys_clear (tceu_go* go, int start, void* stop) {
    go->stk[go->stki  ].evtp = go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    go->stk[go->stki  ].evto = go->evto;
#endif
#endif
    go->stk[go->stki++].evt  = go->evt;
    go->trl  = &go->org->trls[start];
    go->stop = stop;
    go->evt = CEU_IN__CLEAR;
    return RET_TRL;
}
#endif

/* TODO: ifndef CEU_OS? */
u8 CEU_GC = 0;  /* execute __ceu_gc() when "true" */

void ceu_sys_go (tceu_app* app, int evt, tceu_evtp evtp)
{
    tceu_go go;

    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            if (app->wclk_min <= evtp.dt) {
                app->wclk_late = evtp.dt - app->wclk_min;
            }
            app->wclk_min_tmp = app->wclk_min;
            app->wclk_min     = CEU_WCLOCK_INACTIVE;
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            if (app->wclk_min_ <= evtp.dt) {
                app->wclk_late_ = evtp.dt - app->wclk_min_;
            }
            app->wclk_min_tmp_ = app->wclk_min_;
            app->wclk_min_     = CEU_WCLOCK_INACTIVE;
            break;
#endif
#endif
    }

    go.evt  = evt;
    go.evtp = evtp;
    go.stki = 0;
#ifdef CEU_CLEAR
    go.stop = NULL;     /* traverse all (don't stop) */
#endif

#ifdef CEU_NEWS
    tceu_org* lst_free = NULL;  /* "to free" list (only on reaction end) */
#endif

    app->seqno++;

    for (;;)    /* STACK */
    {
#ifdef CEU_DEBUG
        assert(go.stki < 32000);
#endif
        /* TODO: don't restart if kill is impossible (hold trl on stk) */
        go.org = app->data;    /* on pop(), always restart */
#if defined(CEU_INTS) || defined(CEU_ORGS)
_CEU_GO_CALL_ORG_:
#endif
        /* restart from org->trls[0] */
        go.trl = &go.org->trls[0];

#if defined(CEU_CLEAR) || defined(CEU_ORGS)
_CEU_GO_CALL_TRL_:  /* restart from org->trls[i] */
#endif

#ifdef CEU_DEBUG_TRAILS
#if defined(CEU_ORGS) || defined(CEU_OS)
fprintf(stderr, "GO[%d]: evt=%d stk=%d org=%p [%d/%p]\n", app->seqno,
                go.evt, go.stki, go.org, go.org->n, go.org->trls);
#else
fprintf(stderr, "GO[%d]: evt=%d stk=%d [%d]\n", app->seqno,
                go.evt, go.stki, CEU_NTRAILS);
#endif
#endif

        for (;;) /* TRL // TODO(speed): only range of trails that apply */
        {        /* (e.g. events that do not escape an org) */
#ifdef CEU_CLEAR
            if (go.trl == go.stop) {    /* bounded trail traversal? */
                go.stop = NULL;           /* back to default */
                break;                      /* pop stack */
            }
#endif

            /* go.org has been traversed to the end? */
            if (go.trl ==
                &go.org->trls[
#if defined(CEU_ORGS) || defined(CEU_OS)
                    go.org->n
#else
                    CEU_NTRAILS
#endif
                ])
            {
                if (go.org == app->data) {
                    break;  /* pop stack */
                }

#ifdef CEU_ORGS
                {
                    /* hold next org/trl */
                    /* TODO(speed): jump LST */
                    tceu_org* _org = go.org->nxt;
                    tceu_trl* _trl = &_org->trls [
                                        (go.org->n == 0) ?
                                         ((tceu_org_lnk*)go.org)->lnk : 0
                                      ];

                    /* org has been traversed and *CLEARED* to the end? */
                    if (go.evt == CEU_IN__CLEAR) {

#ifdef CEU_ORGS_WATCHING
                        /* TODO: stack will overflow!!! T[9999] */
                        /* emit this.ok */
                        /*go.stk[go.stki].evtp = ?*/
                        go.stk[go.stki].evto = go.org;
                        go.stk[go.stki].evt  = 1;   /* TODO: 1==_ok */
                        go.stki++;
#endif

#ifdef CEU_NEWS
                        if ( go.org->n != 0 /* TODO: avoids LNKs (must be before isDyn */
                        &&   go.org->isDyn ) {
                            /* re-link PRV <-> NXT */
                            go.org->prv->nxt = go.org->nxt;
                            go.org->nxt->prv = go.org->prv;

                            /* Should be freed if (malloc'ed) or
                             *                    (pool still on scope):
                             * - malloc'ed:     (org->pool==NULL)
                             * - pool on scope: (!org->isAlive)
                             */
/* TODO: what if both happens at the same time (body and pool terminate?) */
#ifdef CEU_NEWS_POOL
                            if (!go.org->isAlive
#ifdef CEU_NEWS_MALLOC
                            || go.org->pool == NULL
#endif
                            )
#else
                            /* malloc'ed for sure, no if required */
#endif
                            {
                                tceu_org* nxt = lst_free;
                                go.org->nxt_free = NULL;    /* no next element */
                                if (lst_free == NULL) {
                                    lst_free = go.org;      /* new first element */
                                } else {
                                    while (nxt->nxt_free != NULL) {
                                        nxt = nxt->nxt_free; /* find last element */
                                    }
                                    nxt->nxt_free = go.org;  /* put after that */
                                }
                            }
                            go.org->isAlive = 0;

                            /* explicit free(me) or end of spawn */
                            if (go.stop == go.org)
                                break;  /* pop stack */
                        }
#else
                        go.org->isAlive = 0;
#endif  /* CEU_NEWS */
                    }

                    go.org = _org;
                    go.trl = _trl;
/*fprintf(stderr, "UP[%p] %p %p\n", trl+1, go.org go.trl);*/
                    goto _CEU_GO_CALL_TRL_;
                }
#endif  /* CEU_ORGS */
            }

            /* continue traversing CUR org */
            {
#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
if (go.trl->evt==CEU_IN__ORG)
    fprintf(stderr, "\tTRY [%p] : evt=%d org=%p->%p\n",
                    go.trl, go.trl->evt,
                    &go.trl->lnks[0], &go.trl->lnks[1]);
else
#endif
    fprintf(stderr, "\tTRY [%p] : evt=%d seqno=%d lbl=%d\n",
                    go.trl, go.trl->evt, go.trl->seqno, go.trl->lbl);
#endif

                /* jump into linked orgs */
#ifdef CEU_ORGS
                if ( (go.trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
                  || (go.trl->evt==CEU_IN__ORG_PSED && go.evt==CEU_IN__CLEAR)
#endif
                   )
                {
                    /* TODO(speed): jump LST */
                    go.org = go.trl->lnks[0].nxt;   /* jump FST */
                    if (go.evt == CEU_IN__CLEAR) {
                        go.trl->evt = CEU_IN__NONE;
                    }
                    goto _CEU_GO_CALL_ORG_;
                }
#endif /* CEU_ORGS */

                switch (go.evt)
                {
                    /* "clear" event */
                    case CEU_IN__CLEAR:
                        if (go.trl->evt == CEU_IN__CLEAR)
                            goto _CEU_GO_GO_;
                        go.trl->evt = CEU_IN__NONE;
                        goto _CEU_GO_NEXT_;
                }

                /* a continuation (STK) will always appear before a
                 * matched event in the same stack level
                 */
                if ( ! (
                    (go.trl->evt==CEU_IN__STK && go.trl->stk==go.stki)
                ||
                    (go.trl->evt==go.evt && go.trl->seqno!=app->seqno)
                    /* evt!=CEU_IN__STK (never generated): comp is safe */
                    /* we use `!=´ intead of `<´ due to u8 overflow */
                ) ) {
                    goto _CEU_GO_NEXT_;
                }
_CEU_GO_GO_:
                /* execute this trail */
                go.trl->evt   = CEU_IN__NONE;
                go.trl->seqno = app->seqno;   /* don't awake again */
                go.lbl = go.trl->lbl;
            }

            {
#if defined(CEU_OS) && defined(__AVR)
                CEU_APP_ADDR = app->addr;
#endif
                /*** CODE ***/
                int _ret = app->code(app, &go);
#if defined(CEU_OS) && defined(__AVR)
                CEU_APP_ADDR = 0;
#endif

                switch (_ret) {
                    case RET_END:
#if defined(CEU_RET) || defined(CEU_OS)
                        app->isAlive = 0;
                        CEU_GC = 1;
#endif
                        goto _CEU_GO_QUIT_;
/*
                    case RET_GOTO:
                        goto _CEU_GOTO_;
*/
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                    case RET_TRL:
                        goto _CEU_GO_CALL_TRL_;
#endif
#if defined(CEU_INTS) || defined(CEU_ORGS)
                    case RET_ORG:
                        goto _CEU_GO_CALL_ORG_;
#endif
#ifdef CEU_ASYNCS
                    case RET_ASYNC:
#ifdef ceu_out_async
                        ceu_out_async(app);
#endif
                        app->pendingAsyncs = 1;
                        break;
#endif
                    default:
                        break;
                }
            }
_CEU_GO_NEXT_:
            /* go.trl!=CEU_IN__ORG guaranteed here */
            if (go.trl->evt!=CEU_IN__STK && go.trl->seqno!=app->seqno)
                go.trl->seqno = app->seqno-1;   /* keeps the gap tight */
            go.trl++;
        }

        if (go.stki == 0) {
            break;      /* reaction has terminated */
        }
        go.evtp = go.stk[--go.stki].evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
        go.evto = (tceu_org*) go.stk[  go.stki].evto;
#endif
#endif
        go.evt  = go.stk[  go.stki].evt;
    }

_CEU_GO_QUIT_:;

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
/*
#ifdef ceu_out_wclock_set
        if (app->wclk_min != CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(app->wclk_min);   // only signal after all
            ;
        }
#endif
*/
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
/*
#ifdef ceu_out_wclock_set
        if (app->wclk_min_ != CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(app->wclk_min_);   // only signal after all
            ;
        }
#endif
*/
        app->wclk_late_ = 0;
    }
#endif
#endif

    /* free all orgs on "lst_free" on reaction termination */
#ifdef CEU_NEWS
    while (lst_free != NULL) {
        tceu_org* org = lst_free;
        lst_free = org->nxt_free;
#if    defined(CEU_NEWS_POOL) && !defined(CEU_NEWS_MALLOC)
        ceu_pool_free((tceu_pool*)org->pool, (byte*)org);
#elif  defined(CEU_NEWS_POOL) &&  defined(CEU_NEWS_MALLOC)
        if (org->pool == NULL)
            ceu_sys_free(org);
        else
            ceu_pool_free((tceu_pool*)org->pool, (byte*)org);
#elif !defined(CEU_NEWS_POOL) &&  defined(CEU_NEWS_MALLOC)
        ceu_sys_free(org);
#endif
    }
#endif
}

int ceu_go_all (tceu_app* app)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS)
    if (app->isAlive)
#endif
        ceu_sys_go(app, CEU_IN_OS_START, CEU_EVTP((void*)NULL));
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, CEU_EVTP((void*)NULL));
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
        /* allow threads to also execute */
        CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
    }
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    assert(_ceu_dyns_ == 0);
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

#ifdef CEU_OS

/* SYS_VECTOR
 */
void* CEU_SYS_VEC[CEU_SYS_MAX] __attribute__((used)) = {
    (void*) &ceu_sys_malloc,
    (void*) &ceu_sys_free,
    (void*) &ceu_sys_req,
    (void*) &ceu_sys_load,
#ifdef CEU_ISR
    (void*) &ceu_sys_isr,
#endif
    (void*) &ceu_sys_clear,
    (void*) &ceu_sys_org,
#ifdef CEU_ORGS
    (void*) &ceu_sys_org_trail,
    (void*) &ceu_sys_org_spawn,
#endif
    (void*) &ceu_sys_start,
    (void*) &ceu_sys_link,
    (void*) &ceu_sys_unlink,
    (void*) &ceu_sys_emit,
    (void*) &ceu_sys_call,
#ifdef CEU_WCLOCKS
    (void*) &ceu_sys_wclock,
#endif
    (void*) &ceu_sys_go
};

/*****************************************************************************
 * QUEUE
 * - 256 avoids doing modulo operations
 * - n: number of entries
 * - 0: next position to consume
 * - i: next position to enqueue
 */
#if CEU_QUEUE_MAX == 256
    byte QUEUE[CEU_QUEUE_MAX];
    int  QUEUE_tot = 0;
    u8   QUEUE_get = 0;
    u8   QUEUE_put = 0;
#else
    byte QUEUE[CEU_QUEUE_MAX];
    int  QUEUE_tot = 0;
    u16  QUEUE_get = 0;
    u16  QUEUE_put = 0;
#endif

tceu_queue* ceu_sys_queue_get (void) {
    tceu_queue* ret;
    CEU_ISR_OFF();
    if (QUEUE_tot == 0) {
        ret = NULL;
    } else {
#ifdef CEU_DEBUG
        assert(QUEUE_tot > 0);
#endif
        ret = (tceu_queue*) &QUEUE[QUEUE_get];
    }
    CEU_ISR_ON();
    return ret;
}

int ceu_sys_queue_put (tceu_app* app, tceu_nevt evt, tceu_evtp param,
                       int sz, byte* buf) {
    CEU_ISR_OFF();

    int n = sizeof(tceu_queue) + sz;

    if (QUEUE_tot+n > CEU_QUEUE_MAX)
        return 0;   /* TODO: add event FULL when CEU_QUEUE_MAX-1 */

    /* An event+data must be continuous in the QUEUE. */
    if (QUEUE_put+n+sizeof(tceu_queue)>=CEU_QUEUE_MAX && evt!=CEU_IN__NONE) {
        int fill = CEU_QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
        /*_ceu_sys_emit(app, CEU_IN__NONE, param, fill, NULL);*/
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = CEU_IN__NONE;
        qu->sz  = fill;
        QUEUE_put += sizeof(tceu_queue) + fill;
        QUEUE_tot += sizeof(tceu_queue) + fill;
    }

    {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = evt;
        qu->sz  = sz;

        if (sz == 0) {
            /* "param" is self-contained */
            qu->param = param;
        } else {
            /* "param" points to "buf" */
            qu->param.ptr = qu->buf;
            memcpy(qu->buf, buf, sz);
        }
    }
    QUEUE_put += n;
    QUEUE_tot += n;

    CEU_ISR_ON();
    return 1;
}

void ceu_sys_queue_rem (void) {
    CEU_ISR_OFF();
    tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
    QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
    QUEUE_get += sizeof(tceu_queue) + qu->sz;
    CEU_ISR_ON();
}

/*****************************************************************************/

static tceu_app* CEU_APPS = NULL;
static tceu_lnk* CEU_LNKS = NULL;

#ifdef CEU_RET
    int ok  = 0;
    int ret = 0;
#endif

/* TODO: remove this */
int ceu_sys_emit (tceu_app* app, tceu_nevt evt, tceu_evtp param,
                  int sz, byte* buf) {
    return ceu_sys_queue_put(app, evt, param, sz, buf);
}

tceu_evtp ceu_sys_call (tceu_app* app, tceu_nevt evt, tceu_evtp param) {
    tceu_lnk* lnk = CEU_LNKS;
    for (; lnk; lnk=lnk->nxt)
    {
        if (app!=lnk->src_app || evt!=lnk->src_evt)
            continue;
#if defined(CEU_OS) && defined(__AVR)
        void* __old = CEU_APP_ADDR; /* must remember to resume after call */
        CEU_APP_ADDR = lnk->dst_app->addr;
#endif
        tceu_evtp ret = lnk->dst_app->calls(lnk->dst_app, lnk->dst_evt, param);
#if defined(CEU_OS) && defined(__AVR)
        CEU_APP_ADDR = __old;
#endif
        return ret;
    }
/* TODO: error? */
    return CEU_EVTP((void*)NULL);
}

static void _ceu_sys_unlink (tceu_lnk* lnk) {
    /* remove as head */
    if (CEU_LNKS == lnk) {
        CEU_LNKS = lnk->nxt;
/* TODO: prv */
    /* remove in the middle */
    } else {
        tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt!=NULL && cur->nxt!=lnk)
			cur = cur->nxt;
		if (cur->nxt != NULL)
            cur->nxt = lnk->nxt;
	}

    /*lnk->nxt = NULL;*/
    ceu_sys_free(lnk);
}

static void __ceu_gc (void)
{
    if (! CEU_GC) return;
    CEU_GC = 0;

    /* remove pending events */
    {
        CEU_ISR_OFF();
        int i = 0;
        while (i < QUEUE_tot) {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get+i];
            if (qu->app!=NULL && !qu->app->isAlive) {
                qu->evt = CEU_IN__NONE;
            }
            i += sizeof(tceu_queue) + qu->sz;
        }
        CEU_ISR_ON();
    }

    /* remove broken links */
    {
        tceu_lnk* cur = CEU_LNKS;
        while (cur != NULL) {
            tceu_lnk* nxt = cur->nxt;
            if (!cur->src_app->isAlive || !cur->dst_app->isAlive)
                _ceu_sys_unlink(cur);
            cur = nxt;
        }
    }

    /* remove dead apps */
    tceu_app* app = CEU_APPS;
    tceu_app* prv = NULL;
    while (app)
    {
        tceu_app* nxt = app->nxt;

        if (app->isAlive) {
            prv = app;

        } else {
            if (CEU_APPS == app) {
                CEU_APPS = nxt;     /* remove as head */
            } else {
                prv->nxt = nxt;     /* remove in the middle */
            }

            /* unlink all "from app" or "to app" */
            ceu_sys_unlink(app,0, 0,0);
            ceu_sys_unlink(0,0, app,0);

#ifdef CEU_RET
            ok--;
            ret += app->ret;
#endif

            /* free app memory */
            ceu_sys_free(app->data);
            ceu_sys_free(app);
        }

        app = nxt;
    }
}

#ifdef CEU_ISR

typedef struct {
    tceu_isr_f f;
    tceu_app*  app;
} tceu_isr;

#define CEU_ISR_MAX 40
tceu_isr CEU_ISR_VEC[CEU_ISR_MAX];

int ceu_sys_isr (int n, tceu_isr_f f, tceu_app* app) {
    tceu_isr* isr = &CEU_ISR_VEC[(n-1)];
    if (f==NULL || isr->f==NULL) {
        isr->f   = ((word)app->addr>>1) + f;
        isr->app = app;
                           /* "f" is relative to "app", make it absolute */
        return 1;
    } else {
        return 0;
    }
}
#endif

void ceu_init (void) {
#ifdef CEU_ISR
    int i;
    for (i=0; i<CEU_ISR_MAX; i++) {
        CEU_ISR_VEC[i].f = NULL;      /* TODO: is this required? (bss=0) */
    }
    CEU_ISR_ON();       /* enable global interrupts to start */
#endif
}

int ceu_scheduler (int(*dt)())
{
    /*
     * Intercalate DT->WCLOCK->ASYNC->QUEUE->...
     * QUEUE last to separate app->init() from OS_START.
     * QUEUE handles one event at a time to intercalate with WCLOCK.
     * __ceu_gc() only if QUEUE is emtpy: has to keep data from events 
     * accessible.
     */

#ifdef CEU_RET
    while (ok > 0)
#else
    while (1)
#endif
    {
#if defined(CEU_WCLOCKS) || defined(CEU_IN_OS_DT)
        s32 _dt = dt();
#endif

        /* DT */
#ifdef CEU_IN_OS_DT
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN_OS_DT, CEU_EVTP(_dt));
                app = app->nxt;
            }
        }
#endif	/* CEU_IN_OS_DT */

        /* WCLOCK */
#ifdef CEU_WCLOCKS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
/*
#error TODO: CEU_IN__WCLOCK_
*/
                ceu_sys_go(app, CEU_IN__WCLOCK, CEU_EVTP(_dt));
                app = app->nxt;
            }
        }
#endif	/* CEU_WCLOCKS */

        /* ASYNC */
#ifdef CEU_ASYNCS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN__ASYNC, CEU_EVTP((void*)NULL));
                app = app->nxt;
            }
        }
#endif	/* CEU_ASYNCS */

        /* EVENTS */
        {
            /* clear the current size (ignore events emitted here) */
            CEU_ISR_OFF();
            int tot = QUEUE_tot;
            CEU_ISR_ON();
            if (tot > 0)
            {
                tceu_queue* qu = ceu_sys_queue_get();
                tot -= sizeof(tceu_queue) + qu->sz;
                if (qu->evt == CEU_IN__NONE) {
                    /* nothing; */
                    /* "fill event" */

                /* global events (e.g. OS_START, OS_INTERRUPT) */
                } else if (qu->app == NULL) {
                    tceu_app* app = CEU_APPS;
                    while (app) {
                        ceu_sys_go(app, qu->evt, qu->param);
                        app = app->nxt;
                    }

                } else {
                    /* linked events */
                    tceu_lnk* lnk = CEU_LNKS;
                    while (lnk) {
                        if ( qu->app==lnk->src_app
                        &&   qu->evt==lnk->src_evt
                        &&   lnk->dst_app->isAlive ) {
                            ceu_sys_go(lnk->dst_app, lnk->dst_evt, qu->param);
                        }
                        lnk = lnk->nxt;
                    }
                }

                ceu_sys_queue_rem();
            }
            else
            {
                __ceu_gc();     /* only when queue is empty */
            }
        }
    }

#ifdef CEU_RET
    return ret;
#else
    return 0;
#endif
}

/* LOAD / START */

tceu_app* ceu_sys_load (void* addr)
{
    uint       size;
    tceu_init* init;

#ifdef __AVR
    ((tceu_export) ((word)addr>>1))(&size, &init);
#else
    ((tceu_export) addr)(&size, &init);
#endif

    tceu_app* app = (tceu_app*) ceu_sys_malloc(sizeof(tceu_app));
    if (app == NULL)
        return NULL;

    app->data = (tceu_org*) ceu_sys_malloc(size);
    if (app->data == NULL)
        return NULL;

    app->sys_vec = CEU_SYS_VEC;
    app->nxt = NULL;

    /* Assumes sizeof(void*)==sizeof(WORD) and
        that gcc will word-align SIZE/INIT */
#ifdef __AVR
    app->init = (tceu_init) (((word)addr>>1) + (word)init);
#else
    app->init = (tceu_init) ((word)init);
#endif
    app->addr = addr;

    return app;
}

void ceu_sys_start (tceu_app* app)
{
    /* add as head */
	if (CEU_APPS == NULL) {
		CEU_APPS = app;

    /* add to tail */
    } else {
		tceu_app* cur = CEU_APPS;
        while (cur->nxt != NULL)
            cur = cur->nxt;
        cur->nxt = app;
    }

    /* MAX OK */
#ifdef CEU_RET
    ok++;
#endif

    /* INIT */

/*
printf(">>> %p %X %p[%x %x %x %x %x]\n", addr, size, init,
        ((unsigned char*)init)[5],
        ((unsigned char*)init)[6],
        ((unsigned char*)init)[7],
        ((unsigned char*)init)[8],
        ((unsigned char*)init)[9]);
printf("<<< %d %d\n", app->isAlive, app->ret);
*/

    app->init(app);

    /* OS_START */

#ifdef CEU_IN_OS_START
    ceu_sys_emit(NULL, CEU_IN_OS_START, CEU_EVTP((void*)NULL), 0, NULL);
#endif
}

/* LINK & UNLINK */

int ceu_sys_link (tceu_app* src_app, tceu_nevt src_evt,
                  tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* lnk = (tceu_lnk*) ceu_sys_malloc(sizeof(tceu_lnk));
    if (lnk == NULL)
        return 0;

    lnk->src_app = src_app;
    lnk->src_evt = src_evt;
    lnk->dst_app = dst_app;
    lnk->dst_evt = dst_evt;
    lnk->nxt = NULL;

    /* add as head */
	if (CEU_LNKS == NULL) {
		CEU_LNKS = lnk;

    /* add to tail */
    } else {
		tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt != NULL)
            cur = cur->nxt;
		cur->nxt = lnk;
    }

    return 1;
}

int ceu_sys_unlink (tceu_app* src_app, tceu_nevt src_evt,
                    tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* cur = CEU_LNKS;
    while (cur != NULL) {
        tceu_lnk* nxt = cur->nxt;
        if ( (src_app==0 || src_app==cur->src_app)
          && (src_evt==0 || src_evt==cur->src_evt)
          && (dst_app==0 || dst_app==cur->dst_app)
          && (dst_evt==0 || dst_evt==cur->dst_evt) ) {
            _ceu_sys_unlink(cur);
        }
        cur = nxt;
    }
    return 0;
}

#ifdef CEU_ISR

/* Foreach ISR, call ceu_sys_emit(CEU_IN_OS_INTERRUPT). */

#define GEN_ISR(n)                                                  \
    ISR(__vector_ ## n, ISR_BLOCK) {                                \
        tceu_isr* isr = &CEU_ISR_VEC[n-1];                          \
        if (isr->f != NULL) {                                       \
            CEU_APP_ADDR = isr->app->addr;                          \
            isr->f(isr->app, isr->app->data);                       \
            CEU_APP_ADDR = 0;                                       \
        }                                                           \
        ceu_sys_emit(NULL,CEU_IN_OS_INTERRUPT,CEU_EVTP(n),0,NULL); \
    }
#define _GEN_ISR(n)

GEN_ISR(20);
/*
GEN_ISR( 1) GEN_ISR( 2) GEN_ISR( 3) GEN_ISR( 4) GEN_ISR( 5)
GEN_ISR( 6) GEN_ISR( 7) GEN_ISR( 8) GEN_ISR( 9) GEN_ISR(10)
GEN_ISR(11) GEN_ISR(12) GEN_ISR(13) GEN_ISR(14) GEN_ISR(15)
GEN_ISR(16) GEN_ISR(17) _GEN_ISR(18) GEN_ISR(19) GEN_ISR(20)
GEN_ISR(21) GEN_ISR(22) GEN_ISR(23) GEN_ISR(24) GEN_ISR(25)
GEN_ISR(26) GEN_ISR(27) GEN_ISR(28) GEN_ISR(29) GEN_ISR(30)
GEN_ISR(31) GEN_ISR(32) GEN_ISR(33) GEN_ISR(34) GEN_ISR(35)
GEN_ISR(36) GEN_ISR(37) GEN_ISR(38) GEN_ISR(39) GEN_ISR(40)
*/

#endif /* CEU_ISR */

#endif  /* CEU_OS */
]====],
    ceu_pool_h =
        [====[
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

typedef struct {
    int     size;
    int     free;
    int     index;
    int     unit;
    byte**  queue;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type* name##_queue[size];          \
    type  name##_mem[size];            \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
]====],
    ceu_pool_c =
        [====[
/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>
#include "ceu_pool.h"

void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif
]====],
}
OPTS_NPARAMS = {
    version   = 0,
    input     = nil,

    out_c     = 1,
    out_h     = 1,
    out_s     = 1,
    out_f     = 1,

    join      = 0,
    c_calls   = 1,

    cpp       = 0,
    cpp_exe   = 1,
    cpp_args  = 1,

    safety    = 1,

    tp_word   = 1,

    os        = 0,

    timemachine = 0,
}

OPTS = {
    input     = nil,

    out_c     = '_ceu_app.c',
    out_h     = '_ceu_app.h',
    out_s     = 'CEU_SIZE',
    out_f     = 'ceu_app_init',

    join      = true,
    c_calls   = false,

    cpp       = true,
    cpp_exe   = 'cpp',
    cpp_args  = false,

    safety    = 0,

    tp_word   = 4,

    os        = false,

    timemachine = false,
}

local params = {...}
local i = 1
while i <= #params
do
    local p = params[i]
    i = i + 1

    if p == '-' then
        OPTS.input = '-'

    elseif string.sub(p, 1, 2) == '--' then
        local no = false
        local opt = string.gsub(string.sub(p,3), '%-', '_')
        if string.find(opt, '^no_') then
            no = true
            opt = string.sub(opt, 4)
        end
        if OPTS_NPARAMS[opt]==0 or OPTS_NPARAMS[opt]==nil then
            OPTS[opt] = not no
        else
            local opt = string.gsub(string.sub(p,3), '%-', '_')
            OPTS[opt] = string.match(params[i], "%'?(.*)%'?")
            i = i + 1
        end

    else
        OPTS.input = p
    end
end

if OPTS.version then
    print 'ceu 0.8'
    os.exit(0)
end

if not OPTS.input then
    io.stderr:write([[

    ./ceu <filename>           # Ceu input file, or `-´ for stdin
    
        --out-c <filename>     # C output source file (_ceu_app.c)
        --out-h <filename>     # C output header file (_ceu_app.h)
        --out-s <NAME>         # TODO (CEU_SIZE)
        --out-f <NAME>         # TODO (ceu_app_init)
    
        --join (--no-join)     # join lines enclosed by /*{-{*/ and /*}-}*/ (join)
        --c-calls              # TODO

        --cpp (--no-cpp)       # preprocess the input with `cpp´ (no-cpp)
        --cpp-exe              # preprocessor executable (cpp)
        --cpp-args             # preprocess the input with `cpp´ passing arguments in between `"´ (no)

        --safety <LEVEL>       # safety checks (*0=none*, 1=event, 2=par)

        --tp-word <SIZE>       # sizeof a word in bytes (4)

        --version              # version of Ceu

        --os                   # TODO
        --timemachine          # TODO
]])
    os.exit(1)
end

-- C_CALLS
if OPTS.c_calls then
    local t = {}
    for v in string.gmatch(OPTS.c_calls, "([_%w]+)") do
        t[v] = true
    end
    OPTS.c_calls = t
end


-- INPUT
local inp
if OPTS.input == '-' then
    inp = io.stdin
else
    inp = assert(io.open(OPTS.input))
end
local source = inp:read'*a'

OPTS.source = source

-- PARSE
do
    
do
TP = {
    types = {}
}

local __empty = {}
function TP.get (id)
    return TP.types[id] or __empty
end

function TP.new (me)
    if me.tag == 'Type' then
        local id, ptr, arr, ref = unpack(me)

        me.id  = id
        me.ptr = ptr
        me.arr = arr
        me.ref = ref
        me.ext = (string.sub(id,1,1) == '_') or (id=='@')
        me.hold = true      -- holds by default

        -- var _tp[] v (pointer to _tp holding its own memory)
        -- (for pools `[]´ has another meaning)
        if (not (AST and AST.par(me,'Dcl_pool'))) and me.arr==true then
            me.arr = false
            me.buffer = true
            --ASR(me.ptr==0, me, 'invalid type')
            me.ptr = me.ptr + 1
        end

        -- set from outside (see "types" above and Dcl_nat in env.lua)
        me.prim  = false     -- if primitive
        me.num   = false     -- if numeric
        me.len   = nil       -- sizeof type
        me.plain = false     -- if plain type (no pointers inside it)

-- TODO: remove?
        if ENV and me.ext and (not ENV.c[me.id]) then
            ENV.c[me.id] = { tag='type', id=me.id, len=nil, mod=nil }
        end

    else
        assert(me.tag == 'TupleType')
        me.id  = nil
        me.ptr = (#me==1 and 0) or 1
        me.arr = false
        me.ref = false
        me.ext = false

        me.tup = {}
        for i, t in ipairs(me) do
            local hold, tp, _ = unpack(t)
            tp.hold = hold

            if tp.id=='void' and tp.ptr==0 then
                ASR(#me==1, me, 'invalid type')
                me[1] = nil     -- empty tuple
                break
            end

            me.tup[#me.tup+1] = tp
        end

        if not AST.par(me,'Dcl_fun') then
            TP.types[TP.toc(me)] = me     -- dump typedefs
        end
    end
    return me
end

OPTS.tp_word = assert(tonumber(OPTS.tp_word),
    'missing `--tp-word´ parameter')

-- primitive / numeric / len
local types = {
    void  = { true, false, 0 },
    char  = { true, true, 1 },
    byte  = { true, true, 1 },
    bool  = { true, true, 1 },
    word  = { true, true, OPTS.tp_word },
    uint  = { true, true, OPTS.tp_word },
    int   = { true, true, OPTS.tp_word },
    u64   = { true, true, 8 },
    s64   = { true, true, 8 },
    u32   = { true, true, 4 },
    s32   = { true, true, 4 },
    u16   = { true, true, 2 },
    s16   = { true, true, 2 },
    u8    = { true, true, 1 },
    s8    = { true, true, 1 },
    float = { true, true, OPTS.tp_word },
    f32   = { true, true, 4 },
    f64   = { true, true, 8 },

    pointer   = { false, false, OPTS.tp_word },
    tceu_ncls = { false, false, true }, -- len set in "env.lua"
    tceu_nlbl = { false, false, true }, -- len set in "labels.lua"
}
for id, t in pairs(types) do
    TP.types[id] = TP.new{ tag='Type', id, 0, false, false }
    TP.types[id].prim = t[1]
    TP.types[id].num  = t[2]
    TP.types[id].len  = t[3]
end

function TP.n2bytes (n)
    if n < 2^8 then
        return 1
    elseif n < 2^16 then
        return 2
    elseif n < 2^32 then
        return 4
    end
    error'out of bounds'
end

function TP.copy (t)
    local ret = {}
    for k,v in pairs(t) do
        ret[k] = v
    end
    return ret
end

function TP.fromstr (str)
    local id, ptr = string.match(str, '^(.-)(%**)$')
    assert(id and ptr)
    ptr = (id=='@' and 1) or string.len(ptr);
    return TP.new{ tag='Type', id, ptr, false, false }
end

function TP.toc (tp)
    if tp.tup then
        local t = { 'tceu' }
        for _, v in ipairs(tp.tup) do
            t[#t+1] = TP.toc(v)
            if v.hold then
                t[#t] = t[#t] .. 'h'
            end
        end
        return string.gsub(table.concat(t,'__'),'%*','_')
    end

    local ret = tp.id

    if TOPS[tp.id] then
        ret = 'CEU_'..ret
    end

    ret = ret .. string.rep('*',tp.ptr)

    if tp.arr then
        --error'not implemented'
        ret = ret .. '*'
    end

    if tp.ref then
        ret = ret .. '*'
    end

    return (string.gsub(ret,'^_', ''))
end

function TP.tostr (tp)
    if tp.tup then
        local ret = {}
        for _, t in ipairs(tp.tup) do
            ret[#ret+1] = TP.tostr(t)
        end
        return '('..table.concat(ret,',')..')'
    end

    local ret = tp.id
    ret = ret .. string.rep('*',tp.ptr)
    if tp.arr then
        ret = ret .. '[]'
    end
    if tp.ref then
        ret = ret .. '&'
    end
    return ret
end

function TP.isNumeric (tp)
    return TP.get(tp.id).num and tp.ptr==0 and (not tp.arr)
            or (tp.ext and tp.ptr==0)
            or tp.id=='@'
end

function TP.contains (tp1, tp2)
    -- same type
    if tp1.id==tp2.id and tp1.ptr==tp2.ptr and tp1.arr==tp2.arr then
                                              -- i.e. false
        return true
    end

    -- tp[] vs tp*
    if tp1.id==tp2.id and ((tp1.ptr==1 and tp2.arr) or (tp2.ptr==1 and tp1.arr)) then
        return true
    end

    -- any type (calls, Lua scripts)
    if tp1.id=='@' or tp2.id=='@' then
        return true
    end

    -- both are numeric
    if TP.isNumeric(tp1) and TP.isNumeric(tp2) then
        return true
    end

    -- compatible classes (same classes is handled above)
    local cls1 = ENV.clss[tp1.id]
    local cls2 = ENV.clss[tp2.id]
    if cls1 and cls2 then
        if tp1.ref or tp2.ref or (tp1.ptr>0 and tp2.ptr>0) then
            if tp1.ptr == tp2.ptr then
                return cls1.is_ifc and ENV.ifc_vs_cls(cls1,cls2)
            end
        end
        return false
    end

    -- both are pointers
    if tp1.ptr>0 and tp2.ptr>0 then
        if tp1.id=='char' and tp1.ptr==1 -- cast to char*
        or tp1.id=='void' and tp1.ptr==1 -- cast to void*
        or tp1.ext or tp2.ext then       -- let gcc handle
            return true
            -- TODO: void* too???
        end
        if tp2.id == 'null' then
            return true     -- any pointer can be assigned "null"
        end
        return false
    elseif tp1.ptr>0 or tp2.ptr>0 then
        if tp1.ptr>0 and tp2.ext then
            return true
        elseif tp2.ptr>0 and tp1.ext then
            return true
        else
            return false
        end
    end

    -- let external types be handled by gcc
    if tp1.ext or tp2.ext then
        return true
    end

    -- tuples vs (tuples or single types)
    if tp1.tup or tp2.tup then
        tup1 = tp1.tup or { tp1 }
        tup2 = tp2.tup or { tp2 }
        if #tup1 == #tup2 then
            for i=1, #tup1 do
                local t1 = tup1[i]
                local t2 = tup2[i]
                if not TP.contains(t1,t2) then
                    return false
                end
            end
        end
        return true
    end

    return false
end

function TP.max (tp1, tp2)
    if TP.contains(tp1, tp2) then
        return tp1
    elseif TP.contains(tp2, tp1) then
        return tp2
    else
        return nil
    end
end

end

    
do
m = require 'lpeg'
m.setmaxstack(1000)

local CNT  = 1
local LINE = 1
local FILE = OPTS.input
local patt

LINES = {
    i2l = {},
}

local open = m.Cmt('/*{-{*/',
    function ()
        if OPTS.join then
            CNT = CNT - 1
        end
        return true
    end )
local close = m.Cmt('/*}-}*/',
    function ()
        if OPTS.join then
            CNT = CNT + 1
        end
        return true
    end )

local line = m.Cmt('\n',
    function (s,i)
        for i=#LINES.i2l, i do
            LINES.i2l[i] = { FILE, LINE }
        end
        if CNT > 0 then
            LINE = LINE + 1
        end
        return true
    end )

local S = (m.S'\t\r ' + m.P'\\'*(1-m.P'\n')^0*'\n')
local SS = S^0

-- #line N "file" :: directive to set line/filename
local dir_lins = m.Cmt( m.P'#' *SS* m.P'line'^-1
                          *SS* m.C(m.R'09'^1)             -- line
                          *SS* ( m.P'"' * m.C((1-m.P'"')^0) * m.P'"'
                              + m.Cc(false) )            -- file
                          * (S + (m.P(1)-'\n'))^0 * '\n' -- \n
                 ,
    function (s,i, line, file)
        LINE = line
        FILE = file
        return true
    end )

patt = (line + open + close + dir_lins + 1)^0

OPTS.source = '#line 1 "'..OPTS.input..'"\n'..OPTS.source

if OPTS.cpp or OPTS.cpp_args then
    local args = OPTS.cpp_args or ''
    if OPTS.timemachine then
        args = args .. ' -DCEU_TIMEMACHINE'
    end
    local orig = (OPTS.input=='-' and 'tmp.ceu')
                    or OPTS.input
    local base, name = string.match(orig, '(.*/)(.*)')
    if not base then
        base = ''
        name = orig
    end

    -- fin, fout, ferr
    local fout = base..'_ceu_cpp_'..name
    local ferr = fout..'.err'
    local fin  = fout..'.in'
    local f = assert( io.open(fin,'w') )
    f:write(OPTS.source)
    f:close()

    -- execute cpp
    local ret = os.execute(OPTS.cpp_exe..' -C -dD '..args..' '..fin
                            ..' > '..fout..' 2>'..ferr)
            -- "-C":  keep comments (because of nesting)
            -- "-dD": repeat #define's (because of macros used as C functions)
    os.remove(fin)
    assert(ret == 0 or ret == true, assert(io.open(ferr)):read'*a')
    os.remove(ferr)

    -- remove blank lines of #define's (because of "-dD")
    OPTS.source = assert(io.open(fout)):read'*a'
    --OPTS.source = string.gsub(OPTS.source, '(#define[^\n]*)(\n)(\n)', '%1%3')
    os.remove(fout)
    --print(OPTS.source)
end

patt:match(OPTS.source..'\n')

-------------------------------------------------------------------------------

function DBG (...)
    local t = {}
    for i=1, select('#',...) do
        t[#t+1] = tostring( select(i,...) )
    end
    if #t == 0 then
        t = { [1]=debug.traceback() }
    end
    io.stderr:write(table.concat(t,'\t')..'\n')
end

function MAX (v1, v2)
    return (v1 > v2) and v1 or v2
end

function WRN (cond, ln, code, msg)
    if cond then
        return cond
    end

    if msg==nil then
        msg = code
        code = '0000'
    end
    ln = (AST.isNode(ln) and ln.ln) or ln
    msg = 'WRN ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg

    if RUNTESTS_file and tonumber(code)>1100 then
        RUNTESTS_file:write([[
==============
]]..msg..[[

--------------
]]..T[1]..[[
--------------
]]..debug.traceback()..[[

==============
]])
    end

    DBG('WRN ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg)
    return cond
end
function ASR (cond, ln, code, msg)
    if cond then
        return cond
    end

    if msg==nil then
        msg = code
        code = '0000'
    end
    ln = (AST.isNode(ln) and ln.ln) or ln
    msg = 'ERR ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg

    if RUNTESTS_file and tonumber(code)>1100 then
        RUNTESTS_file:write([[
==============
]]..msg..[[

--------------
]]..T[1]..[[
--------------
]]..debug.traceback()..[[
==============
]])
    end

    if RUNTESTS then
        return assert(false, msg)
                -- TODO: error(msg) ???
    else
        DBG(msg)
        os.exit(1)
    end
end

end

    
do
local P, C, V, Cc, Ct = m.P, m.C, m.V, m.Cc, m.Ct

local S = V'__SPACES'

local ERR_msg
local ERR_i
local LST_i

local I2TK

local f = function (s, i, tk)
    if tk == '' then
        tk = '<BOF>'
        LST_i = 1           -- restart parsing
        ERR_i = 0           -- ERR_i < 1st i
        ERR_msg = '?'
        I2TK = { [1]='<BOF>' }
    elseif i > LST_i then
        LST_i = i
        I2TK[i] = tk
    end
    return true
end
local K = function (patt, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    ERR_msg = '?'
    return #P(1) * m.Cmt(patt*key, f) * S
end
local CK = function (patt, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    ERR_msg = '?'
    return C(m.Cmt(patt*key, f))*S
end
local EK = function (tk, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    return K(P(tk)*key) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected `'..tk.."´"
            end
            return false
        end) * P(false)
end

local KEY = function (str)
    return K(str,true)
end
local EKEY = function (str)
    return EK(str,true)
end
local CKEY = function (str)
    return CK(str,true)
end

local _V2NAME = {
    __Exp = 'expression',
    --__StmtS = 'statement',
    --__StmtB = 'statement',
    --__LstStmt = 'statement',
    --__LstStmtB = 'statement',
    Ext = 'event',
    Var = 'variable/event',
    __ID_nat  = 'identifier',
    __ID_var  = 'identifier',
    __ID_ext  = 'identifier',
    __ID_cls  = 'identifier',
    Type = 'type',
    __ID_field = 'identifier',
    _Dcl_var = 'declaration',
    _Dcl_int = 'declaration',
    _Dcl_pool = 'declaration',
    __Dcl_nat  = 'declaration',
    _Dcl_nat   = 'declaration',
    _TupleType_1 = 'type list',
    _TupleType_2 = 'param list',
}
local EV = function (rule)
    return V(rule) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected ' .. _V2NAME[rule]
            end
            return false
        end) * P(false)
end

local EM = function (msg)
    return m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected ' .. msg
                return false
            end
            return true
        end)
end

TYPES = P'void' + 'char' + 'byte' + 'bool' + 'word'
      + 'int' + 'uint'
      + 'u8' + 'u16' + 'u32' + 'u64'
      + 's8' + 's16' + 's32' + 's64'
      + 'float' + 'f32' + 'f64'

KEYS = P'and'     + 'async'    + 'await'    + 'break'    + 'native'
     + 'continue' + 'do'
     + 'else'     + 'else/if'  + 'emit'     + 'end'      + 'event'
     + 'every'    + 'finalize' + 'FOREVER'  + 'if'       + 'input'
     + 'loop'     + 'not'      + 'nothing'  + 'null'
     + 'or'       + 'output'   + 'par'      + 'par/and'  + 'par/or'
     + 'pause/if' + 'escape'   + 'sizeof'   + 'then'
     + 'until'    + 'var'      + 'with'
     + TYPES
-- ceu-orgs only
     + 'class'    + 'global'   + 'interface'
     + 'free'     + 'this' + 'outer'
     + 'spawn'
--
     --+ 'import'  --+ 'as'
-- export / version
     + 'thread'   + 'sync'
-- functions
     + 'function' + 'call' + 'return' + 'call/rec'
-- isrs
     + 'isr' + 'atomic'
-- bool
     + 'true' + 'false'
-- requests
     + 'input/output' + 'output/input'
-- time
     --+ 'h' + 'min' + 's' + 'ms' + 'us'
-- loop/every
     + 'in'
-- pool
     + 'pool'
     + 'watching'
--
     + P'@' * (
         P'const' + 'hold' + 'nohold' + 'plain' + 'pure' + 'rec' + 'safe'
       )

KEYS = KEYS * -m.R('09','__','az','AZ','\127\255')

local Alpha    = m.R'az' + '_' + m.R'AZ'
local Alphanum = Alpha + m.R'09'
local ALPHANUM = m.R'AZ' + '_' + m.R'09'
local alphanum = m.R'az' + '_' + m.R'09'

NUM = CK(m.R'09'^1) / tonumber

GG = { [1] = CK'' * V'_Stmts' * P(-1)-- + EM'expected EOF')

                -- "Ct" as a special case to avoid "too many captures" (HACK_1)
    , _Stmts  = Ct (( V'__StmtS' * (EK';'*K';'^0) +
                      V'__StmtB' * (K';'^0)
                   )^0
                 * ( V'__LstStmt' * (EK';'*K';'^0) +
                     V'__LstStmtB' * (K';'^0)
                   )^-1
                 * V'Host'^0 )
    , Block  = V'_Stmts'

    , Do     = V'__Do'
    , __Do    = KEY'do' * V'Block' * KEY'end'

    , Nothing = KEY'nothing'

    , __StmtS = V'AwaitS'   + V'AwaitT'    + V'AwaitExt'  + V'AwaitInt'
             + V'EmitT'    + V'EmitExt'   + V'EmitInt'
             + V'_Dcl_nat' + V'_Dcl_ext0'
             + V'_Dcl_int' + V'_Dcl_var' + V'_Dcl_pool'
             + V'Dcl_det'
             --+ V'Call'
             + V'_Set'
             + V'Spawn'    --+ V'Free'
             + V'DoOrg'
             + V'Nothing'
             + V'RawStmt'
             --+ V'Import'
             + V'_Dcl_fun0'
             + V'CallStmt' -- last
             --+ EM'statement'-- (missing `_´?)'
             + EM'statement (usually a missing `var´ or C prefix `_´)'

    , __StmtB = V'Do'    + V'Host'
             + V'Async' + V'_Thread' + V'Sync' + V'Atomic'
             + V'ParOr' + V'ParAnd'  + V'_Watching'
             + V'If'    + V'_Loop'   + V'_Every'  + V'_Iter'
             + V'_Pause'
             + V'_Dcl_ifc' + V'Dcl_cls'
             + V'Finalize'
             + V'_Dcl_fun1' + V'_Dcl_ext1'
             + V'_LuaStmt'

    , __LstStmt  = V'_Escape' + V'Break' + V'_Continue' + V'AwaitN' + V'Return'
    , __LstStmtB = V'ParEver' + V'_Continue'

    , __SetBlock  = V'Do' + V'ParEver' + V'If' + V'_Loop' + V'_Every'

    , VarList = ( K'(' * EV'Var' * (EK',' * EV'Var')^0 * EK')' )

    , _Set  = (V'__Exp' + V'VarList') * V'__Sets'
    , __Sets = (CK'='+CK':=') * (
                                    -- p1=awt,
                Cc'__SetAwait'   * (V'AwaitS'+V'AwaitT'+V'AwaitExt'+V'AwaitInt') * Cc(false)
                                                                                   -- constr
              + Cc'__SetThread'  * V'_Thread' * Cc(false)
                                                -- constr
              + Cc'__SetEmitExt' * ( V'EmitExt'
                                   + K'(' * V'EmitExt' * EK')' )
                                    -- p1=emt, p2=false, p3=false
              + Cc'__SetSpawn'   * V'Spawn'
                                    -- p1=Spawn[max,cls,constr]
              + Cc'__SetDoOrg'   * V'DoOrg'
              + Cc'SetBlock'     * V'__SetBlock' * Cc(false)
                                                   -- constr
              + Cc'SetExp'       * V'__Exp' * Cc(false)
                                              -- constr
              + Cc'__SetLua'     * V'_LuaExp' * Cc(false)
                                                -- constr
              + EM'expression'
              )

    , Finalize = KEY'finalize' * (V'_Set'*EK';'*K';'^0 + Cc(false))
               * EKEY'with' * EV'Finally' * EKEY'end'
    , Finally  = V'Block'

    , Free  = KEY'free'  * V'__Exp'
    , Spawn = KEY'spawn' * EV'__ID_cls' * (KEY'in'*EV'__Exp' + Cc(false))
            * (EKEY'with'*V'Dcl_constr'* EKEY'end' + Cc(false))

    , DoOrg = KEY'do' * EV'__ID_cls'
            * (EKEY'with'*V'Dcl_constr'* EKEY'end' + Cc(false))


    , CallStmt = m.Cmt(V'__Exp',
                    function (s,i,...)
                        return (string.find(s, '%(.*%)')) and i, ...
                    end)

    , Atomic  = KEY'atomic' * V'__Do'
    , Sync    = KEY'sync'   * V'__Do'
    , _Thread = KEY'async' * KEY'thread'    * (V'RefVarList'+Cc(false)) * V'__Do'
    , Async   = KEY'async' * (-P'thread') * (V'RefVarList'+Cc(false)) * V'__Do'

    , __var      = (CK'&'+Cc(false)) * EV'Var'
    , RefVarList = ( K'(' * EV'__var' * (EK',' * EV'__var')^0 * EK')' )

    , _Escape = KEY'escape' * EV'__Exp'

    , _Watching = KEY'watching' * EV'__awaits' * EKEY'do' * V'Block' * EKEY'end'
    , ParOr     = KEY'par/or' * EKEY'do' *
                      V'Block' * (EKEY'with' * V'Block')^1 *
                  EKEY'end'

    , ParAnd  = KEY'par/and' * EKEY'do' *
                    V'Block' * (EKEY'with' * V'Block')^1 *
                EKEY'end'
    , ParEver = KEY'par' * EKEY'do' *
                    V'Block' * (EKEY'with' * V'Block')^1 *
                EKEY'end'

    , If      = KEY'if' * EV'__Exp' * EKEY'then' *
                    V'Block' *
                (KEY'else/if' * EV'__Exp' * EKEY'then' *
                    V'Block')^0 *
                (KEY'else' *
                    V'Block' + Cc(false)) *
                EKEY'end'-- - V'_Continue'

    , Break    = KEY'break'
    , _Continue = KEY'continue'

    , _Loop    = KEY'loop' * ('/'*EV'__Exp' + Cc(false)) *
                    (V'__ID_var' * (EKEY'in'*EV'__Exp' + Cc(false)) +
                        Cc(false)*Cc(false)) *
                V'__Do'

    , _Iter   = KEY'loop' * K'('*EV'Type'*EK')'
              *     V'__ID_var' * KEY'in' * EV'__Exp'
              * V'__Do'

    , _Every  = KEY'every' * ( (EV'__Exp'+V'VarList') * EKEY'in'
                            + Cc(false) )
              *  (V'WCLOCKK' + V'WCLOCKE' + EV'Ext' + EV'__Exp')
              * V'__Do'

    , __Exp    = V'__1'
    , __1      = V'__2'  * (CKEY'or'  * V'__2')^0
    , __2      = V'__3'  * (CKEY'and' * V'__3')^0
    , __3      = V'__4'  * ((CK'|'-'||') * V'__4')^0
    , __4      = V'__5'  * (CK'^' * V'__5')^0
    , __5      = V'__6'  * (CK'&' * V'__6')^0
    , __6      = V'__7'  * ((CK'!='+CK'==') * V'__7')^0
    , __7      = V'__8'  * ((CK'<='+CK'>='+(CK'<'-'<<')+(CK'>'-'>>')) * V'__8')^0
    , __8      = V'__9'  * ((CK'>>'+CK'<<') * V'__9')^0
    , __9      = V'__10' * ((CK'+'+CK'-') * V'__10')^0
    , __10     = V'__11' * ((CK'*'+(CK'/'-'//'-'/*')+CK'%') * V'__11')^0
    , __11     = ( Cc(false) * (CKEY'not'+CK'&'+CK'-'+CK'+'+ CK'~'+CK'*'
                             + Cc'cast'*(K'('*V'Type'*K')') )
                )^0 * V'__12'
    , __12     = V'__13' *
                    (
                        K'(' * Cc'call' * V'ExpList' * EK')' *
                            ( KEY'finalize' * EKEY'with' * V'Finally' * EKEY'end'
                              + Cc(false)) +
                        K'[' * Cc'idx'  * V'__Exp'    * EK']' +
                        (CK':' + CK'.') * EV'__ID_field'
                    )^0
    , __13     = V'__Prim'
    , __Prim   = V'__Parens' + V'SIZEOF'
              + V'Var'     + V'Nat'
              + V'NULL'    + V'NUMBER' + V'STRING'
              + V'Global'  + V'This'   + V'Outer'
              + V'RawExp'
              + CKEY'call'     * EV'__Exp'
              + CKEY'call/rec' * EV'__Exp'

    , ExpList = ( V'__Exp'*(K','*EV'__Exp')^0 )^-1

    , __Parens  = K'(' * EV'__Exp' * EK')'

    , SIZEOF = KEY'sizeof' * EK'(' * (V'Type' + V'__Exp') * EK')'

    , NUMBER = CK( #m.R'09' * (m.R'09'+m.S'xX'+m.R'AF'+m.R'af'+'.'
                                      +(m.S'Ee'*'-')+m.S'Ee')^1 )
            + CK( "'" * (P(1)-"'")^0 * "'" )
            + KEY'false' / function() return 0 end
            + KEY'true'  / function() return 1 end

    , NULL = CKEY'null'

    , WCLOCKK = #NUM *
                (NUM * K'h'   + Cc(0)) *
                (NUM * K'min' + Cc(0)) *
                (NUM * K's'   + Cc(0)) *
                (NUM * K'ms'  + Cc(0)) *
                (NUM * K'us'  + Cc(0)) *
                (NUM * EM'<h,min,s,ms,us>')^-1 * (CK'_' + Cc(false))
    , WCLOCKE = K'(' * V'__Exp' * EK')' * (
                    CK'h' + CK'min' + CK's' + CK'ms' + CK'us'
                  + EM'<h,min,s,ms,us>'
              ) * (CK'_' + Cc(false))

    , _Pause   = KEY'pause/if' * EV'__Exp' * V'__Do'

    , AwaitN   = KEY'await' * KEY'FOREVER'

    , __until  = KEY'until' * EV'__Exp'
    , AwaitExt = KEY'await' * EV'Ext'  * (V'__until' + Cc(false))
    , AwaitInt = KEY'await' * EV'__Exp' * (V'__until' + Cc(false))
    , AwaitT   = KEY'await' * (V'WCLOCKK'+V'WCLOCKE')
                                     * (V'__until' + Cc(false))

    , __awaits = (V'WCLOCKK' + V'WCLOCKE' + V'Ext' + EV'__Exp')
    , ___awaits = K'(' * V'__awaits' * EK')'
    , AwaitS   = KEY'await' * V'___awaits' * (EKEY'or' * V'___awaits')^1
                                     * (V'__until' + Cc(false))

    , EmitT    = KEY'emit' * (V'WCLOCKK'+V'WCLOCKE')

    , EmitExt  = (CKEY'call/rec'+CKEY'call'+CKEY'emit'+CKEY'request')
               * EV'Ext' * V'__emit_ps'
    , EmitInt  = CKEY'emit' * EV'__Exp' * V'__emit_ps'
    , __emit_ps = ( K'=>' * (V'__Exp' + K'(' * V'ExpList' * EK')')
                +   Cc(false) )

    , __ID     = V'__ID_nat' + V'__ID_ext' + V'Var'
    , Dcl_det  = KEY'@safe' * EV'__ID' * EKEY'with' *
                     EV'__ID' * (K',' * EV'__ID')^0

    , __Dcl_nat = Cc'type' * V'__ID_nat' * K'=' * NUM
                + Cc'func' * V'__ID_nat' * '()' * Cc(false)
                + Cc'unk'  * V'__ID_nat'        * Cc(false)

    , _Dcl_nat = KEY'native' * (CKEY'@pure'+CKEY'@const'+CKEY'@nohold'+CK'@plain'+Cc(false))
                   * EV'__Dcl_nat' * (K',' * EV'__Dcl_nat')^0

    , __Dcl_ext_call = (CKEY'input'+CKEY'output')
                     * Cc(false)     -- spawn array
                     * (CKEY'@rec'+Cc(false))
                     * V'_TupleType_2' * K'=>' * EV'Type'
                     * EV'__ID_ext' * (K','*EV'__ID_ext')^0
    , __Dcl_ext_evt  = (CKEY'input'+CKEY'output')
                     * Cc(false)     -- spawn array
                     * Cc(false)     -- recursive
                     * (V'_TupleType_1'+EV'Type') * Cc(false)
                     * EV'__ID_ext' * (K','*EV'__ID_ext')^0
    , __Dcl_ext_io   = (CKEY'input/output'+CKEY'output/input')
                     * ('['*(V'__Exp'+Cc(true))*EK']'+Cc(false))
                     * Cc(false)     -- recursive
                     * V'_TupleType_2' * K'=>' * EV'Type'
                     * EV'__ID_ext' * (K','*EV'__ID_ext')^0

    , _Dcl_ext0 = V'__Dcl_ext_io' + V'__Dcl_ext_call' + V'__Dcl_ext_evt'
    , _Dcl_ext1 = V'_Dcl_ext0' * V'__Do'

    , _Dcl_int  = CKEY'event' * (V'_TupleType_1'+EV'Type') *
                    EV'__ID_var' * (K','*EV'__ID_var')^0

    , _Dcl_pool = CKEY'pool' * EV'Type' * EV'__ID_var' * (K','*EV'__ID_var')^0

    -------

    , _Dcl_var = CKEY'var' * EV'Type' *
                 (
                    Cc(true)  * EV'__ID_var' * EKEY'with' * V'Dcl_constr' * EKEY'end'
                 +
                    Cc(false) * V'__dcl_var' * (K','*V'__dcl_var')^0
                 )

    , Dcl_constr = V'Block'

    , __dcl_var = EV'__ID_var' * (V'__Sets' +
                                Cc(false)*Cc(false)*Cc(false)*Cc(false))
    -------

    , _Dcl_imp = KEY'interface' * EV'__ID_cls' * (K',' * EV'__ID_cls')^0

    , _Dcl_fun0 = KEY'function' * CKEY'isr' * EK'[' * NUM * EK']' * (CKEY'@rec'+Cc(false))
                + CKEY'function' * (CKEY'@rec'+Cc(false))
                               * EV'_TupleType_2' * EK'=>' * EV'Type'
                               * V'__ID_var'

    , _Dcl_fun1 = V'_Dcl_fun0' * V'__Do'
    , Return  = KEY'return' * EV'__Exp'^-1

    , BlockI = ( (EV'_Dcl_var'+V'_Dcl_int'+V'_Dcl_pool'+V'_Dcl_fun0'+V'_Dcl_imp')
                  * (EK';'*K';'^0)
               )^0
    , _Dcl_ifc = KEY'interface' * Cc(true)
               * EV'__ID_cls'
               * EKEY'with' * V'BlockI' * EKEY'end'
    , Dcl_cls  = KEY'class'     * Cc(false)
               * EV'__ID_cls'
               * EKEY'with' * V'BlockI' * V'__Do'

    , Global  = KEY'global'
    , This    = KEY'this' * Cc(false)
    , Outer   = KEY'outer'

    , Ext     = V'__ID_ext'
    , Var     = V'__ID_var'
    , Nat     = V'__ID_nat'

    , __ID_cls  = -KEYS * CK(m.R'AZ'*Alphanum^0)
    , __ID_ext  = -KEYS * CK(m.R'AZ'*ALPHANUM^0)
    , __ID_var  = (-KEYS * CK(m.R'az'*(Alphanum+'?')^0) + CK('_'*-Alphanum))
                    / function(id) return (string.gsub(id,'%?','_')) end
    , __ID_nat  = CK(  P'_' *Alphanum^1)
    , __ID_type = CK(TYPES) + V'__ID_nat' + V'__ID_cls'

    , Type = V'__ID_type'
           * (P'*'^0 / function (s)
                        return string.len(s)
                       end) *S
           * (K'['*(V'__Exp'+Cc(true))*K']' + Cc(false))
           * (CK'&' + Cc(false))
            -- id, *, [], &

    , __ID_field = (CK(Alpha * (Alphanum+'?')^0) /
                    function (id)
                        return (string.gsub(id,'%?','_'))
                    end)

    -- (int, void*)
    , _TupleTypeItem_1 = Cc(false) * EV'Type' * Cc(false)
    , _TupleType_1 = K'(' * EV'_TupleTypeItem_1' * (EK','*V'_TupleTypeItem_1')^0 * EK')'

    -- (int v, nohold void* ptr)
    , _TupleTypeItem_2 = (CKEY'@hold'+Cc(false)) * EV'Type' * (EV'__ID_var'+Cc(false))
    , _TupleType_2 = K'(' * EV'_TupleTypeItem_2' * (EK','*V'_TupleTypeItem_2')^0 * EK')'

    , STRING = CK( CK'"' * (P(1)-'"'-'\n')^0 * EK'"' )

    , Host    = KEY'native' * (#EKEY'do')*'do' * --m.S' \n\t'^0 *
                    ( C(V'_C') + C((P(1)-(m.S'\t\n\r '*'end'*P';'^0*'\n'))^0) )
                *S* EKEY'end'

    , RawStmt = K'{' * C((P(1)-'}')^0) * EK'}'
    , RawExp  = K'{' * C((P(1)-'}')^0) * EK'}'

    --, _C = '/******/' * (P(1)-'/******/')^0 * '/******/'
    , _C      = m.Cg(V'_CSEP','mark') *
                    (P(1)-V'_CEND')^0 *
                V'_CEND'
    , _CSEP = '/***' * (1-P'***/')^0 * '***/'
    , _CEND = m.Cmt(C(V'_CSEP') * m.Cb'mark',
                    function (s,i,a,b) return a == b end)

    , __SPACES = (  m.S'\t\n\r '
                + ('//' * (P(1)-'\n')^0 * P'\n'^-1)
                + ('#'  * (P(1)-'\n')^0 * P'\n'^-1) -- TODO: set of #'s/only after spaces
                + V'__comm'
                )^0

    , __comm    = '/' * m.Cg(P'*'^1,'comm') * (P(1)-V'__commcmp')^0 * 
                    V'__commcl'
                    / function () end
    , __commcl  = C(P'*'^1) * '/'
    , __commcmp = m.Cmt(V'__commcl' * m.Cb'comm',
                    function (s,i,a,b) return a == b end)

    -- Stmt/Exp differ only by the "return" and are re-unified in "adj.lua"
    , _LuaStmt = V'__lua'
    , _LuaExp  = Cc'return ' * V'__lua'

    , __lua    = K'[' * m.Cg(P'='^0,'lua') * '[' *
                ( V'__luaext' + C((P(1)-V'__luaext'-V'__luacmp')^1) )^0
                 * (V'__luacl'/function()end) *S
    , __luaext = K'@' * V'__Exp'
    , __luacl  = ']' * C(P'='^0) * EK']'
    , __luacmp = m.Cmt(V'__luacl' * m.Cb'lua',
                    function (s,i,a,b) return a == b end)
}

function err ()
    local x = (ERR_i<LST_i) and 'before' or 'after'
--DBG(LST_i, ERR_i, ERR_msg, _I2L[LST_i], I2TK[LST_i])
    local file, line = unpack(LINES.i2l[LST_i])
    return 'ERR : '..file..
              ' : line '..line..
              ' : '..x..' `'..(I2TK[LST_i] or '?').."´"..
              ' : '..ERR_msg
end

if RUNTESTS then
    assert(m.P(GG):match(OPTS.source), err())
else
    if not m.P(GG):match(OPTS.source) then     -- TODO: match only in ast.lua?
        DBG(err())
        os.exit(1)
    end
end

end

    
do
AST = {
    root = nil,
}

local MT = {
    __index = function (t,k)
        if t.tag == 'Ref' then
            return t[1][k]
        end
    end,
}

local STACK = {}

function AST.isNode (node)
    return (getmetatable(node) == MT) and node.tag
end

function AST.isParent (n1, n2)
    return n1 == n2
        or n2.__par and AST.isParent(n1, n2.__par)
end

local _N = 0
function AST.node (tag, ln, ...)
    local me
    if tag == '_Stmts' then
        -- "Ct" as a special case to avoid "too many captures" (HACK_1)
        tag = 'Stmts'
        me = setmetatable((...), MT)
    else
        me = setmetatable({ ... }, MT)
    end
    me.n = _N
    _N = _N + 1
    me.ln  = ln
    --me.ln[2] = me.n
    me.tag = tag
    return me
end

function AST.copy (node, ln)
    local ret = setmetatable({}, MT)
    ret.n = _N
    _N = _N + 1
    for k, v in pairs(node) do
        if k == '__par' then
            ret[k] = v
        elseif AST.isNode(v) then
            if v.tag == 'Ref' then
                ret[k] = v
            else
                ret[k] = AST.copy(v, ln)
                ret[k].ln = ln or ret[k].ln
            end
        else
            ret[k] = v
        end
    end
    return ret
end

function AST.pred_async (me)
    local tag = me.tag
    return tag=='Async' or tag=='Thread'
end
function AST.pred_par (me)
    local tag = me.tag
    return tag=='ParOr' or tag=='ParAnd' or tag=='ParEver'
end
function AST.pred_true (me) return true end

function AST.par (me, pred)
    if type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    if not me.__par then
        return nil
    elseif pred(me.__par) then
        return me.__par
    else
        return AST.par(me.__par, pred)
    end
end

function AST.child (me, pred)
    if type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    if pred(me) then
        return me
    end
    for i, sub in ipairs(me) do
        if AST.isNode(sub) and sub.tag~='Ref' then
            if AST.child(sub,pred) then
                return sub
            end
        end
    end
end

function AST.iter (pred, inc)
    if pred == nil then
        pred = AST.pred_true
    elseif type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    local from = (inc and 1) or #STACK
    local to   = (inc and #STACK) or 1
    local step = (inc and 1) or -1
    local i = from
    return function ()
        for j=i, to, step do
            local stmt = STACK[j]
            if pred(stmt) then
                i = j+step
                return stmt
            end
        end
    end
end

function AST.dump (me, spc)
    spc = spc or 0
    local ks = ''
--[[
    for k, v in pairs(me) do
        if type(k)~='number' then
            v = string.gsub(string.sub(tostring(v),1,8),'\n','\\n')
            ks = ks.. k..'='..v..','
        end
    end
]]
    --local t=0; for _ in pairs(me.aw.t) do t=t+1 end
    --ks = 'n='..(me.aw.n or '?')..',t='..t..',ever='..(me.aw.forever_ and 1 or 0)
    --ks = table.concat(me.trails,'-')
--
if me.ana then
    local f = function(v)
                return type(v)=='table'
                            and (type(v[1])=='table' and v[1].id or v[1])
                    or tostring(v)
              end
    local t = {}
    for k in pairs(me.ana.pre) do t[#t+1]=f(k) end
    ks = '['..table.concat(t,',')..']'
    local t = {}
    for k in pairs(me.ana.pos) do t[#t+1]=f(k) end
    ks = ks..'['..table.concat(t,',')..']'
end
--[[
]]
--
    --ks = me.ns.trails..' / '..tostring(me.needs_clr)
    DBG(string.rep(' ',spc)..me.tag..
        ' (ln='..me.ln[2]..' n='..me.n..
                           ' d='..(me.__depth or 0)..
                           ' p='..(me.__par and me.__par.n or '')..
                           ') '..ks)
    for i, sub in ipairs(me) do
        if me.tag~='Ref' and AST.isNode(sub) then
            AST.dump(sub, spc+2)   -- 'Ref' create cycles
        else
            DBG(string.rep(' ',spc+2) .. '['..tostring(sub)..']')
        end
    end
end

local function FF (F, str)
    local f = F[str]
    if type(f) == 'string' then
        return FF(F, f)
    end
    assert(f==nil or type(f)=='function')
    return f
end

local function visit_aux (me, F)
    local _me = me
    me.__par   = STACK[#STACK]
    me.__depth = (me.__par and me.__par.__depth+1) or 0
    ASR(me.__depth < 0xFF, me, 'max depth of 0xFF')

    local pre, mid, pos = FF(F,me.tag..'_pre'), FF(F,me.tag), FF(F,me.tag..'_pos')
    local bef, aft = FF(F,me.tag..'_bef'), FF(F,me.tag..'_aft')

    if F.Node_pre then
        me = F.Node_pre(me) or me
        if me ~= _me then
            --DBG('Node_pre', me.tag, me)
            return visit_aux(me, F)
        end
    end
    if pre then
        me = pre(me) or me
        if me ~= _me then
            --DBG('XXXX_pre', me.tag, me, _me.tag, _me)
            return visit_aux(me, F)
        end
    end

    STACK[#STACK+1] = me

    for i, sub in ipairs(me) do
        if AST.isNode(sub) and sub.tag~='Ref' then
            if bef then assert(bef(me, sub, i)==nil) end
            me[i] = visit_aux(sub, F)
            if aft then assert(aft(me, sub, i)==nil) end
        end
    end

    if mid then
        assert(mid(me) == nil, me.tag)
    end
    if F.Node then
        assert(F.Node(me) == nil)
    end

    STACK[#STACK] = nil

    if pos then
        me = pos(me) or me
        if AST.isNode(me) then
            me.__par = STACK[#STACK]
            me.__depth = (me.__par and me.__par.__depth+1) or 0
        end
    end
    if F.Node_pos then
        me = F.Node_pos(me) or me
        if AST.isNode(me) then
            me.__par = STACK[#STACK]
            me.__depth = (me.__par and me.__par.__depth+1) or 0
        end
    end

    return me
end
AST.visit_aux = visit_aux

function AST.visit (F, node)
    assert(AST)
    --STACK = {}
    return visit_aux(node or AST.root, F)
end

local function i2l (p)
    return LINES.i2l[p]
end

for tag, patt in pairs(GG) do
    if string.sub(tag,1,2) ~= '__' then
        GG[tag] = m.Cc(tag) * (m.Cp()/i2l) * patt / AST.node
    end
end

local function f (ln, v1, op, v2, v3, ...)
    --DBG('2',ln[2],v1,op,v2,v3,...)
    local ret
    if not op then
        ret = v1
    elseif v1=='call' or v1=='call/rec' then
        -- Prim call
        ASR(op.tag=='Op2_call', ln, 'invalid call')
        op[1] = v1  -- change modifier
        ret = op
    elseif v1 then
        -- Op2_*
        if op == 'call' then
            ret = f(ln, AST.node('Op2_'..op,ln,op,v1,v2,v3), ...)
        else
            ret = f(ln, AST.node('Op2_'..op,ln,op,v1,v2), v3, ...)
        end
    else
        -- Op1_*
        if op == 'cast' then
            -- consume the type
            ret = AST.node('Op1_'..op, ln, v2, f(ln,v3,...))
        else
            ret = AST.node('Op1_'..op, ln, op, f(ln,v2,v3,...))
        end
    end
    ret.__ast_isexp = true
    return ret
end

for i=1, 12 do
    local tag = '__'..i
    GG[tag] = (m.Cp()/i2l) * GG[tag] / f
end

AST.root = m.P(GG):match(OPTS.source)
--DBG('oi',AST.root)

end

    
do
local node = AST.node

-- TODO: remove
MAIN = nil

function REQUEST (me)
    --[[
    --      (err, v) = (request LINE=>10);
    -- becomes
    --      var _reqid id = _ceu_sys_request();
    --      var _reqid id';
    --      emit _LINE_request => (id, 10);
    --      finalize with
    --          _ceu_sys_unrequest(id);
    --          emit _LINE_cancel => id;
    --      end
    --      (id', err, v) = await LINE_return
    --                      until id == id';
    --]]

    local to, op, _, emit
    if me.tag == 'EmitExt' then
        to   = nil
        emit = me
    else
        -- _Set
        to, op, _, emit = unpack(me)
    end

    local op_emt, ext, ps = unpack(emit)
    local id_evt = ext[1]
    local id_req  = '_reqid_'..me.n
    local id_req2 = '_reqid2_'..me.n

    local tp_req = node('Type', me.ln, 'int', 0, false, false)

    if ps then
        -- insert "id" into "emit REQUEST => (id,...)"
        if ps.tag == 'ExpList' then
            table.insert(ps, 1, node('Var',me.ln,id_req))
        else
            ps = node('ExpList', me.ln,
                    node('Var', me.ln, id_req),
                    ps)
        end
    end

    local awt = node('AwaitExt', me.ln,
                    node('Ext', me.ln, id_evt..'_RETURN'),
                    node('Op2_==', me.ln, '==',
                        node('Var', me.ln, id_req),
                        node('Var', me.ln, id_req2)))
    if to then
        -- v = await RETURN

        -- insert "id" into "v = await RETURN"
        if to.tag ~= 'VarList' then
            to = node('VarList', me.ln, to)
        end
        table.insert(to, 1, node('Var',me.ln,id_req2))

        awt = node('_Set', me.ln, to, op, '__SetAwait', awt, false, false)
    end

    return node('Stmts', me.ln,
            node('Dcl_var', me.ln, 'var', tp_req, id_req),
            node('Dcl_var', me.ln, 'var', tp_req, id_req2),
            node('SetExp', me.ln, '=',
                node('RawExp', me.ln, 'ceu_out_req()'),
                node('Var', me.ln, id_req)),
            node('EmitExt', me.ln, 'emit',
                node('Ext', me.ln, id_evt..'_REQUEST'),
                ps),
            node('Finalize', me.ln,
                false,
                node('Finally', me.ln,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Nothing', me.ln), -- TODO: unrequest
                            node('EmitExt', me.ln, 'emit',
                                node('Ext', me.ln, id_evt..'_CANCEL'),
                                node('Var', me.ln, id_req)))))),
            awt
    )
end

F = {
-- 1, Root --------------------------------------------------

    ['1_pre'] = function (me)
        local spc, stmts = unpack(me)
        local blk_ifc_body = node('Block', me.ln,       -- same structure of
                                node('Stmts', me.ln,    -- other classes
                                    node('BlockI', me.ln),
                                    stmts))
        local ret = blk_ifc_body

        -- for OS: <par/or do [blk_ifc_body] with await OS_STOP; escape 1; end>
        if OPTS.os then
            ret = node('ParOr', me.ln,
                        node('Block', me.ln, ret),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('AwaitExt', me.ln,
                                    node('Ext',me.ln,'OS_STOP'),
                                    false),
                                node('_Escape', me.ln,
                                    node('NUMBER',me.ln,1)))))
        end

        -- enclose the main block with <ret = do ... end>
        local blk = node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Dcl_var', me.ln, 'var',
                                node('Type', me.ln, 'int', 0, false, false),
                                '_ret'),
                            node('SetBlock', me.ln,
                                ret,
                                node('Var', me.ln,'_ret'))))

        --[[
        -- Prepare request loops to run in "par/or" with the Block->Stmts
        -- above:
        --
        -- par/or do
        --      <ret>
        -- with
        --      par do
        --          every REQ1 do ... end
        --      with
        --          every REQ2 do ... end
        --      end
        -- end
        --]]
        do
            local stmts = blk[1]
            local paror = node('ParOr', me.ln,
                            node('Block', me.ln, stmts),
                            node('Block', me.ln, node('Stmts',me.ln,node('XXX',me.ln))))
                                                -- XXX = Par or Stmts
            blk[1] = paror
            ADJ_REQS = { blk=blk, orig=stmts, reqs=paror[2][1][1] }
                --[[
                -- Use "ADJ_REQS" to hold the "par/or", which can be
                -- substituted by the original "stmts" if there are no requests
                -- in the program (avoiding the unnecessary "par/or->par").
                -- See also ['Root'].
                --]]
        end

        -- enclose the program with the "Main" class
        MAIN = node('Dcl_cls', me.ln, false,
                      'Main',
                      node('Nothing', me.ln),
                      blk)
        MAIN.blk_ifc  = blk_ifc_body   -- Main has no ifc:
        MAIN.blk_body = blk_ifc_body   -- ifc/body are the same

        -- [1] => ['Root']
        AST.root = node('Root', me.ln, MAIN)
        return AST.root
    end,

    Root = function (me)
        if #ADJ_REQS.reqs == 0 then
            -- no requests, substitute the "par/or" by the original "stmts"
            ADJ_REQS.blk[1] = ADJ_REQS.orig
        elseif #ADJ_REQS.reqs == 1 then
            ADJ_REQS.reqs.tag = 'Stmts'
        else
            ADJ_REQS.reqs.tag = 'Par'
        end
    end,

-- Dcl_cls/_ifc --------------------------------------------------

    _Dcl_ifc_pos = 'Dcl_cls_pos',
    Dcl_cls_pos = function (me)
        local is_ifc, id, blk_ifc, blk_body = unpack(me)
        local blk = node('Block', me.ln,
                         node('Stmts',me.ln,blk_ifc,blk_body))

        if not me.blk_ifc then  -- Main already set
            me.blk_ifc  = blk   -- top-most block for `this´
        end
        me.blk_body = me.blk_body or blk_body
        me.tag = 'Dcl_cls'  -- Dcl_ifc => Dcl_cls
        me[3]  = blk        -- both blocks 'ifc' and 'body'
        me[4]  = nil        -- remove 'body'

        assert(me.blk_ifc.tag == 'Block' and
               me.blk_ifc[1]    and me.blk_ifc[1].tag   =='Stmts' and
               me.blk_ifc[1][1] and me.blk_ifc[1][1].tag=='BlockI')

        -- All orgs have an implicit event emitted automatically on
        -- their termination:
        -- event void _ok;
        -- The idx must be constant as the runtime uses it blindly.
        -- (generated in env.ceu)
        table.insert(me.blk_ifc[1][1], 1,
            node('Dcl_int', me.ln, 'event',
                node('Type', me.ln, 'void', 0, false, false),
                '_ok'))

        -- insert class pool for orphan spawn
        if me.__ast_has_malloc then
            table.insert(me.blk_ifc[1][1], 2,
                node('Dcl_pool', me.ln, 'pool',
                    node('Type', me.ln, '_TOP_POOL', 0, true, false),
                    '_top_pool'))
        end
    end,

-- Escape --------------------------------------------------

    _Escape_pos = function (me)
        local exp = unpack(me)

        local cls = AST.par(me, 'Dcl_cls')
        local set = AST.par(me, 'SetBlock')
        ASR(set and set.__depth>cls.__depth,
            me, 'invalid `escape´')

        local _,to = unpack(set)
        local to = AST.copy(to)    -- escape from multiple places
            to.ln = me.ln

        --[[
        --  a = do
        --      var int a;
        --      escape 1;   -- "set" block (outer)
        --  end
        --]]
        to.__adj_blk = set

-- TODO: remove
        to.ret = true

        --[[
        --      a = do ...; escape 1; end
        -- becomes
        --      do ...; a=1; escape; end
        --]]

        return node('Stmts', me.ln,
                    node('SetExp', me.ln, '=', exp, to, fr),
                    node('Escape', me.ln))
    end,

-- Watching --------------------------------------------------

    _Watching_pre = function (me)
        --[[
        --      watching <EVT>|<ORG> do
        --          ...
        --      end
        -- becomes
        --      par/or do
        --          if <ORG>->isAlive
        --              await <EVT>|<ORG>.ok;
        --          end
        --      with
        --          ...
        --      end
        --]]
        local evt, blk = unpack(me)

        local awt
        local ref = node('Ref', me.ln, evt) -- "evt" must be parsed before "awt"
        if evt.tag=='WCLOCKK' or evt.tag=='WCLOCKE' then
            awt = node('AwaitT', me.ln, ref, false)
        elseif evt.tag=='Ext' then
            awt = node('AwaitExt', me.ln, ref, false)
        else  -- maybe an org
            awt = node('AwaitInt', me.ln, ref, false)
            awt.isWatching = true
                -- converts "await org" to "await org._ok" in env.lua
        end

        local ret = node('ParOr', me.ln,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                evt,  -- parses here, than uses "Ref" in "awt"
                                node('If', me.ln,
                                    -- changes to "true" if normal event in env.lua
                                    node('Op2_.', me.ln, '.',
                                        node('Op1_*', me.ln, '*',
                                            -- this cast confuses acc.lua (see Op1_* there)
                                            -- TODO: HACK_3
                                            node('Op1_cast', me.ln,
                                                node('Type', me.ln, '_tceu_org', 1, false, false),
                                                AST.copy(evt))),
                                        'isAlive'),
                                    node('Block',me.ln,node('Stmts',me.ln,awt)),
                                    node('Block',me.ln,node('Stmts',me.ln,node('Nothing', me.ln)))))),
                        blk)
        ret.isWatching = evt
        return ret
    end,

-- Every --------------------------------------------------

    _Every_pre = function (me)
        local to, ext, blk = unpack(me)

        --[[
        --      every a=EXT do ... end
        -- becomes
        --      loop do a=await EXT; ... end
        --]]

        local tag
        if ext.tag == 'Ext' then
            tag = 'AwaitExt'
        elseif ext.tag=='WCLOCKK' or ext.tag=='WCLOCKE' then
            tag = 'AwaitT'
        else
            tag = 'AwaitInt'
        end
        local awt = node(tag, me.ln, ext, false)
            awt.isEvery = true  -- refuses other "awaits"

        local set
        if to then
            set = node('_Set', me.ln, to, '=', '__SetAwait', awt, false)
        else
            set = awt
        end

        local ret = node('Loop', me.ln, node('Stmts', me.ln, set, blk))
            ret.isEvery = true  -- refuses other "awaits"
-- TODO: remove
        ret.blk = blk
        return ret
    end,

-- Iter --------------------------------------------------

    _Iter_pre = function (me)
        local to_tp, to_id, fr_exp, blk = unpack(me)

        local fr_id = '_iter_'..me.n
        local fr_tp = '_tceu_org*'

        local fr_fvar = function() return node('Var', me.ln, fr_id) end
        local to_fvar = function() return node('Var', me.ln, to_id) end

        local fr_dcl = node('Dcl_var', me.ln, 'var',
                        node('Type', me.ln, fr_tp, 0, false, false),
                        fr_id)
        local to_dcl = node('Dcl_var', me.ln, 'var', to_tp, to_id)
        to_dcl.read_only = true

        local fr_ini = node('SetExp', me.ln, '=',
                                        node('IterIni', me.ln, fr_exp),
                                        fr_fvar())
              fr_ini.__ast_iter = true  -- don't check in fin.lua
        local to_ini = node('SetExp', me.ln, '=',
                        node('Op1_cast', me.ln, to_tp, fr_fvar()),
                        to_fvar())
        to_ini.read_only = true   -- accept this write

        local fr_nxt = node('SetExp', me.ln, '=',
                                        node('IterNxt', me.ln, fr_fvar()),
                                        fr_fvar())
              fr_nxt.__ast_iter = true  -- don't check in fin.lua
        fr_nxt[2].iter_nxt = fr_nxt[3]
        local to_nxt = node('SetExp', me.ln, '=',
                        node('Op1_cast', me.ln, to_tp, fr_fvar()),
                        to_fvar())
        to_nxt.read_only = true   -- accept this write

        local loop = node('Loop', me.ln,
                        node('Stmts', me.ln,
                            node('If', me.ln,
                                node('Op2_==', me.ln, '==',
                                                   fr_fvar(),
                                                   node('NULL', me.ln)),
                                node('Break', me.ln),
                                node('Nothing', me.ln)),
                            node('If', me.ln,
                                node('Op2_==', me.ln, '==',
                                                   to_fvar(),
                                                   node('NULL', me.ln)),
                                node('Nothing', me.ln),
                                blk),
                            fr_nxt,to_nxt))
        loop.blk = blk      -- continue
        loop.bound = true   -- guaranteed to be bounded
        loop.isEvery = true  -- refuses other "awaits"

        return node('Block', me.ln, node('Stmts', me.ln, fr_dcl,to_dcl,
                                                         fr_ini,to_ini,
                                                         loop))
    end,

-- Loop --------------------------------------------------

    _Loop_pre  = function (me)
        local max, _i, _j, blk = unpack(me)
        local bound = max and { true, max }
                                -- must be limited to "max" (must have sval)

        if not _i then
            ASR(not max, me, 'invalid loop')
            local n = node('Loop', me.ln, blk)
            n.blk = blk     -- continue
            return n
        end

        local i = function() return node('Var', me.ln, _i) end
        local dcl_i = node('Dcl_var', me.ln, 'var',
                        node('Type', me.ln, 'int', 0, false, false),
                        _i)
        dcl_i.read_only = true
        local set_i = node('SetExp', me.ln, '=', node('NUMBER', me.ln,0), i())
        set_i.read_only = true  -- accept this write
        local nxt_i = node('SetExp', me.ln, '=',
                        node('Op2_+', me.ln, '+', i(), node('NUMBER', me.ln,1)),
                        i())
        nxt_i.read_only = true  -- accept this write

        if max then
            max = node('CallStmt', me.ln,
                    node('Op2_call', me.ln, 'call',
                        node('Nat', me.ln, '_assert'),
                        node('ExpList', me.ln,
                            node('Op2_<', me.ln, '<', i(),
                                max))))
        else
            max = node('Nothing', me.ln)
        end

        if not _j then
            local n = node('Loop', me.ln,
                        node('Stmts', me.ln,
                            max,
                            blk,
                            nxt_i))
            n.blk = blk     -- _Continue needs this
            n.bound = bound
            return node('Block', me.ln,
                    node('Stmts', me.ln, dcl_i, set_i, n))
        end

        bound = bound or { false, _j }
                            -- may be limited to "_j" (if has sval)
        local dcl_j, set_j, j

        if _j.tag == 'NUMBER' then
            ASR(tonumber(_j[1]) > 0, me.ln,
                'constant should not be `0´')
            j = function () return _j end
            dcl_j = node('Nothing', me.ln)
            set_j = node('Nothing', me.ln)
        else
            local j_name = '_j'..blk.n
            j = function() return node('Var', me.ln, j_name) end
            dcl_j = node('Dcl_var', me.ln, 'var',
                        node('Type', me.ln ,'int', 0, false, false),
                        j_name)
            set_j = node('SetExp', me.ln, '=', _j, j())
        end

        local cmp = node('Op2_>=', me.ln, '>=', i(), j())

        local loop = node('Loop', me.ln,
                        node('Stmts', me.ln,
                            node('If', me.ln, cmp,
                                node('Break', me.ln),
                                node('Nothing', me.ln)),
                            max,
                            blk,
                            nxt_i))
        loop.blk = blk      -- continue
        loop.bound = bound

        return node('Block', me.ln,
                node('Stmts', me.ln,
                    dcl_i, set_i,
                    dcl_j, set_j,
                    loop))
    end,

-- Continue --------------------------------------------------

    _Continue_pos = function (me)
        local _if  = AST.iter('If')()
        local loop = AST.iter('Loop')()
        ASR(_if and loop, me, 'invalid `continue´')
        local _,_,_else = unpack(_if)

        loop.hasContinue = true
        _if.hasContinue = true
        ASR( _else.tag=='Nothing'          and   -- no else
            me.__depth  == _if.__depth+3   and   -- If->Block->Stmts->Continue
             _if.__depth == loop.blk.__depth+2 , -- Block->Stmts->If
            me, 'invalid `continue´')
        return AST.node('Nothing', me.ln)
    end,

    Loop_pos = function (me)
        if not me.hasContinue then
            return
        end
        -- start from last to first continue
        local stmts = unpack(me.blk)
        local N = #stmts
        local has = true
        while has do
            has = false
            for i=N, 1, -1 do
                local n = stmts[i]
                if n.hasContinue then
                    has = true
                    N = i-1
                    local _else = AST.node('Stmts', n.ln)
                    n[3] = _else
                    for j=i+1, #stmts do
                        _else[#_else+1] = stmts[j]
                        stmts[j] = nil
                    end
                end
            end
        end
    end,

-- If --------------------------------------------------

    -- "_pre" because of "continue"
    If_pre = function (me)
        if #me==3 and me[3] then
            return      -- has no "else/if" and has "else" clause
        end
        local ret = me[#me] or node('Nothing', me.ln)
        for i=#me-1, 1, -2 do
            local c, b = me[i-1], me[i]
            ret = node('If', me.ln, c, b, ret)
        end
        return ret
    end,

-- Thread ---------------------------------------------------------------------

    _Thread_pre = function (me)
        me.tag = 'Thread'
        local raw = node('RawStmt', me.ln, nil)    -- see code.lua
              raw.thread = me
        return node('Stmts', me.ln,
                    node('Finalize', me.ln,
                        false,
                        node('Finally', me.ln,
                            node('Block', me.ln,
                                node('Stmts', me.ln,raw)))),
                    me,
                    node('Async', me.ln, node('VarList', me.ln),
                                      node('Block', me.ln, node('Stmts', me.ln))))
                    --[[ HACK_2:
                    -- Include <async do end> after it to enforce terminating
                    -- from the main program.
                    --]]
    end,

-- Spawn ------------------------------------------------------------

    -- implicit pool in enclosing class if no "in pool"
    Spawn = function (me)
        local _,pool = unpack(me)
        if not pool then
            AST.par(me,'Dcl_cls').__ast_has_malloc = true
            me[2] = node('Var', me.ln, '_top_pool')
        end
    end,

-- DoOrg ------------------------------------------------------------

    DoOrg_pre = function (me, to)
        --[[
        --  x = do T ... (handled on _Set_pre)
        --
        --  do T with ... end;
        --
        --      becomes
        --
        --  do
        --      var T t with ... end;
        --      await t.ok;
        --  end
        --]]
        local id_cls, constr = unpack(me);

        local awt = node('AwaitInt', me.ln,
                        node('Op2_.', me.ln, '.',
                            node('Var', me.ln, '_org_'..me.n),
                                'ok'),
                            false)
        if to then
            awt = node('_Set', me.ln, to, '=', '__SetAwait', awt, false, false)
        end

        return node('Do', me.ln,
                node('Block', me.ln,
                    node('Stmts', me.ln,
                        node('Dcl_var', me.ln, 'var',
                            node('Type', me.ln, id_cls, 0, false, false),
                            '_org_'..me.n,
                            constr),
                        awt)))
    end,

-- BlockI ------------------------------------------------------------

    -- expand collapsed declarations inside Stmts
    BlockI_pos = function (me)
        local new = {}
        for _, dcl in ipairs(me) do
            if dcl.tag == 'Stmts' then
                for _, v in ipairs(dcl) do
                    new[#new+1] = v
                end
            else
                new[#new+1] = dcl
            end
        end
--[[
        if #new > #me then
            for i,v in ipairs(new) do
                me[i] = v
            end
        end
]]
        -- changes the node reference
        return node('BlockI', me.ln, unpack(new))
    end,

-- Dcl_fun, Dcl_ext --------------------------------------------------------

    _Dcl_ext1_pre = '_Dcl_fun1_pre',
    _Dcl_fun1_pre = function (me)
        local dcl, blk = unpack(me)
        dcl[#dcl+1] = blk           -- include body on DCL0
        return dcl
    end,

    _Dcl_fun0_pre = function (me)
        me.tag = 'Dcl_fun'

        local isr, n, rec, blk = unpack(me)

        -- ISR: include "ceu_out_isr(id)"
        if isr == 'isr' then
            -- convert to 'function'
                --me[1] = 'function'
                me[2] = rec
                me[3] = node('TupleType', me.ln,
                            node('TupleTypeItem', me.ln, false,
                                node('Type', me.ln, 'void', 0, false, false),
                                false))
                me[4] = node('Type', me.ln, 'void', 0, false, false)
                me[5] = n
                me[6] = blk

            --[[
            -- _ceu_out_isr(20, rx_isr)
            --      finalize with
            --          _ceu_out_isr(20, null);
            --      end
            --]]
            return node('Stmts', me.ln,
                me,
                node('CallStmt', me.ln,
                    node('Op2_call', me.ln, 'call',
                        node('Nat', me.ln, '_ceu_out_isr'),
                        node('ExpList', me.ln,
                            node('NUMBER', me.ln, n),
                            node('Var', me.ln, n)),
                        node('Finally', me.ln,
                            node('Block', me.ln,
                                node('Stmts', me.ln,
                                    node('CallStmt', me.ln,
                                        node('Op2_call', me.ln, 'call',
                                            node('Nat', me.ln, '_ceu_out_isr'),
                                            node('ExpList', me.ln,
                                                node('NUMBER', me.ln, n),
                                                node('NULL', me.ln))))))))))
        -- FUN
        else
            return me
        end
    end,

    _Dcl_ext0_pre = function (me)
        local dir, spw, rec, ins, out, id_evt, blk = unpack(me)

        if me[#me].tag == 'Block' then
            -- refuses id1,i2 + blk
            ASR(me[#me]==blk, me, 'same body for multiple declarations')
            -- removes blk from the list of ids
            me[#me] = nil
        else
            -- blk is actually another id_evt, keep #me
            blk = nil
        end

        local ids = { unpack(me,6) }  -- skip dir,spw,rec,ins,out

        local ret = {}
        for _, id_evt in ipairs(ids) do
            if dir=='input/output' or dir=='output/input' then
                --[[
                --      output/input (T1,...)=>T2 LINE;
                -- becomes
                --      input  (tceu_req,T1,...) LINE_REQUEST;
                --      input  tceu_req          LINE_CANCEL;
                --      output (tceu_req,u8,T2)  LINE_RETURN;
                --]]
                local d1, d2 = string.match(dir, '([^/]*)/(.*)')
                assert(out)
                assert(rec == false)
                local tp_req = node('Type', me.ln, 'int', 0, false, false)

                local ins_req = node('TupleType', me.ln,
                                    node('TupleTypeItem', me.ln,
                                        false,AST.copy(tp_req),false),
                                    unpack(ins))                -- T1,...
                local ins_ret = node('TupleType', me.ln,
                                    node('TupleTypeItem', me.ln,
                                        false,AST.copy(tp_req),false),
                                    node('TupleTypeItem', me.ln,
                                        false,node('Type',me.ln,'u8',0,false,false),false),
                                    node('TupleTypeItem', me.ln,
                                        false, out, false))

                ret[#ret+1] = node('Dcl_ext', me.ln, d1, false,
                                   ins_req, false, id_evt..'_REQUEST')
                ret[#ret+1] = node('Dcl_ext', me.ln, d1, false,
                                   AST.copy(tp_req),  false, id_evt..'_CANCEL')
                ret[#ret+1] = node('Dcl_ext', me.ln, d2, false,
                                   ins_ret, false, id_evt..'_RETURN')
            else
                if out then
                    ret[#ret+1] = node('Dcl_fun',me.ln,dir,rec,ins,out,id_evt, blk)
                end
                ret[#ret+1] = node('Dcl_ext',me.ln,dir,rec,ins,out,id_evt)
            end
        end

        if blk and (dir=='input/output' or dir=='output/input') then
            --[[
            -- input/output (int max)=>char* LINE [10] do ... end
            --
            --      becomes
            --
            -- class Line with
            --     var _reqid id;
            --     var int max;
            -- do
            --     finalize with
            --         emit _LINE_return => (this.id,XX,null);
            --     end
            --     par/or do
            --         ...
            --     with
            --         var int v = await _LINE_cancel
            --                     until v == this.id;
            --     end
            -- end
            --]]
            local id_cls = string.sub(id_evt,1,1)..string.lower(string.sub(id_evt,2,-1))
            local tp_req = node('Type', me.ln, 'int', 0, false, false)
            local id_req = '_req_'..me.n

            local ifc = {
                node('Dcl_var', me.ln, 'var', tp_req, id_req)
            }
            for _, t in ipairs(ins) do
                local mod, tp, id = unpack(t)
                ASR(tp.id=='void' or id, me, 'missing parameter identifier')
                --id = '_'..id..'_'..me.n
                ifc[#ifc+1] = node('Dcl_var', me.ln, 'var', tp, id)
            end

            local cls =
                node('Dcl_cls', me.ln, false, id_cls,
                    node('BlockI', me.ln, unpack(ifc)),
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Finalize', me.ln,
                                false,
                                node('Finally', me.ln,
                                    node('Block', me.ln,
                                        node('Stmts', me.ln,
                                            node('EmitExt', me.ln, 'emit',
                                                node('Ext', me.ln, id_evt..'_RETURN'),
                                                    node('ExpList', me.ln,
                                                        node('Var', me.ln, id_req),
                                                        node('NUMBER', me.ln, 2),
                                                                -- TODO: err=2?
                                                        node('NUMBER', me.ln, 0))))))),
                            node('ParOr', me.ln,
                                node('Block', me.ln,
                                    node('Stmts', me.ln, blk)),
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        node('Dcl_var', me.ln, 'var', tp_req, 'id_req'),
                                        node('_Set', me.ln,
                                            node('Var', me.ln, 'id_req'),
                                            '=', '__SetAwait',
                                            node('AwaitExt', me.ln,
                                                node('Ext', me.ln, id_evt..'_CANCEL'),
                                                node('Op2_==', me.ln, '==',
                                                    node('Var', me.ln, 'id_req'),
                                                    node('Op2_.', me.ln, '.',
                                                        node('This',me.ln),
                                                        id_req))),
                                            false)))))))
            cls.__ast_req = {id_evt=id_evt, id_req=id_req}
            ret[#ret+1] = cls

            --[[
            -- Include the request loop in parallel with the top level
            -- stmts:
            --
            -- do
            --     pool Line[10] _Lines;
            --     var tp_req id_req_;
            --     var tpN, idN_;
            --     every (id_req,idN) = _LINE_request do
            --         var Line* new = spawn Line in _Lines with
            --             this.id_req = id_req_;
            --             this.idN    = idN_;
            --         end
            --         if new==null then
            --             emit _LINE_return => (id_req,err,0);
            --         end
            --     end
            -- end
            ]]

            local dcls = {
                node('Dcl_var', me.ln, 'var', tp_req, id_req)
            }
            local vars = node('VarList', me.ln, node('Var',me.ln,id_req))
            local sets = {
                node('_Set', me.ln,
                    node('Op2_.', me.ln, '.', node('This',me.ln), id_req),
                    '=', 'SetExp',
                    node('Var', me.ln, id_req))
            }
            for _, t in ipairs(ins) do
                local mod, tp, id = unpack(t)
                ASR(tp.id=='void' and tp.ptr==0 or id, me,
                    'missing parameter identifier')
                local _id = '_'..id..'_'..me.n
                dcls[#dcls+1] = node('Dcl_var', me.ln, 'var', tp, _id)
                vars[#vars+1] = node('Var', me.ln, _id)
                sets[#sets+1] = node('_Set', me.ln,
                                    node('Op2_.', me.ln, '.',
                                        node('This',me.ln),
                                        id),
                                    '=', 'SetExp',
                                    node('Var', me.ln, _id))
            end

            local reqs = ADJ_REQS.reqs
            reqs[#reqs+1] =
                node('Do', me.ln,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Dcl_pool', me.ln, 'pool',
                                node('Type', me.ln, id_cls, 0, (spw or true), false),
                                '_'..id_cls..'s'),
                            node('Stmts', me.ln, unpack(dcls)),
                            node('_Every', me.ln, vars,
                                node('Ext', me.ln, id_evt..'_REQUEST'),
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        node('Dcl_var', me.ln, 'var',
                                            node('Type', me.ln, 'void', 1, false, false),
                                            'ok_'),
                                        node('_Set', me.ln,
                                            node('Var', me.ln, 'ok_'),
                                            '=', '__SetSpawn',
                                            node('Spawn', me.ln, id_cls,
                                                node('Var', me.ln, '_'..id_cls..'s'),
                                                node('Dcl_constr', me.ln, unpack(sets)))),
                                        node('If', me.ln,
                                            node('Op2_==', me.ln, '==',
                                                node('Var', me.ln, 'ok_'),
                                                node('NULL',me.ln)),
                                            node('Block', me.ln,
                                                node('EmitExt', me.ln, 'emit',
                                                    node('Ext', me.ln, id_evt..'_RETURN'),
                                                    node('ExpList', me.ln,
                                                        node('Var', me.ln, id_req),
                                                        node('NUMBER', me.ln, 1),
                                                                -- TODO: err=1?
                                                        node('NUMBER', me.ln, 0)))),
                                            false)))))))
        end

        return node('Stmts', me.ln, unpack(ret))
    end,

    Return_pre = function (me)
        local cls = AST.par(me, 'Dcl_cls')
        if cls and cls.__ast_req then
            --[[
            --      return ret;
            -- becomes
            --      emit RETURN => (this.id, 0, ret);
            --]]
            return node('EmitExt', me.ln, 'emit',
                        node('Ext', me.ln, cls.__ast_req.id_evt..'_RETURN'),
                        node('ExpList', me.ln,
                            node('Var', me.ln, cls.__ast_req.id_req),
                            node('NUMBER', me.ln, 0), -- no error
                            me[1])  -- return expression
                    )
        end
    end,

-- Dcl_nat, Dcl_ext, Dcl_int, Dcl_pool, Dcl_var ---------------------

    _Dcl_nat_pre = function (me)
        local mod = unpack(me)
        local ret = {}
        local t = { unpack(me,2) }  -- skip "mod"

        for i=1, #t, 3 do   -- pure/const/false, type/func/var, id, len
            ret[#ret+1] = node('Dcl_nat', me.ln, mod, t[i], t[i+1], t[i+2])
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

    _Dcl_int_pre = function (me)
        local pre, tp = unpack(me)
        local ret = {}
        local t = { unpack(me,3) }  -- skip "pre","tp"
        for i=1, #t do
            ret[#ret+1] = node('Dcl_int', me.ln, pre, tp, t[i])
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

    _Dcl_pool_pre = function (me)
        local pre, tp = unpack(me)
        local ret = {}
        local t = { unpack(me,3) }  -- skip "pre","tp"
        for i=1, #t do
            ret[#ret+1] = node('Dcl_pool', me.ln, pre, tp, t[i])
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

    -- "_pre" because of SetBlock assignment
    _Dcl_var_pre = function (me)
        local pre, tp, hasConstr = unpack(me)
        local ret = {}
        local t = { unpack(me,4) }  -- skip pre,tp,hasConstr

        if hasConstr then
            table.remove(me, 3)
            me.tag = 'Dcl_var'
            return
        end

        -- id, op, tag, exp, constr
        for i=1, #t, 5 do
            ret[#ret+1] = node('Dcl_var', me.ln, pre, tp, t[i])
            if t[i+1] then
                ret[#ret+1] = node('_Set', me.ln,
                                node('Var', me.ln, t[i]),  -- var
                                t[i+1],                 -- op
                                t[i+2],                 -- tag
                                t[i+3],                 -- exp    (p1)
                                t[i+4] )                -- constr (p2)
                ret[#ret][1].byRef = true  -- first assignment
                ret[#ret][4].byRef = true  -- first assignment
            end
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

-- Tuples ---------------------

    _TupleItem_2 = '_TupleItem_1',
    _TupleItem_1 = function (me)
        me.tag = 'TupleItem'
    end,
    _TupleType_2 = '_TupleType_1',
    _TupleType_1 = function (me)
        me.tag = 'TupleType'
    end,

    AwaitExt_pre = function (me)
        local exp, cnd = unpack(me)
        if not cnd then
            return me
        end
        if AST.par(me, '_Set_pre') then
            return me   -- TODO: join code below with _Set_pre
        end

        -- <await until> => loop

        me[2] = false   -- remove "cnd" from "Await"
        return node('Loop', me.ln,
                node('Stmts', me.ln,
                    me,
                    node('If', me.ln, cnd,
                        node('Break', me.ln),
                        node('Nothing', me.ln))))
    end,
    AwaitInt_pre = 'AwaitExt_pre',
    AwaitT_pre   = 'AwaitExt_pre',

    _Set_pre = function (me)
        local to, op, tag, p1, p2, p3 = unpack(me)

--[[
-- remove! now "request" generates EmitExt that returns tuple
        if to.tag == 'VarList' then
            ASR(tag=='__SetAwait', me.ln,
                'invalid attribution (`await´ expected)')
        end
]]

        if tag == 'SetExp' then
            return node(tag, me.ln, op, p1, to)

        elseif tag == '__SetAwait' then

            local ret
            local awt = p1
            local T = node('Stmts', me.ln)

            -- <await until> => loop
            local cnd = awt[#awt]
            awt[#awt] = false   -- remove "cnd" from "Await"
            if cnd then
                ret = node('Loop', me.ln,
                            node('Stmts', me.ln,
                                T,
                                node('If', me.ln, cnd,
                                    node('Break', me.ln),
                                    node('Nothing', me.ln))))
                ret.isAwaitUntil = true     -- see tmps.lua
            else
                ret = T
            end

            local tup = '_tup_'..me.n

            -- <a = await I>  => await I; a=I;
            T[#T+1] = awt
            if op then
                if to.tag == 'VarList' then
                    T[#T+1] = node('SetExp', me.ln, '=',
                                    node('Ref', me.ln, awt),
                                    node('Var', me.ln, tup))
                                    -- assignment to struct must be '='
                else
                    T[#T+1] = node('SetExp', me.ln, op,
                                    node('Ref', me.ln, awt),
                                    to)
                end
            end

            if to.tag == 'VarList' then
                local var = unpack(awt) -- find out 'TP' before traversing tup

                table.insert(T, 1, AST.copy(var))
                table.insert(T, 2,
                    node('Dcl_var', me.ln, 'var',
                        node('Type', me.ln, 'char', 1, false, false),
                        tup))
                    T[2].__ast_ref = { T, 1 } -- TP is changed on env.lua

                -- T = { evt_var, dcl_tup, awt, set [_1,_N] }

                for i, v in ipairs(to) do
                    T[#T+1] = node('SetExp', me.ln, op,
                                node('Op2_.', me.ln, '.',
                                    node('Op1_*', me.ln, '*',
                                        node('Var', me.ln, tup)),
                                    '_'..i),
                                v)
                    T[#T][2].__ast_chk = { {T,1}, i }
                    T[#T][2].__ast_fr = p1    -- p1 is an AwaitX
                end
            end

            return ret

        elseif tag == 'SetBlock' then
            return node(tag, me.ln, p1, to)

        elseif tag == '__SetThread' then
            return node('Stmts', me.ln,
                        p1,
                        node('SetExp', me.ln, op,
                            node('Ref', me.ln, p1),
                            to))

        elseif tag == '__SetEmitExt' then
            assert(p1.tag == 'EmitExt')
            local op_emt, ext, ps = unpack(p1)
            if op_emt == 'request' then
                return REQUEST(me)

            else
                --[[
                --      v = call A(1,2);
                -- becomes
                --      do
                --          var _tup t;
                --          t._1 = 1;
                --          t._2 = 2;
                --          emit E => &t;
                --          v = <ret>
                --      end
                --]]
                p1.__ast_set = true
                return node('Block', me.ln,
                            node('Stmts', me.ln,
                                p1,  -- Dcl_var, Sets, EmitExt
                                node('SetExp', me.ln, op,
                                    node('Ref', me.ln, p1),
                                    to)))
            end

        elseif tag=='__SetSpawn' then
            p1[#p1+1] = node('SetExp', me.ln, op,
                            node('Ref', me.ln, p1),
                            to)
            return p1

        elseif tag == '__SetDoOrg' then
            return F.DoOrg_pre(p1, to)

        elseif tag == '__SetLua' then
            p1.ret = to     -- node Lua will assign to "to"
            return node('Stmts', me.ln, to, p1)

        else
            error 'not implemented'
        end
    end,

-- Lua --------------------------------------------------------

    _LuaExp = function (me)
        --[[
        -- a = @a ; b = @b
        --
        -- __ceu_1, __ceu_2 = ...
        -- a = __ceu_1 ; b = __ceu_2
        --]]
        local params = {}
        local code = {}
        local names = {}
        for _, v in ipairs(me) do
            if type(v) == 'table' then
                params[#params+1] = v
                code[#code+1] = '_ceu_'..#params
                names[#names+1] = code[#code]
            else
                code[#code+1] = v;
            end
        end

        -- me.ret:    node to assign result ("_Set_pre")
        -- me.params: @v1, @v2
        -- me.lua:    code as string

        me.params = params
        if #params == 0 then
            me.lua = table.concat(code,' ')
        else
            me.lua = table.concat(names,', ')..' = ...\n'..
                     table.concat(code,' ')
        end

        me.tag = 'Lua'
    end,
    _LuaStmt = '_LuaExp',

-- EmitExt --------------------------------------------------------

    EmitExt_pre = function (me)
        local op, ext, ps = unpack(me)
        if op ~= 'request' then
            return
        end
        return REQUEST(me)
    end,

    EmitInt_pos = 'EmitExt_pos',
    EmitExt_pos = function (me)
        local op, ext, ps = unpack(me)
        me.ps = ps  -- save for arity check

        -- (1) no exp: emit e
        if not ps then
            return
        end

        local t = { }

        -- (2) single: emit e => a
        if ps.tag ~= 'ExpList' then
            -- avoid emitting tmps (see tmps.lua)
            if me.tag == 'EmitInt' then
                t[#t+1] = node('EmitNoTmp', me.ln)
            end

            t[#t+1] = me
            return node('Stmts', me.ln, unpack(t))
        end

        -- (3) multiple: emit e => (a,b)
        local tup = '_tup_'..me.n
        t[#t+1] = AST.copy(ext)   -- find out 'TP' before traversing local
        local I = #t
        t[#t+1] = node('Dcl_var', me.ln, 'var',
                    node('Type', me.ln, 'TP', 0, false, false),
                    tup)
        t[#t].__ast_ref = { t, #t-1 } -- TP is changed on env.lua

        -- avoid emitting tmps (see tmps.lua)
        if me.tag == 'EmitInt' then
            t[#t+1] = node('EmitNoTmp', me.ln)
        end

        for i, p in ipairs(ps) do
            t[#t+1] = node('SetExp', me.ln, '=',
                        p,
                        node('Op2_.', me.ln, '.', node('Var',me.ln,tup),
                            '_'..i))
            t[#t][3].__ast_chk = { {t,I}, i }
        end

        me[3] = node('Op1_&', me.ln, '&',
                    node('Var', me.ln, tup))
        t[#t+1] = me

        return node('Stmts', me.ln, unpack(t))
    end,

-- Finalize ------------------------------------------------------

    Finalize_pos = function (me)
        if (not me[1]) or (me[1].tag ~= 'Stmts') then
            return      -- normal finalize
        end

        ASR(me[1][1].tag == 'AwaitInt', me,
            'invalid finalize (multiple scopes)')

        -- invert fin <=> await
        local ret = me[1]   -- return stmts
        me[1] = ret[2]      -- await => fin
        ret[2] = me         -- fin => stmts[2]
        return ret
    end,

-- Pause ---------------------------------------------------------

    _Pause_pre = function (me)
        local evt, blk = unpack(me)
        local cur_id  = '_cur_'..blk.n
        local cur_dcl = node('Dcl_var', me.ln, 'var',
                            node('Type', me.ln, 'u8', 0, false, false),
                            cur_id)

        local PSE = node('Pause', me.ln, blk)
        PSE.dcl = cur_dcl

        local on  = node('PauseX', me.ln, 1)
            on.blk  = PSE
        local off = node('PauseX', me.ln, 0)
            off.blk = PSE

        return
            node('Block', me.ln,
                node('Stmts', me.ln,
                    cur_dcl,    -- Dcl_var(cur_id)
                    node('SetExp', me.ln, '=',
                        node('NUMBER', me.ln, 0),
                        node('Var', me.ln, cur_id)),
                    node('ParOr', me.ln,
                        node('Loop', me.ln,
                            node('Stmts', me.ln,
                                node('_Set', me.ln,
                                    node('Var', me.ln, cur_id),
                                    '=', '__SetAwait',
                                    node('AwaitInt', me.ln, evt, false),
                                    false, false),
                                node('If', me.ln,
                                    node('Var', me.ln, cur_id),
                                    on,
                                    off))),
                        PSE)))
    end,
--[=[
        var u8 psed? = 0;
        par/or do
            loop do
                psed? = await <evt>;
                if psed? then
                    PauseOff()
                else
                    PauseOn()
                end
            end
        with
            pause/if (cur) do
                <blk>
            end
        end
]=]

-- Op2_: ---------------------------------------------------

    ['Op2_:_pre'] = function (me)
        local _, ptr, fld = unpack(me)
        return node('Op2_.', me.ln, '.',
                node('Op1_*', me.ln, '*', ptr),
                fld)
    end,

-- This ------------------------------------------------------------

    -- constructor assignments are first assignments "byRef"
    This = function (me)
        local set = AST.par(me,'SetExp')
        if AST.par(me,'Dcl_constr') and set then
            set[2].byRef = true     -- first assignment
            set[3].byRef = true     -- first assignment
        end
    end,

-- RefVarList ------------------------------------------------------------

    RefVarList = function (me)
        -- { &1, var2, &2, var2, ... }
        for i=1, #me, 2 do
            local isRef, var = me[i], me[i+1]
            local id = unpack(var)
            me[id] = { isRef, var }
        end
    end,

-- STRING ------------------------------------------------------------

    STRING_pos = function (me)
        if not OPTS.os then
            return
        end

        -- <"abc"> => <var str[4]; str[0]='a';str[1]='b';str[2]='c';str[3]='\0'>

        local str = loadstring('return '..me[1])()  -- eval `"´ and '\xx'
        local len = string.len(str)
        local id = '_str_'..me.n

        local t = {
            node('Dcl_var', me.ln, 'var',
                node('Type', me.ln, 'char', 0, node('NUMBER',me.ln,len+1), false),
                id)
        }

        for i=1, len do
            -- str[(i-1)] = str[i]  (lua => C)
            t[#t+1] = node('SetExp', me.ln, '=',
                        node('NUMBER', me.ln, string.byte(str,i)),
                        node('Op2_idx', me.ln, 'idx',
                            node('Var',me.ln,id),
                            node('NUMBER',me.ln,i-1)))
        end

        -- str[len] = '\0'
        t[#t+1] = node('SetExp', me.ln, '=',
                    node('NUMBER', me.ln, 0),
                    node('Op2_idx', me.ln, 'idx',
                        node('Var',me.ln,id),
                        node('NUMBER',me.ln,len)))

        -- include this string into the enclosing block
        local stmt = AST.par(me, 'Stmts')
        local strs = stmt.__ast_strings or {}
        stmt.__ast_strings = strs
        strs[#strs+1] = node('Stmts', me.ln, unpack(t))

        return node('Var',me.ln,id)
    end,

    Stmts = function (me)
        local strs = me.__ast_strings
        me.__ast_strings = nil
        if strs then
            -- insert all strings in the beginning of the block
            for i, str in ipairs(strs) do
                table.insert(me, i, str)
            end
        end
    end,
}

AST.visit(F)

end

    
do
TOPS  = {}    -- holds all clss/exts/nats

local node = AST.node

F = {
    Root_pos = function (me)
        AST.root = node('Root', me.ln, unpack(TOPS))
        return AST.root
    end,

    Dcl_cls_pos = function (me)
        local ifc, id, blk = unpack(me)
        me.is_ifc = ifc
        me.id     = id
        TOPS[#TOPS+1] = me
        TOPS[id] = me
        return node('Nothing', me.ln)
    end,

    Dcl_nat_pos = function (me)
        TOPS[#TOPS+1] = me
        return node('Nothing', me.ln)
    end,
    Dcl_ext_pos = function (me)
        TOPS[#TOPS+1] = me
        return node('Nothing', me.ln)
    end,
}

local function id2ifc (id)
    for _, cls in ipairs(TOPS) do
        local _,id2 = unpack(cls)
        if id2 == id then
            return cls
        end
    end
    return nil
end

AST.visit(F)

-- substitute all Dcl_imp for the referred fields (simplifies later phases)
for _, cls in ipairs(TOPS) do
    if cls.tag=='Dcl_cls' and cls[2]~='Main' then   -- "Main" has no Dcl_imp's
        local dcls1 = cls.blk_ifc[1][1]
        assert(dcls1.tag == 'BlockI')
        for i=1, #dcls1 do
            local imp = dcls1[i]
            if imp.tag == '_Dcl_imp' then
                -- interface A,B,...
                for _,dcl in ipairs(imp) do
                    local ifc = id2ifc(dcl)  -- interface must exist
                    ASR(ifc and ifc[1]==true,
                        imp, 'interface "'..dcl..'" is not declared')
                    local dcls2 = ifc.blk_ifc[1][1]
                    assert(dcls2.tag == 'BlockI')
                    for _, dcl2 in ipairs(dcls2) do
                        assert(dcl2.tag ~= 'Dcl_imp')   -- impossible because I'm going in order
                        local new = AST.copy(dcl2)
                        dcls1[#dcls1+1] = new -- fields from interface should go to the end
                        new.isImp = true      -- to avoid redeclaration warnings indeed
                    end
                end
                table.remove(dcls1, i) -- remove _Dcl_imp
                i = i - 1                    -- repeat
            else
            end
        end
    end
end

end

    
do
ENV = {
    clss  = {},     -- { [1]=cls, ... [cls]=0 }
    clss_ifc = {},
    clss_cls = {},

    calls = {},     -- { _printf=true, _myf=true, ... }

    -- f=fields, e=events
    ifcs  = {
        flds = {}, -- {[1]='A',[2]='B',A=0,B=1,...}
        evts = {}, -- ...
        funs = {}, -- ...
        trls = {}, -- ...
    },

    exts = {
        --[1]=ext1,         [ext1.id]=ext1.
        --[N-1]={_ASYNC},   [id]={},
        --[N]={_WCLOCK},    [id]={},
    },

    -- TODO: move to TP
    -- "len" is used to sort fields on generated "structs"
    -- TODO: try to remove ENV.c, a lot is shared w/ Type (e.g. hold)
    c = {
        void = 0,

        word     = OPTS.tp_word,
        pointer  = OPTS.tp_word,

        bool     = 1,
        byte     = 1,
        char     = 1,
        int      = OPTS.tp_word,
        uint     = OPTS.tp_word,
        u8=1, u16=2, u32=4, u64=8,
        s8=1, s16=2, s32=4, s64=8,

        float    = OPTS.tp_word,
        f32=4, f64=8,

        tceu_ncls = true,    -- env.lua
        tceu_nlbl = true,    -- labels.lua
    },
    dets  = {},

    max_evt = 0,    -- max # of internal events (exts+1 start from it)
}

for k, v in pairs(ENV.c) do
    if v == true then
        ENV.c[k] = { tag='type', id=k, len=nil }
    else
        ENV.c[k] = { tag='type', id=k, len=v }
    end
end

function CLS ()
    return AST.iter'Dcl_cls'()
end

function var2ifc (var)
    local tp
    if var.pre=='var' or var.pre=='pool' then
        tp = TP.toc(var.tp)
    elseif var.pre == 'event' then
        tp = TP.toc(var.evt.ins)
    elseif var.pre == 'function' then
        tp = TP.toc(var.fun.ins)..'$'..TP.toc(var.fun.out)
    else
        error 'not implemented'
    end
    tp = var.pre..'__'..tp
    return table.concat({
        var.id,
        tp,
        tostring(var.pre),
        var.tp.arr and '[]' or '',
    }, '$')
end

function ENV.ifc_vs_cls (ifc, cls)
    -- check if they have been checked
    ifc.matches = ifc.matches or {}
    cls.matches = cls.matches or {}
    if ifc.matches[cls] ~= nil then
        return ifc.matches[cls]
    end

    -- check if they match
    for _, v1 in ipairs(ifc.blk_ifc.vars) do
        v2 = cls.blk_ifc.vars[v1.id]
        if v2 then
            v2.ifc_id = v2.ifc_id or var2ifc(v2)
        end
        if (not v2) or (v1.ifc_id~=v2.ifc_id) then
            ifc.matches[cls] = false
            return false
        end
    end

    -- yes, they match
    ifc.matches[cls] = true
    cls.matches[ifc] = true
    return true
end

-- unique numbers for vars and events
local _N = 0
local _E = 1    -- 0=NONE

function newvar (me, blk, pre, tp, id, isImp)
    for stmt in AST.iter() do
        if stmt.tag=='Async' or stmt.tag=='Thread' then
            break   -- search until Async boundary
        elseif stmt.tag == 'Block' then
            for _, var in ipairs(stmt.vars) do
                --ASR(var.id~=id or var.blk~=blk, me,
                    --'variable/event "'..var.id..
                    --'" is already declared at --line '..var.ln)
                if var.id == id then
                    local fun = pre=='function' and stmt==CLS().blk_ifc -- dcl
                                                and blk==CLS().blk_ifc  -- body
                    WRN(fun or id=='_ok' or isImp, me,
                        'declaration of "'..id..'" hides the one at line '
                            ..var.ln[2])
                    --if (blk==CLS().blk_ifc or blk==CLS().blk_body) then
                        --ASR(false, me, 'cannot hide at top-level block' )
                end
            end
        end
    end

    local c = ENV.c[tp.id]

    ASR(TOPS[tp.id] or c, me, 'undeclared type `'..(tp.id or '?')..'´')
    if TOPS[tp.id] and TOPS[tp.id].is_ifc and tp.ptr==0 and (not tp.ref) then
        ASR(pre == 'pool', me,
            'cannot instantiate an interface')
    end

    ASR(tp.ptr>0 or TP.get(tp.id).len~=0 or (tp.id=='void' and pre=='event'),
        me, 'cannot instantiate type "'..tp.id..'"')
    --ASR((not arr) or arr>0, me, 'invalid array dimension')

    local cls = (tp.ptr==0 and (not tp.ref) and TOPS[tp.id])
        if cls then
            ASR(cls ~=AST.iter'Dcl_cls'(), me, 'invalid declaration')
        end

    -- Class definitions take priority over interface definitions:
    --      * consts
    --      * rec => norec methods
    if  blk.vars[id] and (blk==CLS().blk_ifc) then
        return true, blk.vars[id]
    end

    local var = {
        ln    = me.ln,
        id    = id,
        blk   = blk,
        tp    = tp,
        cls   = cls or (pre=='pool'),   -- (case of _TOP_POOL & ifaces)
        pre   = pre,
        inTop = (blk==CLS().blk_ifc) or (blk==CLS().blk_body),
                -- (never "tmp")
        isTmp = false,
        --arr   = arr,
        n     = _N,
    }

    _N = _N + 1
    blk.vars[#blk.vars+1] = var
    blk.vars[id] = var -- TODO: last/first/error?
    -- TODO: warning in C (hides)

    return false, var
end

function newint (me, blk, pre, tp, id, isImp)
    local has, var = newvar(me, blk, pre,
                        {id='void',ptr=0,arr=false,ref=false,ext=false},
                        id, isImp)
    if has then
        return true, var
    end
    local evt = {
        id  = id,
        idx = _E,
        ins = tp,
        pre = pre,
    }
    var.evt = evt
    _E = _E + 1
    return false, var
end

function newfun (me, blk, pre, rec, ins, out, id, isImp)
    rec = not not rec
    local old = blk.vars[id]
    if old then
        ASR(TP.toc(ins)==TP.toc(old.fun.ins) and
            TP.toc(out)==TP.toc(old.fun.out) and
            (rec==old.fun.mod.rec or (not old.fun.mod.rec)),
            me, 'function declaration does not match the one at "'..
                old.ln[1]..':'..old.ln[2]..'"')
        -- Accept rec mismatch if old is not (old is the concrete impl):
        -- interface with rec f;
        -- class     with     f;
        -- When calling from an interface, call/rec is still required,
        -- but from class it is not.
    end

    local has, var = newvar(me, blk, pre,
                        TP.fromstr('___typeof__(CEU_'..CLS().id..'_'..id..')'),
                        -- TODO: TP.toc eats one '_'
                        id, isImp)
    if has then
        return true, var
    end
    local fun = {
        id  = id,
        ins = ins,
        out = out,
        pre = pre,
        mod = { rec=rec },
        isExt = string.upper(id)==id,
    }
    var.fun = fun
    return false, var
end

function ENV.getvar (id, blk)
    local blk = blk or AST.iter('Block')()
    while blk do
        if blk.tag=='Async' or blk.tag=='Thread' then
            local vars = unpack(blk)    -- VarList
            if not (vars and vars[id] and vars[id][1]) then
                return nil  -- async boundary: stop unless declared with `&´
            end
        elseif blk.tag == 'Block' then
            for i=#blk.vars, 1, -1 do   -- n..1 (hidden vars)
                local var = blk.vars[i]
                if var.id == id then
                    return var
                end
            end
        end
        blk = blk.__par
    end
    return nil
end

-- identifiers for ID_c / ID_ext (allow to be defined after annotations)
-- variables for Var
function det2id (v)
    if type(v) == 'string' then
        return v
    else
        return v.var
    end
end

F = {
    Type = function (me)
        TP.new(me)
    end,
    TupleType_pos = 'Type',

    Root_pre = function (me)
        -- TODO: NONE=0
        -- TODO: if PROPS.* then ... end

        local evt = {id='_STK', pre='input'}
        ENV.exts[#ENV.exts+1] = evt
        ENV.exts[evt.id] = evt

        -- TODO: shared with _INIT?
        local evt = {id='_ORG', pre='input'}
        ENV.exts[#ENV.exts+1] = evt
        ENV.exts[evt.id] = evt

        local evt = {id='_ORG_PSED', pre='input'}
        ENV.exts[#ENV.exts+1] = evt
        ENV.exts[evt.id] = evt

        local evt = {id='_INIT', pre='input'}
        ENV.exts[#ENV.exts+1] = evt
        ENV.exts[evt.id] = evt

        local evt = {id='_CLEAR', pre='input'}
        ENV.exts[#ENV.exts+1] = evt
        ENV.exts[evt.id] = evt

        local evt = {id='_WCLOCK', pre='input'}
        ENV.exts[#ENV.exts+1] = evt
        ENV.exts[evt.id] = evt

        if OPTS.timemachine then
            local evt = {id='_WCLOCK_', pre='input'}
            ENV.exts[#ENV.exts+1] = evt
            ENV.exts[evt.id] = evt
        end

        local evt = {id='_ASYNC', pre='input'}
        ENV.exts[#ENV.exts+1] = evt
        ENV.exts[evt.id] = evt

        local evt = {id='_THREAD', pre='input'}
        ENV.exts[#ENV.exts+1] = evt
        ENV.exts[evt.id] = evt

        -- need to reserve these events so that they always have the same code
        if OPTS.os then
            local t = {
                { 'OS_START',     'void' },
                { 'OS_STOP',      'void' },
                { 'OS_DT',        'int'  },
                { 'OS_INTERRUPT', 'int'  },
            }
            for _, v in ipairs(t) do
                local id, tp = unpack(v)
                local evt = {
                    ln  = me.ln,
                    id  = id,
                    pre = 'input',
                    ins = AST.node('Type', me.ln, tp, 0, false, false),
                    mod = { rec=false },
                }
                TP.new(evt.ins)
                ENV.exts[#ENV.exts+1] = evt
                ENV.exts[id] = evt
            end
        end
    end,

    Root = function (me)
        TP.types.tceu_ncls.len = TP.n2bytes(#ENV.clss_cls)
        ASR(ENV.max_evt+#ENV.exts < 255, me, 'too many events')
                                    -- 0 = NONE

        -- matches all ifc vs cls
        for _, ifc in ipairs(ENV.clss_ifc) do
            for _, cls in ipairs(ENV.clss_cls) do
                ENV.ifc_vs_cls(ifc, cls)
            end
        end
        local glb = ENV.clss.Global
        if glb then
            ASR(glb.is_ifc and glb.matches[ENV.clss.Main], me,
                'interface "Global" must be implemented by class "Main"')
        end
    end,

    Block_pre = function (me)
        me.vars = {}
        if me.__par.tag=='Async' or me.__par.tag=='Thread' then
            local vars, blk = unpack(me.__par)
            if vars then
                -- { &1, var2, &2, var2, ... }
-- TODO: make on adj.lua ?
                for i=1, #vars, 2 do -- create new variables for params
                    local isRef, n = vars[i], vars[i+1]
                    local var = n.var
                    --ASR(not var.arr, vars, 'invalid argument')

                    if not isRef then
                        local _
                        _,n.new = newvar(vars, blk, 'var', var.tp, var.id, false)
                    end
                end
            end
        end

        -- include arguments into function block
        local fun = AST.iter()()
        local _, _, inp, out = unpack(fun)
        if fun.tag == 'Dcl_fun' then
            for i, v in ipairs(inp) do
                local _, tp, id = unpack(v)
                if tp ~= 'void' then
                    local has,var = newvar(fun, me, 'var', tp, id, false)
                    assert(not has)
                    var.isTmp  = true -- TODO: var should be a node
                    var.isFun  = true
                    var.funIdx = i
                end
            end
        end
    end,

    Dcl_cls_pre = function (me)
        local ifc, id, blk = unpack(me)
        me.c = {}      -- holds all "native _f()"
        me.tp = TP.fromstr(id)
        ASR(not ENV.clss[id], me,
                'interface/class "'..id..'" is already declared')

        -- restart variables/events counting
        _N = 0
        _E = 1  -- 0=NONE

        ENV.clss[id] = me
        ENV.clss[#ENV.clss+1] = me

        if me.is_ifc then
            me.n = #ENV.clss_ifc   -- TODO: n=>?
            ENV.clss_ifc[id] = me
            ENV.clss_ifc[#ENV.clss_ifc+1] = me
        else
            me.n = #ENV.clss_cls   -- TODO: remove Main?   -- TODO: n=>?
            ENV.clss_cls[id] = me
            ENV.clss_cls[#ENV.clss_cls+1] = me
        end
    end,
    Dcl_cls = function (me)
        ENV.max_evt = MAX(ENV.max_evt, _E)

        -- all identifiers in all interfaces get a unique (sequential) N
        if me.is_ifc then
            for _, var in pairs(me.blk_ifc.vars) do
                var.ifc_id = var.ifc_id or var2ifc(var)
                if not ENV.ifcs[var.ifc_id] then
                    if var.pre=='var' or var.pre=='pool' then
                        ENV.ifcs.flds[var.ifc_id] = #ENV.ifcs.flds
                        ENV.ifcs.flds[#ENV.ifcs.flds+1] = var.ifc_id
                        if var.pre == 'pool' then
                            ENV.ifcs.trls[var.ifc_id] = #ENV.ifcs.trls
                            ENV.ifcs.trls[#ENV.ifcs.trls+1] = var.ifc_id
                        end
                    elseif var.pre == 'event' then
                        ENV.ifcs.evts[var.ifc_id] = #ENV.ifcs.evts
                        ENV.ifcs.evts[#ENV.ifcs.evts+1] = var.ifc_id
                    elseif var.pre == 'function' then
                        ENV.ifcs.funs[var.ifc_id] = #ENV.ifcs.funs
                        ENV.ifcs.funs[#ENV.ifcs.funs+1] = var.ifc_id
                    end
                end
            end
        end
    end,

    Dcl_det = function (me)                 -- TODO: verify in ENV.c
        local id1 = det2id(me[1])
        local t1 = ENV.dets[id1] or {}
        ENV.dets[id1] = t1
        for i=2, #me do
            local id2 = det2id(me[i])
            local t2 = ENV.dets[id2] or {}
            ENV.dets[id2] = t2
            t1[id2] = true
            t2[id1] = true
        end
    end,

    Global = function (me)
        ASR(ENV.clss.Global and ENV.clss.Global.is_ifc, me,
            'interface "Global" is not defined')
        me.tp   =TP.fromstr'Global*'
        me.lval = false
        me.blk  = AST.root
    end,

    Outer = function (me)
        local cls = CLS()
            --ASR(cls ~= MAIN, me, 'invalid access')
        ASR(cls, me, 'undeclared class')
        me.tp   = cls.tp
        me.lval = false
        me.blk  = cls.blk_ifc
    end,

    This = function (me)
        -- if inside constructor, change scope to the class being created
        local constr = AST.iter'Dcl_constr'()
        local cls = constr and constr.cls or CLS()
        ASR(cls, me, 'undeclared class')
        me.tp   = cls.tp
        me.lval = false
        me.blk  = cls.blk_ifc
    end,

    Free = function (me)
        local exp = unpack(me)
        ASR(exp.tp.ptr==1 and ENV.clss[exp.tp.id], me, 'invalid `free´')
    end,

    Dcl_ext = function (me)
        local dir, rec, ins, out, id = unpack(me)
        local ext = ENV.exts[id]
        if ext then
            local eq = (ext.pre==dir and ext.mod.rec==rec and
                        ext.out==(out or 'int') and TP.contains(ext.ins,ins))
            WRN(eq, me, 'event "'..id..'" is already declared')
            return
        end

        ASR(ins.tup or ins.id=='void' or ins.id=='int' or ins.ptr>0,
            me, 'invalid event type')
        ASR((not ins.arr) and (not ins.ref),
            me, 'invalid event type')

        me.evt = {
            ln  = me.ln,
            id  = id,
            pre = dir,
            ins = ins,
            out = out or 'int',
            mod = { rec=rec },
            op  = (out and 'call' or 'emit')
        }
        ENV.exts[#ENV.exts+1] = me.evt
        ENV.exts[id] = me.evt
    end,

    Dcl_var_pre = function (me)
        -- changes TP from ast.lua
        if me.__ast_ref then
            local t, i = unpack(me.__ast_ref)
            local ref = t[i]
            local evt = ref.evt or (ref.var and ref.var.evt)
            ASR(evt, me,
                'event "'..(ref.var and ref.var.id or '?')..'" is not declared')
            ASR(evt.ins.tup, me, 'invalid arity' )
            me[2][1] = '_'..TP.toc(evt.ins)
        end
    end,
    Dcl_var = function (me)
        local pre, tp, id, constr = unpack(me)
        if id == '_' then
            id = id..me.n   -- avoids clash with other '_'
        end
        local has
        has, me.var = newvar(me, AST.iter'Block'(), pre, tp, id, me.isImp)
        assert(not has or (me.var.read_only==nil))
        me.var.read_only = me.read_only
        if constr then
            ASR(me.var.cls, me, 'invalid type')
            constr.blk = me.var.blk
        end
    end,
    Dcl_pool = function (me)
        local pre, tp, id, constr = unpack(me)
        ASR(tp.arr, me, 'missing `pool´ dimension')
        F.Dcl_var(me)
    end,

    Dcl_int = function (me)
        local pre, tp, id = unpack(me)
        if id == '_' then
            id = id..me.n   -- avoids clash with other '_'
        end
        ASR(tp.id=='void' or TP.isNumeric(tp) or
            tp.ptr>0      or tp.tup,
                me, 'invalid event type')
        ASR(not tp.ref, me, 'invalid event type')
        if tp.tup then
            for _, t in ipairs(tp.tup) do
                ASR((TP.isNumeric(t) or t.ptr>0) and (not t.ref),
                    me, 'invalid event type')
            end
        end
        local _
        _, me.var = newint(me, AST.iter'Block'(), pre, tp, id, me.isImp)
    end,

    Dcl_fun = function (me)
        local pre, rec, ins, out, id, blk = unpack(me)
        local cls = CLS()

        -- implementation cannot be inside interface, so,
        -- if it appears on blk_body, make it be in blk_ifc
        local up = AST.iter'Block'()
        if blk and cls.blk_body==up and cls.blk_ifc.vars[id] then
            up = cls.blk_ifc
        end

        local _
        _, me.var = newfun(me, up, pre, rec, ins, out, id, me.isImp)

        -- "void" as parameter only if single
        if #ins > 1 then
            for _, v in ipairs(ins) do
                local _, tp, _ = unpack(v)
                ASR(tp ~= 'void', me, 'invalid declaration')
            end
        end

        if not blk then
            return
        end

        -- full definitions must contain parameter ids
        for _, v in ipairs(ins) do
            local _, tp, id = unpack(v)
            ASR(tp=='void' or id, me, 'missing parameter identifier')
        end
    end,

    Ext = function (me)
        local id = unpack(me)
        me.evt = ASR(ENV.exts[id], me,
                    'event "'..id..'" is not declared')
    end,

    Var = function (me)
        local id = unpack(me)

        local blk = me.__adj_blk and assert(AST.par(me.__adj_blk,'Block'))
                        or AST.iter('Block')()
        local var = ENV.getvar(id, blk)
        ASR(var, me, 'variable/event "'..id..'" is not declared')
        me.var  = var
        me.tp   = var.tp
        me.lval = not (var.pre~='var' or var.cls or var.tp.arr)
                    and var
    end,

    Dcl_nat = function (me)
        local mod, tag, id, len = unpack(me)
        if tag=='type' or mod=='@plain' then
            local tp = TP.fromstr(id)
            tp.len   = len
            tp.plain = (mod=='@plain')
            TP.types[id] = tp
        end
        -- TODO: remove
        ENV.c[id] = { tag=tag, id=id, len=len, mod=mod }
    end,

    Dcl_pure = function (me)
        ENV.pures[me[1]] = true
    end,

    AwaitS = function (me)
        local wclock
        for _, awt in ipairs(me) do
            if awt.__ast_isexp then
                F.AwaitInt(me, awt)
            elseif awt.tag~='Ext' then
                ASR(not wclock, me,
                    'invalid await: multiple timers')
                wclock = true
            end
        end
        error'me.fst'
        --me.fst = ?
    end,

    ParOr = function (me)
        -- detects if "isWatching" a real event (not an org)
        --  to remove the "isAlive" test
        if me.isWatching then
            local tp = me.isWatching.tp
            if not (tp and tp.ptr==1 and ENV.clss[tp.id]) then
                local if_ = me[1][1][2]
                assert(if_ and if_.tag == 'If')
                me[1][1][2] = if_[2]    -- changes "if" for the "await" (true branch)
                --if_[1] = AST.node('NUMBER', me.ln, 1)
            end
        end
    end,

    AwaitInt_pre = function (me)
        local int = unpack(me)
        if me.isWatching then
            -- ORG: "await org" => "await org._ok"
            if int.tp.ptr==1 and ENV.clss[int.tp.id] then
                me[1] = AST.node('Op2_.', me.ln, '.',
                            AST.node('Op1_*', me.ln, '*', int),
                            '_ok')

            -- EVT:
            else
--error'oi'
            end
        end
    end,
    AwaitInt = function (me)
        local int = unpack(me)
        ASR(int.var and int.var.pre=='event', me,
            'event "'..(int.var and int.var.id or '?')..'" is not declared')
        if int.var.evt.ins.tup then
            me.tp = TP.fromstr('_'..TP.toc(int.var.evt.ins)..'*') -- convert to pointer
        else
            me.tp = int.var.evt.ins
        end
    end,

    AwaitExt = function (me)
        local ext = unpack(me)
        if ext.evt.ins.tup then
            me.tp = TP.fromstr('_'..TP.toc(ext.evt.ins)..'*') -- convert to pointer
        else
            me.tp = ext.evt.ins
        end
    end,
    AwaitT = function (me)
        me.tp = TP.fromstr's32'    -- <a = await ...>
    end,

    __arity = function (me, ins, ps)
        local n_evt, n_exp
        if ins.tup then
            n_evt = #ins.tup
        elseif ins.id=='void' and ins.ptr==0 then
            n_evt = 0
        else
            n_evt = 1
        end
        if ps then
            if ps.tag == 'ExpList' then
                n_exp = #ps
            else
                n_exp = 1
            end
        else
            n_exp = 0
        end
        ASR(n_evt==n_exp, me, 'invalid arity')

        if n_evt == 1 then
            ASR(TP.contains(ins,ps.tp), me,
                'non-matching types on `emit´ ('..TP.tostr(ins)..' vs '..TP.tostr(ps.tp)..')')
        end
    end,

    EmitInt = function (me)
        local _, int, ps = unpack(me)
        local var = int.var
        ASR(var and var.pre=='event', me,
            'event "'..(var and var.id or '?')..'" is not declared')
        --ASR(var.evt.ins.id=='void' or (ps and TP.contains(var.evt.ins,ps.tp)),
            --me, 'invalid `emit´')
        F.__arity(me, var.evt.ins, me.ps)

--[[
-- should fail on arity or individual assignments
        if ps then
            local tp = var.evt.ins
            if var.evt.ins.tup then
                tp = TP.fromstr('_'..TP.toc(tp)..'*') -- convert to pointer
            end
            ASR(TP.contains(tp,ps.tp), me,
                'non-matching types on `emit´ ('..TP.tostr(tp)..' vs '..TP.tostr(ps.tp)..')')
        else
            ASR(var.evt.ins.id=='void' or
                var.evt.ins.tup and #var.evt.ins.tup==0,
                me, "missing parameters on `emit´")
        end
]]
    end,

    EmitExt = function (me)
        local op, ext, ps = unpack(me)

        ASR(ext.evt.op == op, me, 'invalid `'..op..'´')
        F.__arity(me, ext.evt.ins, me.ps)

        if op == 'call' then
            me.tp = ext.evt.out     -- return value
        else
            me.tp = TP.fromstr'int'           -- [0,1] enqueued? (or 'int' return val)
        end

--[[
-- should fail on arity or individual assignments
        if ps then
            local tp = ext.evt.ins
            if ext.evt.ins.tup then
                --tp = TP.fromstr('_'..TP.toc(tp)..'*') -- convert to pointer
            end
            ASR(TP.contains(tp,ps.tp), me,
                'non-matching types on `'..op..'´ ('..TP.tostr(tp)..' vs '..TP.tostr(ps.tp)..')')
        else
            ASR(ext.evt.ins.id=='void' or
                ext.evt.ins.tup and #ext.evt.ins.tup==0,
                me, "missing parameters on `emit´")
        end
]]
    end,

    --------------------------------------------------------------------------

    SetExp = function (me)
        local _, fr, to = unpack(me)
        to = to or AST.iter'SetBlock'()[1]
        ASR(to and to.lval, me, 'invalid attribution')
        ASR(TP.contains(to.tp,fr.tp), me,
            'invalid attribution ('..TP.tostr(to.tp)..' vs '..TP.tostr(fr.tp)..')')
        ASR(me.read_only or (not to.lval.read_only), me,
            'read-only variable')
        ASR(not CLS().is_ifc, me, 'invalid attribution')

        -- remove byRef flag if normal assignment
        if not to.tp.ref then
            to.byRef = false
            fr.byRef = false
        end

        -- lua type
--[[
        if fr.tp == '@' then
            fr.tp = to.tp
            ASR(TP.isNumeric(fr.tp) or fr.tp=='bool' or fr.tp=='char*', me,
                'invalid attribution')
        end
]]
    end,

    Lua = function (me)
        if me.ret then
            ASR(not me.ret.tp.ref, me, 'invalid attribution')
            me.ret.byRef = false
        end
    end,

    Free = function (me)
        local exp = unpack(me)
        local id = ASR(exp.tp.ptr>0, me, 'invalid `free´')
        me.cls = ASR( ENV.clss[id], me,
                        'class "'..id..'" is not declared')
    end,

    -- _pre: give error before "set" inside it
    Spawn_pre = function (me)
        local id, pool, constr = unpack(me)

        me.cls = ASR(ENV.clss[id], me,
                        'class "'..id..'" is not declared')
        ASR(not me.cls.is_ifc, me, 'cannot instantiate an interface')
        me.tp = TP.fromstr(id..'*')  -- class id
    end,
    IterIni = 'RawExp',
    IterNxt = 'RawExp',

    Dcl_constr_pre = function (me)
        local spw = AST.iter'Spawn'()
        local dcl = AST.iter'Dcl_var'()

        -- type check for this.* inside constructor
        if spw then
            me.cls = ENV.clss[ spw[1] ]   -- checked on Spawn
        elseif dcl then
            me.cls = ENV.clss[ dcl[2].id ]   -- checked on Dcl_var
        end
        --assert(me.cls)
    end,

    CallStmt = function (me)
        local call = unpack(me)
        ASR(call.tag == 'Op2_call', me, 'invalid statement')
    end,

    Thread = function (me)
        me.tp = TP.fromstr'int'       -- 0/1
    end,

    --------------------------------------------------------------------------

    Op2_call = function (me)
        local _, f, p, _ = unpack(me)
        me.tp  = f.var and f.var.fun and f.var.fun.out or TP.fromstr'@'
        local id
        if f.tag == 'Nat' then
            id   = f[1]
            me.c = ENV.c[id]
        elseif f.tag == 'Op2_.' then
            id   = f.id
            if f.org then   -- t._f()
                me.c = assert(ENV.clss[f.org.tp.id]).c[f.id]
            else            -- _x._f()
                me.c = f.c
            end
        else
            id = (f.var and f.var.id) or '$anon'
            me.c = { tag='func', id=id, mod=nil }
        end

        ASR((not OPTS.c_calls) or OPTS.c_calls[id], me,
                'native calls are disabled')

        if not me.c then
            me.c = { tag='func', id=id, mod=nil }
            ENV.c[id] = me.c
        end
        --ASR(me.c and me.c.tag=='func', me,
            --'native function "'..id..'" is not declared')

        ENV.calls[id] = true
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
        ASR(arr.tp.arr or arr.tp.ptr>0 or arr.tp.ext, me,
            'cannot index a non array')
        ASR(TP.isNumeric(idx.tp), me, 'invalid array index')

        me.tp = TP.copy(arr.tp)
            if arr.tp.arr then
                me.tp.arr = false
            elseif arr.tp.ptr>0 then
                me.tp.ptr = me.tp.ptr - 1
            end

        if me.tp.ptr==0 and ENV.clss[me.tp.id] then
            me.lval = false
        else
            me.lval = arr
        end
    end,

    Op2_int_int = function (me)
        local op, e1, e2 = unpack(me)
        me.tp  = TP.fromstr'int'
        ASR(TP.isNumeric(e1.tp) and TP.isNumeric(e2.tp), me,
                'invalid operands to binary "'..op..'"')
    end,
    ['Op2_-']  = 'Op2_int_int',
    ['Op2_+']  = 'Op2_int_int',
    ['Op2_%']  = 'Op2_int_int',
    ['Op2_*']  = 'Op2_int_int',
    ['Op2_/']  = 'Op2_int_int',
    ['Op2_|']  = 'Op2_int_int',
    ['Op2_&']  = 'Op2_int_int',
    ['Op2_<<'] = 'Op2_int_int',
    ['Op2_>>'] = 'Op2_int_int',
    ['Op2_^']  = 'Op2_int_int',

    Op1_int = function (me)
        local op, e1 = unpack(me)
        me.tp  = TP.fromstr'int'
        ASR(TP.isNumeric(e1.tp), me,
                'invalid operand to unary "'..op..'"')
    end,
    ['Op1_~']  = 'Op1_int',
    ['Op1_-']  = 'Op1_int',
    ['Op1_+']  = 'Op1_int',

    Op2_same = function (me)
        local op, e1, e2 = unpack(me)
        me.tp  = TP.fromstr'int'
        ASR(TP.max(e1.tp,e2.tp), me,
            'invalid operands to binary "'..op..'"')
    end,
    ['Op2_=='] = 'Op2_same',
    ['Op2_!='] = 'Op2_same',
    ['Op2_>='] = 'Op2_same',
    ['Op2_<='] = 'Op2_same',
    ['Op2_>']  = 'Op2_same',
    ['Op2_<']  = 'Op2_same',

    Op2_any = function (me)
        me.tp  = TP.fromstr'int'
    end,
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',
    ['Op1_not'] = 'Op2_any',

    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
        me.lval = e1.lval and e1
        me.tp   = TP.copy(e1.tp)
        if e1.tp.ptr > 0 then
            me.tp.ptr = me.tp.ptr - 1
        end
        ASR(e1.tp.ptr>0 or (me.tp.ext and (not me.tp.plain) and (not TP.get(me.tp.id).plain)),
            me, 'invalid operand to unary "*"')
    end,

    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        ASR(ENV.clss[e1.tp.id] or e1.lval, me, 'invalid operand to unary "&"')
        me.lval = false
        me.tp   = TP.copy(e1.tp)
        me.tp.ptr = me.tp.ptr + 1
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)
        local cls = e1.tp.ptr==0 and ENV.clss[e1.tp.id]
        me.id = id
        if cls then
            me.org = e1

            -- me[3]: id => Var
            local var
            if e1.tag == 'This' then
                -- accept private "body" vars
                var = cls.blk_body.vars[id]
                    --[[
                    -- class T with
                    -- do
                    --     var int a;
                    --     this.a = 1;
                    -- end
                    --]]
            end
            var = var or ASR(cls.blk_ifc.vars[id], me,
                        'variable/event "'..id..'" is not declared')
            me[3] = AST.node('Var', me.ln, '$'..id)
            me[3].var = var
            me[3].tp  = var.tp

            me.org  = e1
            me.var  = var
            me.tp   = var.tp
            me.lval = not (var.pre~='var' or var.cls or var.tp.arr)
                        and var
        else
            assert(not e1.tp.tup)   -- TODO: remove
            ASR(me.__ast_chk or e1.tp.ext, me, 'not a struct')
            if me.__ast_chk then
                -- check Emit/Await-Ext/Int param
                local T, i = unpack(me.__ast_chk)
                local t, j = unpack(T)
                local chk = t[j]
                local evt = chk.evt or chk.var.evt  -- EmitExt or EmitInt
                assert(evt.ins and evt.ins.tup)
                me.tp = ASR(evt.ins.tup[i], me, 'invalid arity')
            else
                -- rect.x = 1 (_SDL_Rect)
                me.tp = TP.fromstr'@'
                local tp = TP.get(e1.tp.id)
                if tp.plain and e1.tp.ptr==0 then
                    me.tp.plain = true
                    me.tp.ptr   = 0
                end
            end
            me.lval = e1.lval
        end
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        me.tp   = tp
        me.lval = exp.lval
    end,

    Nat = function (me)
        local id = unpack(me)
        local c = ENV.c[id] or {}
        ASR(c.tag~='type', me,
            'native variable/function "'..id..'" is not declared')
        me.id   = id
        me.tp   = TP.fromstr'_'
        me.lval = me
        me.c    = c
    end,
    RawExp = function (me)
        me.tp   = TP.fromstr'_'
        me.lval = me
    end,

    WCLOCKK = function (me)
        me.tp   = TP.fromstr'int'
        me.lval = false
    end,
    WCLOCKE = 'WCLOCKK',

    SIZEOF = function (me)
        me.tp   = TP.fromstr'int'
        me.lval = false
        me.const = true
    end,

    STRING = function (me)
        me.tp   = TP.fromstr'char*'
        me.lval = false
        me.const = true
    end,
    NUMBER = function (me)
        local v = unpack(me)
        ASR(string.sub(v,1,1)=="'" or tonumber(v), me, 'malformed number')
        if string.find(v,'%.') or string.find(v,'e') or string.find(v,'E') then
            me.tp = TP.fromstr'float'
        else
            me.tp = TP.fromstr'int'
        end
        me.lval = false
        me.const = true
    end,
    NULL = function (me)
        me.tp   = TP.fromstr'null*'
        me.lval = false
        me.const = true
    end,
}

AST.visit(F)

end

    
do
F = {
    SetExp = function (me)
        local _, fr, to = unpack(me)
        if fr.tag=='Ref' and fr[1].tag=='Spawn' then
            -- a = spawn T
            fr[1].blk = to.lst.var.blk   -- to = me.__par[3]

            -- refuses (x.ptr = spawn T;)
            ASR( AST.isParent(CLS(),to.lst.var.blk), me,
                    'invalid attribution (no scope)' )
        end

        -- refuses:
        -- var int& i = 1;
        -- var int& i = *p;
        if to.byRef and (not fr.tp.ref) then
            ASR(fr.lval or (fr.lst and (fr.lst.tag=='Outer' or
                                        fr.lst.var and fr.lst.var.cls)),
                                           -- orgs are not lval
                me, 'invalid attribution (not a reference)')
            ASR(not AST.child(fr,'Op1_*'), me, 'invalid attribution')
        end

    end,

    Spawn = function (me)
        local _,pool,_ = unpack(me)
        ASR(pool and pool.lst and pool.lst.var and pool.lst.var.tp.arr, me,
            'invalid pool')
    end,

-- EXPS --

    Node = function (me)
        me.fst = me.fst or me
        me.lst = me.lst or me
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
        me.fst = arr.fst
        me.lst = arr.lst
    end,

    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
        me.fst = e1.fst
        me.lst = e1.lst
    end,

    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        me.fst = e1.fst
        me.lst = e1.lst
        me.lst.amp = true
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)
        local cls = e1.tp.ptr==0 and ENV.clss[e1.tp.id]
        if cls then
            -- org.var => var
            me.lst = me[3]
        else
            -- s.x => s
            me.lst = e1.lst
        end
        me.fst = e1.fst
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        me.fst = exp.fst
        me.lst = exp.lst
        me.isConst = exp.isConst
    end,

    NUMBER = function (me)
        me.isConst = true
    end,
    STRING = 'NUMBER',
    NULL   = 'NUMBER',
}

AST.visit(F)

end

    
do
local _ceu2c = { ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

--[[
-- Fills nodes with "sval" and "cval".
-- sval: static value
-- cval: C value
--]]

F =
{
    Dcl_var = function (me)
        if me.var.cls then
            if me.var.tp.arr then
                ASR(me.var.tp.arr.sval, me, 'invalid static expression')
            end
        end
    end,

    Op2_call = function (me)
        local _, f, ins = unpack(me)
        if not f.cval then
            return
        end
        local ps = {}
        for i, exp in ipairs(ins) do
            if not exp.cval then
                return
            end
            ps[i] = exp.cval
        end
        me.cval = f.cval..'('..table.concat(ps,',')..')'
    end,

    Op2_any = function (me)
        local op, e1, e2 = unpack(me)
        if e1.cval and e2.cval then
            me.cval = '('..e1.cval..ceu2c(op)..e2.cval..')'
        end

        if e1.sval and e2.sval then
            local v = loadstring('return '..e1.sval..op..e2.sval)
            me.sval = v and tonumber(v())
        end
    end,
    ['Op2_-']   = 'Op2_any',
    ['Op2_+']   = 'Op2_any',
    ['Op2_%']   = 'Op2_any',
    ['Op2_*']   = 'Op2_any',
    ['Op2_/']   = 'Op2_any',
    ['Op2_|']   = 'Op2_any',
    ['Op2_&']   = 'Op2_any',
    ['Op2_<<']  = 'Op2_any',
    ['Op2_>>']  = 'Op2_any',
    ['Op2_^']   = 'Op2_any',
    ['Op2_==']  = 'Op2_any',
    ['Op2_!=']  = 'Op2_any',
    ['Op2_>=']  = 'Op2_any',
    ['Op2_<=']  = 'Op2_any',
    ['Op2_>']   = 'Op2_any',
    ['Op2_<']   = 'Op2_any',
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',

    Op1_any = function (me)
        local op, e1 = unpack(me)
        if e1.cval then
            me.cval = '('..ceu2c(op)..e1.cval..')'
        end
        if e1.sval then
            local v = loadstring(op..e1.sval)
            me.sval = v and tonumber(v())
        end
    end,
    ['Op1_~']   = 'Op1_any',
    ['Op1_-']   = 'Op1_any',
    ['Op1_+']   = 'Op1_any',
    ['Op1_not'] = 'Op1_any',

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        if exp.cval then
            me.cval = '(('..TP.toc(tp)..')'..exp.cval..')'
        end
    end,

    RawExp = function (me)
        me.cval = unpack(me)
    end,

    Nat = function (me)
        me.cval = string.sub(me[1], 2)
    end,
    STRING = function (me)
        me.cval = me[1]
    end,
    NUMBER = function (me)
        me.cval = me[1]
        me.sval = tonumber(me[1])
    end,
    NULL = function (me)
        me.cval = '((void *)0)'
        me.sval = '((void *)0)'
    end,
}

AST.visit(F)

end

    
do
--[[
-- If an ISR acesses a symbol (Var/Nat), then all accesses outside it must be
-- atomic.
-- In the first pass "F", we mark all symbols accessed in ISRs.
-- In the second pass "G", we check if all accesses are protected.
--
-- If an ISR accesses a pointer or makes a call, we warn that this breaks the
-- analysis.
-- If outside gets a reference to a symbol used in an ISR, we warn that this
-- breaks the analysis.
--]]

local accs = {}

local function inIsr (me)
    local fun = AST.par(me, 'Dcl_fun')
    return fun and fun.var.pre=='isr'
end

local msg = 'breaks the static check for `atomic´ sections'

F = {
    Var = function (me)
        if inIsr(me) then
            accs[me.var] = true
            local isPtr = me.var.tp.ptr>0 and (not me.var.tp.arr)
            WRN(not isPtr, me, 'pointer access '..msg)
        end
    end,
    Nat = function (me)
        if inIsr(me) and (me.c.mod~='@pure') then
            accs[me.id] = true
        end
    end,
    Op2_call = function (me)
        if inIsr(me) then
            WRN((me.c and me.c.mod=='@pure'), me,
                'call '..msg)
        end
    end,
}

G = {
    Var = function (me)
        if inIsr(me) or AST.par(me,'Dcl_var') then
            return  -- ignore isrs and var declarations
        end
        if accs[me.var] then
            ASR( AST.par(me,'Atomic'), me,
                    'access to "'..me.var.id..'" must be atomic' )
        end
    end,
    Nat = function (me)
        if inIsr(me) or AST.par(me,'Native') then
            return  -- ignore isrs and native declarations
        end
        if accs[me.id] then
            ASR( AST.par(me,'Atomic'), me,
                    'access to "'..me.id..'" must be atomic' )
        end
    end,
    ['Op1_&'] = function (me)
        if accs[me.lst.var] then
            WRN(false, me, 'reference access '..msg)
        end
    end,
}

AST.visit(F)
AST.visit(G)

end

    
do
TIGHT = false

function OR_all (me, t)
    t = t or me
    me.tl_awaits  = false
    me.tl_escapes = false
    me.tl_blocks  = false
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            me.tl_awaits  = me.tl_awaits  or sub.tl_awaits
            me.tl_escapes = me.tl_escapes or sub.tl_escapes
            me.tl_blocks  = me.tl_blocks  or sub.tl_blocks
        end
    end
end

function AND_all (me, t)
    t = t or me
    me.tl_awaits  = true
    me.tl_escapes = true
    me.tl_blocks  = true
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            me.tl_awaits  = me.tl_awaits  and sub.tl_awaits
            me.tl_escapes = me.tl_escapes and sub.tl_escapes
            me.tl_blocks  = me.tl_blocks  and sub.tl_blocks
        end
    end
end

function SAME (me, sub)
    me.tl_awaits  = sub.tl_awaits
    me.tl_escapes = sub.tl_escapes
    me.tl_blocks  = sub.tl_blocks
end

F = {
    Node_pre = function (me)
        me.tl_awaits  = false
        me.tl_escapes = false
        me.tl_blocks  = false
    end,
    Node = function (me)
        if not F[me.tag] then
            OR_all(me)
        end
    end,

    Stmts   = OR_all,

    ParEver = OR_all,
    ParAnd  = OR_all,
    ParOr   = AND_all,

    If = function (me)
        local c, t, f = unpack(me)
        AND_all(me, {t,f})
    end,

    Break = function (me)
        me.tl_blocks = true
    end,

    Loop_pre = function (me)
        if me.bound then
            if me.bound == true then
                return      -- already "true"
            end
            local must, v = unpack(me.bound)
            if must then
                ASR(v.cval, me, '`loop´ bound must be constant')
                me.bound = true
            elseif v.cval then
                me.bound = true
            else
                me.bound = false
            end
        end
    end,

    Loop = function (me)
        local body = unpack(me)
        SAME(me, body)
        local isTight = (not AST.iter(AST.pred_async)())
                            and (not body.tl_blocks)
                            and (not me.bound)
        WRN(not isTight, me, 'tight loop')
        TIGHT = TIGHT or isTight
        me.tl_blocks = me.bound or (body.tl_awaits or body.tl_escapes)

        local dcl = AST.iter'Dcl_fun'()
        if dcl and isTight then
            dcl.var.fun.isTight = true
        end
    end,

    SetBlock = function (me)
        local blk,_ = unpack(me)
        SAME(me, blk)
        me.tl_escapes = false
    end,
    Escape = function (me)
        me.tl_escapes = true
        me.tl_blocks  = true
    end,

    Thread = 'Async',
    Async = function (me)
        local _,body = unpack(me)
        SAME(me, body)
        me.tl_awaits = true
        me.tl_blocks = true
    end,

    AwaitExt = function (me)
        me.tl_awaits = true
        me.tl_blocks = true
    end,
    AwaitInt = 'AwaitExt',
    AwaitT   = 'AwaitExt',
    AwaitN   = 'AwaitExt',
    AwaitS   = 'AwaitExt',

    Op2_call = function (me)
        local op, f, _ = unpack(me)

        if not (f.var and f.var.fun) then
            return  -- ignore native and pointer calls
        end

        -- if calling a tight (or unknown) function,
        --  then the top function is also tight
        local dcl = AST.iter'Dcl_fun'()
        if dcl and (f.var.fun.isTight or f.var.fun.isTight==nil) then
            dcl.var.fun.isTight = true
            ASR(dcl.var.fun.mod.rec == true,
                dcl, 'function must be declared with `recursive´')
        end

        -- assert that the call is using call/rec correctly
        if f.var.fun.mod.rec then
            ASR(op=='call/rec',
                me, '`call/rec´ is required for "'..f.var.fun.id..'"')
        else
            ASR(op=='call',
                me, '`call/rec´ is not required for "'..f.var.fun.id..'"')
        end
    end,
    Dcl_fun = function (me)
        local _, rec, _, _, id, blk = unpack(me)
        if not blk then
            return          -- pure declarations
        end

        -- if I'm not discovered as tight, then I'm not tight
        if me.var.fun.isTight == nil then
            me.var.fun.isTight = false
        end
        if me.var.fun.isTight then
            ASR(me.var.fun.mod.rec == me.var.fun.isTight,
                me, 'function must be declared with `recursive´')
        else
            WRN(me.var.fun.mod.rec == me.var.fun.isTight,
                me, 'function may be declared without `recursive´')
        end

        -- copy isTight to all matching interfaces with method "id"
        local matches = CLS().matches or {}
        for ifc in pairs(matches) do
            local var = ifc.blk_ifc.vars[id]
            if var then
                assert(var.fun)
                local t = var.fun.__tights or {}
                var.fun.__tights = t
                t[#t+1] = me.var.fun.isTight
            end
        end
    end,

    Root = function (me)
        -- check if all interface methods have "mod.rec"
        -- respecting their implementations
        for _, ifc in pairs(ENV.clss_ifc) do
            for _,var in ipairs(ifc.blk_ifc.vars) do
                if var.fun then
                    local t = var.fun.__tights or {}

                    -- If "rec", at least one implementation should
                    -- not be isTight.
                    if var.fun.mod.rec then
                        local ok = false
                        for _, isTight in ipairs(t) do
                            if isTight then
                                ok = true
                                break
                            end
                        end
                        WRN(ok, var.ln,
                            'function may be declared without `recursive´')

                    -- If not "rec", all implementations should be
                    -- isTight.
                    else
                        for _, isTight in ipairs(t) do
                            ASR((not isTight), var.ln,
                                'function must be declared with `recursive´')
                        end
                    end
                end
            end
        end
    end,
}

AST.visit(F)

end

    
do
-- Track all declared pointers to assert that they are not accessed across
-- await statements:
local TRACK = {
    --[var] = true,   -- tracking but no await yet
    --[var] = await,  -- an "await" happened while tracking "var"
                      --   now, any access to "var" yields error
}

-- TODO: TRACK por classe?

local function node2blk (n)
    return n.fst and n.fst.blk or
           n.fst and n.fst.var and n.fst.var.blk or
           MAIN.blk_ifc
end

F = {
    Dcl_cls_pre = function (me)
        TRACK = {}  -- restart tracking for each class
    end,

    SetExp = function (me)
        local op, fr, to = unpack(me)
        to = to or AST.iter'SetBlock'()[1]

        if fr.tag == 'Ref' then
            fr = fr[1]  -- Spawn, Thread, EmitExt
        end

        local cls = CLS()

    --
    -- NON-POINTER ATTRIBUTIONS (always safe)
    --

        local noptr =  (to.tp.ptr==0 and (not to.tp.arr) and
                        ((not to.tp.ext) or TP.get(to.tp.id).plain or to.tp.plain))
                    or (fr.tp.ptr==0 and (not fr.tp.arr) and
                        ((not fr.tp.ext) or TP.get(fr.tp.id).plain or fr.tp.plain))
                                            -- either native dcl or derived
                                            -- from s.field

        -- byRef behaves like pointers
        noptr = noptr and (not to.byRef)

        -- var int[] a; do var int[] b=a; end
        noptr = noptr or (to.tp.buffer and fr.tp.buffer)

        if noptr then
            ASR(op == '=', me, 1101, 'wrong operator')
            ASR(not me.fin, me, 1102, 'attribution does not require `finalize´')
            return
        end

    --
    -- POINTER ATTRIBUTIONS
    --

        -- attribution in pool iterators
        if me.__ast_iter then
            return
        end

        -- an attribution restarts tracking accesses to "to"
        -- variables or native symbols
        if to.var or to.id then
            TRACK[to.var or to.id] = true
        end

        -- constants are safe
        if fr.sval then
            ASR(op == '=', me, 1103, 'wrong operator')
            ASR(not me.fin, me, 1104, 'attribution does not require `finalize´')
            return
        end

    -- NON-CONSTANT ATTRIBUTIONS

        -- determine "to_blk": block/scope for "to"
        local to_blk
        local constr = AST.iter'Dcl_constr'()
        if constr then
            -- var T t with
            --  this.x = y;     -- blk of this is the same as block of t
            -- end;
            -- spawn T with
            --  this.x = y;     -- blk of this is the same spawn pool
            -- end
            local dcl = AST.iter'Dcl_var'()
            if dcl then
                to_blk = dcl.var.blk
            else
                assert(constr.__par.tag=='Spawn')
                local _,pool,_ = unpack(constr.__par)
                assert(assert(pool.lst).var)
                to_blk = pool.lst.var.blk
            end
        else
            -- block where variable is defined
            to_blk = node2blk(to)
        end

    -- CHECK IF "FINALIZE" IS REQUIRED

        if fr.lst and fr.lst.tag=='Op2_call' and fr.lst.c.mod~='@pure'
        or fr.tag == 'RawExp' then
            -- We assume that a impure function that returns a global pointer
            -- creates memory (e.g. malloc, fopen):
            --      var int[] pa = _fopen();
            -- We assume that a RawExp that returns a global pointer
            -- creates memory (e.g. { new T }):
            --      var int[] pa = { new T() };
            -- In these cases, the return memory would persist when
            -- the local goes out of scope, hence, we require finalization.
            -- The "to" pointers must be `[]´.

            ASR(to.tp.buffer or to.tp.ext, me, 1105,
                    'destination pointer must be declared with the `[]´ buffer modifier')
                -- var void* ptr = _malloc(1);  // no
                -- _ptr = _malloc(1);           // ok

-- TODO: code
            ASR(me.fin, me, 'attribution requires `finalize´')
                -- var void[] ptr = _malloc(1);
            if me.fin then
                to_blk.fins = to_blk.fins or {}
                table.insert(to_blk.fins, 1, me.fin)
            end
            return
        end
-- TODO: code
        ASR(not me.fin, me, 'attribution does not require `finalize´')

    -- REFUSE THE FOLLOWING POINTER ATTRIBUTIONS:
        -- to pointers inside organisms (e.g., org.x=y)
        -- to pointers with greater scope than source
    -- (CHECK IF ":=" IS REQUIRED)

        -- refuse "org.x=y", unless "this" (inside constructor or not)
        -- "this" is easy to follow inside the single body
        -- other assignments are spread in multiple bodies
--[[
        if to.org and to.fst.tag~='This' then
-- TODO: code
            ASR(op==':=', me,
                'organism pointer attribution only inside constructors')
                -- var T t;
                -- t.v = null;

        else
]]
            -- OK: "fr" is a pointer to org (watching makes it safe)
            -- OK: "fr" `&´ reference has bigger scope than "to"
            -- int a; int* pa; pa=&a;
            -- int a; do int* pa; pa=&a; end
            local fr_blk = node2blk(fr)
            if not (
                fr.const                   or -- constants are globals
                fr.fst.tag == 'Nat'        or -- natives are globals
                (fr.tag=='Op2_call' and       -- native calls are globals
                 fr[2].fst.tag=='Nat')     or
                AST.iter'Dcl_constr'()     or -- org bodies can't hold
                (fr.org and                   -- "global:*" is global
                 fr.org.tp.id=='Global')   or
                (ENV.clss[to.tp.id] and       -- organisms must use "watching"
                 fr.tag~='Op1_&')          or -- (but avoid &org)
                string.sub(fr.tag,1,5) == 'Await' or -- pointer from outside
                (   -- same class and scope of "to" <= "fr"
                    (AST.par(to_blk,'Dcl_cls') == AST.par(fr_blk,'Dcl_cls')) and
                        (   to_blk.__depth >= fr_blk.__depth            -- to <= fr
                        or (to_blk.__depth==cls.blk_ifc.__depth and     --    or
                            fr_blk.__depth==cls.blk_body.__depth)       -- ifc/bdy
                        )
                )
            ) then
-- TODO: code
                ASR(op==':=', me, 'attribution to pointer with greater scope')
                    -- NO:
                    -- var int* p;
                    -- do
                    --     var int i;
                    --     p = &i;
                    -- end
            else
-- TODO: code
                ASR(op=='=', me, 'wrong operator')
            end
        --end

    -- FORCE @hold FOR UNSAFE ATTRIBUTIONS INSIDE FUNCTIONS

        local fun = AST.iter'Dcl_fun'()
        if op==':=' and fun and                          -- unsafe attribution
           (to_blk==cls.blk_ifc or to_blk==cls.blk_body) -- inside a function
        then                                             -- to ifc/body field
            -- must be hold
            local _, _, ins, _, _, _ = unpack(fun)
            -- functions/methods that hold pointers
            -- must annotate those arguments
            ASR(ins[fr.lst.var.funIdx][1], me, 1106, 'parameter must be `hold´')
                -- function (void* v)=>void f do
                --     _V := v;
                -- end
                -- class T with
                --     var void* a;
                -- do
                --     function (void* v)=>void f do
                --         this.a := v;
                --     end
                -- end
        end
    end,

    Dcl_var = function (me)
        if me.var.tp.ptr > 0 then
            TRACK[me.var] = true
        end
    end,

    Var = function (me)
        local set = AST.iter'SetExp'()
        if set and set[3] == me then
            return  -- re-setting variable
        end
        if not TRACK[me.var] then
            return  -- not tracking this var (not a pointer)
        end
        if TRACK[me.var]==true then
            return  -- no await happened yet
        end
        if me.var.tp.buffer or me.var.tp.arr then
            return  -- ignore tracked vars with []
        end
        if AST.iter'Dcl_constr'() and me.__par.fst.tag=='This' then
            return  -- constructor access
        end

        -- possible dangling pointer "me.var" is accessed across await

        if me.tp.ptr>0 and ENV.clss[me.tp.id] then
            -- pointer to org: check if it is enclosed by "watching me.var"
            -- since before the first await
            for n in AST.iter('ParOr') do
                local var = n.isWatching and n.isWatching.lst and n.isWatching.lst.var
                if var==me.var and AST.isParent(n,TRACK[me.var]) then
                    return      -- ok, I'm safely watching "me.var"
                end
            end
        end

        -- invalid access!
        ASR(false, me, 1107, 'pointer access across `await´')
    end,

    AwaitInt = function (me)
        if me.tl_awaits then
            for var, _ in pairs(TRACK) do
                if TRACK[var]==true then
                    TRACK[var] = me   -- tracks the *first* await
                end
            end
        end
    end,
    AwaitExt = 'AwaitInt',
    AwaitT   = 'AwaitInt',
    AwaitN   = 'AwaitInt',
    AwaitS   = 'AwaitInt',

    --Block    = 'AwaitInt',
    Async    = 'AwaitInt',
    Thread   = 'AwaitInt',
    ParOr    = 'AwaitInt',
    ParAnd   = 'AwaitInt',
    Par      = 'AwaitInt',

    --Loop     = 'AwaitInt',
    Loop = function (me)
        if me.isAwaitUntil then
            return
        else
            F.AwaitInt(me)
        end
    end,

    Finalize_pre = function (me, set, fin)
        if not fin then
            set, fin = unpack(me)
        end
        assert(fin[1].tag == 'Block')
        assert(fin[1][1].tag == 'Stmts')
        fin.active = fin[1] and fin[1][1] and
                        (#fin[1][1]>1 or
                         fin[1][1][1] and fin[1][1][1].tag~='Nothing')

        if AST.iter'Dcl_constr'() then
            ASR(not fin.active, me, 1108,
                    '`finalize´ inside constructor')
        end

        if set then
            set.fin = fin                   -- let call/set handle
        elseif fin.active then
            local blk = AST.iter'Block'()
            blk.fins = blk.fins or {}
            table.insert(blk.fins, 1, fin)  -- force finalize for this blk
        end
    end,

    Op2_call_pre = function (me)
        local _, f, exps, fin = unpack(me)
        if fin then
            F.Finalize_pre(me, me, fin)
        end
    end,
    Op2_call = function (me)
        local _, f, exps, fin = unpack(me)

        local req = false

        if not (me.c and (me.c.mod=='@pure' or me.c.mod=='@nohold')) then
            for i, exp in ipairs(exps) do
                local hold = true
                if f.var and f.var.fun then
                    hold = f.var.fun.ins.tup[i].hold
                end
                if hold then
                    -- int* pa; _f(pa);
                    --  (`pa´ termination must consider `_f´)
                    local r = (exp.tp.ptr>0 or exp.tp.ext or exp.tp.arr) and
                              (not exp.isConst) and
                              (not exp.c or exp.c.mod~='const')
                                    -- except constants

                    r = r and exp.fst and exp.fst.blk or
                        r and exp.fst and exp.fst.var and exp.fst.var.blk
                                -- need to hold block
-- TODO: ERR 10xx
                    WRN( (not r) or (not req) or (r==req),
                            me, 'invalid call (multiple scopes)')
                    req = req or r
                end
            end
        end

        if AST.iter'Thread'() then
            req = false     -- impossible to run finalizers on threads
        end

        ASR((not req) or fin or AST.iter'Dcl_fun'(), me, 1109,
            'call requires `finalize´')
        ASR((not fin) or req, me, 1110, 'invalid `finalize´')

        if fin and fin.active then
            req.fins = req.fins or {}
            table.insert(req.fins, 1, fin)
        end
    end,
}

AST.visit(F)

--[[
-- EVENTS:
--
-- The event emitter may pass a pointer that is already out of scope when the
-- awaking trail uses it:
--
-- event void* e;
-- var void* v = await e;
-- await ...;   // v goes out of scope
-- *v;          // segfault
--
-- We have to force the receiving "v" to go out of scope immediatelly:
--
--  event void* e;
--  do
--      var void* v = await e;
--      await ...;   // ERROR: cannot inside the "v" enclosing do-end
--      *v;
--  end
--
-------------------------------------------------------------------------------
--
-- FUNCTIONS:
--
-- When holding a parameter, a function could do either on native globals
-- or on object fields:
--
--      function (void* v1, void* v2)=>void f do
--          this.v = v1;    // OK
--          _V     = v2;    // NO!
--      end
--
-- For object fields, the caller must write a finalizer only if the
-- parameter has a shorter scope than the object of the method call:
--
--      // w/o fin
--      var void* p;
--      var T t;
--      t.f(p);     // t == p (scope)
--
--      // w/ fin
--      var T t;
--      do
--          var void* p;
--          t.f(p)      // t > p (scope)
--              finalize with ... end;
--      end
--
-- Native globals should be forbidden because we would need two different
-- kinds of "nohold" annotations to distinguish the two scopes (object and
-- global).
--
-- Native globals can be assigned in static functions requiring finalizer
-- whenever appliable.
]]

end

    --dofile 'awaits.lua'
    
do
PROPS = {
    has_exts    = false,
    has_wclocks = false,
    has_ints    = false,
    has_asyncs  = false,
    has_threads = false,
    has_orgs    = false,
    has_news    = false,
    has_news_pool   = false,
    has_news_malloc = false,
    has_ifcs    = false,
    has_clear   = false,
    has_pses    = false,
    has_ret     = false,
    has_lua     = false,
    has_orgs_watching = false,
}

local NO_atomic = {
    Finalize=true, Finally=true,
    Host=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    AwaitS=true, AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
    EmitInt=true, EmitExt=true,
    Pause=true,
    -- TODO:
    Loop=true, Break=true, Escape=true,
    Op2_call=true,
}

local NO_fun = {
    Finalize=true, Finally=true,
    Host=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    AwaitS=true, AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
    EmitInt=true, --EmitExt=true,
    Pause=true,
}

local NO_fin = {
    Finalize=true, Finally=true,
    Host=true, Escape=true, Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    AwaitS=true, AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
    EmitInt=true,
    Pause=true,
}

local NO_async = {
    Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    AwaitS=true, AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
    EmitInt=true,
    Pause=true,
    Escape=true,
    Finalize=true,
}

local NO_thread = {
    Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    AwaitS=true, AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
    EmitInt=true, EmitExt=true, EmitT=true,
    Pause=true,
    Escape=true,
    Finalize=true,
}

local NO_constr = {
    --Finalize=true, Finally=true,
    Escape=true, Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    AwaitS=true, AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
    EmitInt=true,
    Pause=true,
}

-- Loop, SetBlock may need clear
-- if break/return are in parallel w/ something
--                  or inside block that needs_clr
function NEEDS_CLR (top)
    for n in AST.iter() do
        if n.tag == top.tag then
            break
        elseif n.tag == 'ParEver' or
               n.tag == 'ParAnd'  or
               n.tag == 'ParOr'   or
               n.tag == 'Block' and n.needs_clr then
            PROPS.has_clear = true
            top.needs_clr = true
            break
        end
    end
end

function HAS_FINS ()
    for n in AST.iter() do
        if n.tag == 'Block'    or
           n.tag == 'ParOr'    or
           n.tag == 'Loop'     or
           n.tag == 'SetBlock' then
            n.needs_clr_fin = true
        end
    end
end

F = {
    Node_pre = function (me)
        if NO_atomic[me.tag] then
            ASR(not AST.par(me,'Atomic'), me,
                'not permitted inside `atomic´')
        end
        if NO_fun[me.tag] then
            ASR(not AST.par(me,'Dcl_fun'), me,
                'not permitted inside `function´')
        end
        if NO_fin[me.tag] then
            ASR(not AST.par(me,'Finally'), me,
                'not permitted inside `finalize´')
        end
        if NO_async[me.tag] then
            ASR(not AST.par(me,'Async'), me,
                    'not permitted inside `async´')
        end
        if NO_thread[me.tag] then
            ASR(not AST.par(me,'Thread'), me,
                    'not permitted inside `thread´')
        end
        if NO_constr[me.tag] then
            ASR(not AST.par(me,'Dcl_constr'), me,
                    'not permitted inside a constructor')
        end
    end,

    Block_pre = function (me)       -- _pre: break/return depends on it
        if me.fins then
            me.needs_clr = true
            me.needs_clr_fin = true
            PROPS.has_clear = true
        end

        for _, var in ipairs(me.vars) do
            if var.cls then
                me.needs_clr = true
                PROPS.has_clear = true
            end
            if var.pre=='pool' then
                PROPS.has_news = true
                if var.tp.arr==true then
                    PROPS.has_news_malloc = true       -- pool T[]  ts
                else
                    PROPS.has_news_pool = true         -- pool T[N] ts
                end
            end
        end

        if me.needs_clr then
            HAS_FINS()  -- TODO (-ROM): could avoid ors w/o fins
        end
    end,
    Free = function (me)
        PROPS.has_news = true
        PROPS.has_clear = true
    end,
    Spawn = function (me)
        local _,pool,_ = unpack(me)

        --PROPS.has_news = true    (pool does this)
        if pool and pool.lst.var.tp.arr==true then
            PROPS.has_news_malloc = true       -- pool T[]  ts
        else
            PROPS.has_news_pool = true         -- pool T[N] ts
        end

        --PROPS.has_clear = true   (var.cls does this)
        --me.blk.needs_clr = true   (var.cls does this)
        ASR(not AST.iter'BlockI'(), me,
                'not permitted inside an interface')
    end,

    ParOr = function (me)
        me.needs_clr = true
        PROPS.has_clear = true

        -- detects if "isWatching" an org
        if me.isWatching then
            local tp = me.isWatching.tp
            if (tp and tp.ptr==1 and ENV.clss[tp.id]) then
                PROPS.has_orgs_watching = true
            end
        end
    end,

    Loop_pre = function (me)
        me.brks = {}
    end,
    Break = function (me)
        local loop = AST.iter'Loop'()
        ASR(loop, me, 'break without loop')
        loop.brks[me] = true
        loop.has_break = true

        NEEDS_CLR(loop)

        local fin = AST.iter'Finally'()
        ASR(not fin or fin.__depth<loop.__depth, me,
                'not permitted inside `finalize´')
        -- TODO: same for return

        local async = AST.iter(AST.pred_async)()
        if async then
            local loop = AST.iter'Loop'()
            ASR(loop.__depth>async.__depth, me, '`break´ without loop')
        end
    end,

    SetBlock_pre = function (me)
        me.rets = {}
        ASR(not AST.iter'BlockI'(), me,
                'not permitted inside an interface')
    end,
    Escape = function (me)
        local blk = AST.iter'SetBlock'()
        blk.rets[me] = true
        blk.has_escape = true

        NEEDS_CLR(blk)
    end,

    Return = function (me)
        ASR(AST.iter'Dcl_fun'(), me,
                'not permitted outside a function')
    end,

    Outer = function (me)
        ASR(AST.par(me,'Dcl_constr'), me,
            '`outer´ can only be unsed inside constructors')
    end,

    Dcl_cls = function (me)
        if me.id ~= 'Main' then
            PROPS.has_orgs = true
            PROPS.has_ints = true      -- all have "emit _ok"
        end
        if me.is_ifc then
            PROPS.has_ifcs = true
        end
    end,

    Dcl_ext = function (me)
        PROPS.has_exts = true
    end,

    Dcl_var = function (me)
        if me.var.cls then
            -- <class T with var U u; end>
            ASR(not AST.iter'BlockI'(), me,
                    'not permitted inside an interface')
        end
    end,

    Async = function (me)
        PROPS.has_asyncs = true
    end,
    Thread = function (me)
        PROPS.has_threads = true
    end,
    Sync = function (me)
        ASR(AST.iter'Thread'(), me,'not permitted outside `thread´')
    end,

    Pause = function (me)
        PROPS.has_pses = true
    end,

    _loop1 = function (me)
        for loop in AST.iter'Loop' do
            if loop.isEvery then
                ASR(me.isEvery, me,
                    '`every´ cannot contain `await´')
            end
        end
    end,

    AwaitT = function (me)
        PROPS.has_wclocks = true
        F._loop1(me)
    end,
    AwaitInt = function (me)
        PROPS.has_ints = true
        F._loop1(me)
    end,
    AwaitExt = function (me)
        F._loop1(me)
    end,
    AwaitN = function (me)
        F._loop1(me)
    end,
    AwaitS = function (me)
        for _, awt in ipairs(me) do
            if awt.__ast_isexp then
                F.AwaitInt(me)
            elseif awt.tag=='Ext' then
                F.AwaitExt(me)
            else
                F.AwaitT(me)
            end
        end
    end,

    EmitInt = function (me)
        PROPS.has_ints = true
    end,

    EmitExt = function (me)
        local op, ext = unpack(me)
        if ext.evt.pre == 'input' then
            ASR( AST.par(me,'Async') or op=='call',
                me, 'invalid `'..op..'´')
                    -- no <emit I> on sync
        end

        if AST.par(me,'Dcl_fun') then
            ASR(op=='call', me, 'invalid `emit´')
        end
    end,
    EmitT = function (me)
        ASR(AST.par(me,'Async'),
            me,'not permitted outside `async´')
    end,

    SetExp = function (me)
        local _, fr, to = unpack(me)
        local thr = AST.par(me, 'Thread')
        if thr and (not to) then
            ASR( thr.__depth <= AST.iter'SetBlock'().__depth+1, me,
                    'invalid access from `thread´')
        end

        if AST.iter'BlockI'() then
            CLS().has_pre = true   -- code for pre (before constr)

            -- new, spawn, async, await
            ASR(fr.tag ~= 'Ref',
                me, 'not permitted inside an interface')
        end

        if to.tag=='Var' and to.var.id=='_ret' then
            PROPS.has_ret = true
        end
    end,

--[[
    Var = function (me)
        local thr = AST.par(me, 'Thread')
        if thr then
            ASR(AST.iter'RefVarList'() or        -- param list
                me.ret or                         -- var assigned on return
                thr.__depth < me.var.blk.__depth, -- var is declared inside
                    me, 'invalid access from `thread´')
        end
    end,
]]

    Op1_cast = function (me)
        local tp, _ = unpack(me)
        if tp.ptr>0 and ENV.clss[tp.id] then
            PROPS.has_ifcs = true      -- cast must check org->cls_id
        end
    end,

    Lua = function (me)
        PROPS.has_lua = true
    end,
}

AST.visit(F)

end

    
do
-- TODO: rename to flow
ANA = {
    ana = {
        isForever  = nil,
        reachs   = 0,      -- unexpected reaches
        unreachs = 0,      -- unexpected unreaches
    },
}

-- avoids counting twice (due to loops)
-- TODO: remove
local __inc = {}
function INC (me, c)
    if __inc[me] then
        return true
    else
        ANA.ana[c] = ANA.ana[c] + 1
        __inc[me] = true
        return false
    end
end

-- [false]  => never terminates
-- [true]   => terminates w/o event

function OR (me, sub, short)

    -- TODO: short
    -- short: for ParOr/Loop/SetBlock if any sub.pos is equal to me.pre,
    -- then we have a "short circuit"

    for k in pairs(sub.ana.pos) do
        if k ~= false then
            me.ana.pos[false] = nil      -- remove NEVER
            me.ana.pos[k] = true
        end
    end
end

function COPY (n)
    local ret = {}
    for k in pairs(n) do
        ret[k] = true
    end
    return ret
end

function ANA.CMP (n1, n2)
    return ANA.HAS(n1, n2) and ANA.HAS(n2, n1)
end

function ANA.HAS (n1, n2)
    for k2 in pairs(n2) do
        if not n1[k2] then
            return false
        end
    end
    return true
end

local LST = {
    Do=true, Stmts=true, Block=true, Root=true, Dcl_cls=true,
    Pause=true,
}

F = {
    Root_pos = function (me)
        ANA.ana.isForever = not (not me.ana.pos[false])
    end,

    Node_pre = function (me)
        if me.ana then
            return
        end

        local top = AST.iter()()
        me.ana = {
            pre  = (top and COPY(top.ana.pre)) or { [true]=true },
        }
    end,
    Node = function (me)
        if me.ana.pos then
            return
        end
        if LST[me.tag] and me[#me] then
            me.ana.pos = COPY(me[#me].ana.pos)  -- copy lst child pos
        else
            me.ana.pos = COPY(me.ana.pre)       -- or copy own pre
        end
    end,

    Dcl_cls_pre = function (me)
        if me ~= MAIN then
            me.ana.pre = { [me.id]=true }
        end
    end,
    Orgs = function (me)
        me.ana.pos = { [false]=true }       -- orgs run forever
    end,

    Stmts_bef = function (me, sub, i)
        if i == 1 then
            -- first sub copies parent
            sub.ana = {
                pre = COPY(me.ana.pre)
            }
        else
            -- broken sequences
            if sub.tag~='Host' and me[i-1].ana.pos[false] and (not me[i-1].ana.pre[false]) then
                --ANA.ana.unreachs = ANA.ana.unreachs + 1
                me.__unreach = true
                WRN( INC(me, 'unreachs'),
                     sub, 'statement is not reachable')
            end
            -- other subs follow previous
            sub.ana = {
                pre = COPY(me[i-1].ana.pos)
            }
        end
    end,

    ParOr_pos = function (me)
        me.ana.pos = { [false]=true }
        for _, sub in ipairs(me) do
            OR(me, sub, true)
        end
        if me.ana.pos[false] then
            --ANA.ana.unreachs = ANA.ana.unreachs + 1
            WRN( INC(me, 'unreachs'),
                 me, 'at least one trail should terminate')
        end
    end,

    ParAnd_pos = function (me)
        -- if any of the sides run forever, then me does too
        -- otherwise, behave like ParOr
        for _, sub in ipairs(me) do
            if sub.ana.pos[false] then
                me.ana.pos = { [false]=true }
                --ANA.ana.unreachs = ANA.ana.unreachs + 1
                WRN( INC(me, 'unreachs'),
                     sub, 'trail should terminate')
                return
            end
        end

        -- like ParOr, but remove [true]
        local onlyTrue = true
        me.ana.pos = { [false]=true }
        for _, sub in ipairs(me) do
            OR(me, sub)
            if not sub.ana.pos[true] then
                onlyTrue = false
            end
        end
        if not onlyTrue then
            me.ana.pos[true] = nil
        end
    end,

    ParEver_pos = function (me)
        me.ana.pos = { [false]=true }
        local ok = false
        for _, sub in ipairs(me) do
            if sub.ana.pos[false] then
                ok = true
                break
            end
        end
        if not ok then
            --ANA.ana.reachs = ANA.ana.reachs + 1
            WRN( INC(me, 'reachs'),
                 me, 'all trails terminate')
        end
    end,

    If = function (me)
        me.ana.pos = { [false]=true }
        for _, sub in ipairs{me[2],me[3]} do
            OR(me, sub)
        end
    end,

    SetBlock_pre = function (me)
        me.ana.pos = { [false]=true }   -- `return/break´ may change this
    end,
    Escape = function (me)
        local top = AST.iter((me.tag=='Escape' and 'SetBlock') or 'Loop')()
        me.ana.pos = COPY(me.ana.pre)
        OR(top, me, true)
        me.ana.pos = { [false]='esc' }   -- diff from [false]=true
    end,
    SetBlock = function (me)
        local blk = me[1]
        if not blk.ana.pos[false] then
            --ANA.ana.reachs = ANA.ana.reachs + 1
            WRN( INC(me, 'reachs'),
                 blk, 'missing `escape´ statement for the block')
        end
    end,

    Loop_pre = 'SetBlock_pre',
    Break    = 'Escape',

    Loop = function (me)
        if me.bound then
            me.ana.pos = COPY(me[1].ana.pos)
            return      -- guaranteed to terminate
        end

        if me[1].ana.pos[false] then
            --ANA.ana.unreachs = ANA.ana.unreachs + 1
            WRN( INC(me, 'unreachs'),
                 me, '`loop´ iteration is not reachable')
        end
    end,

    Thread = 'Async',
    Async = function (me)
        if me.ana.pre[false] then
            me.ana.pos = COPY(me.ana.pre)
        else
            me.ana.pos = { ['ASYNC_'..me.n]=true }  -- assume it terminates
        end
    end,

--[[
-- TODO: remove
-- not needed after SetAwait => AwaitX;SetExp
    SetAwait = function (me)
        local _, awt, set = unpack(me)
        set.ana.pre = COPY(awt.ana.pos)
        set.ana.pos = COPY(awt.ana.pos)
        me.ana.pre = COPY(awt.ana.pre)
        me.ana.pos = COPY(set.ana.pos)
    end,
]]

    AwaitS = function (me)
        DBG'TODO - ana.lua - AwaitS'
    end,

    AwaitExt_aft = function (me, sub, i)
        if i > 1 then
            return
        end

        -- between Await and Until

        local awt, cnd = unpack(me)

        local t
        if me.ana.pre[false] then
            t = { [false]=true }
        else
            -- enclose with a table to differentiate each instance
            if me.tag == 'AwaitExt' then
                t = { [{awt.evt}]=true }
            elseif me.tag == 'AwaitInt' then
                -- use "var" as identifier (why "evt" doesn't work?)
                t = { [{awt.var}]=true }
            else    -- 'AwaitT'
                t = { [{awt.evt or 'WCLOCK'}]=true }
            end
        end
        me.ana.pos = COPY(t)
        if cnd then
            cnd.ana = {
                pre = COPY(t),
            }
        end
    end,
    AwaitInt_aft = 'AwaitExt_aft',
    AwaitT_aft   = 'AwaitExt_aft',

    AwaitN = function (me)
        me.ana.pos = { [false]=true }
    end,
}

local _union = function (a, b, keep)
    if not keep then
        local old = a
        a = {}
        for k in pairs(old) do
            a[k] = true
        end
    end
    for k in pairs(b) do
        a[k] = true
    end
    return a
end

-- TODO: remove
-- if nested node is reachable from "pre", join with loop POS
function ANA.union (root, pre, POS)
    local t = {
        Node = function (me)
            if me.ana.pre[pre] then         -- if matches loop begin
                _union(me.ana.pre, POS, true)
            end
        end,
    }
    AST.visit(t, root)
end

AST.visit(F)

end

    
do
ANA.ana.acc  = 0      -- nd accesses
ANA.ana.abrt  = 0      -- nd flows
ANA.ana.excpt = 0      -- nd excpt

-- any variable access calls this function
-- to be inserted on parent Parallel sub[i] or Class
function iter (n)
    local par = n.__par and n.__par.tag
    return par=='ParOr' or par=='ParAnd' or par=='ParEver'
        or n.tag=='Dcl_cls'
end

function ERR (me, msg)
    return msg..' ('..me.ln[1]..':'..me.ln[2]..')'
end

function INS (acc, exists)
--[[
    if AST.iter'Async'() then
        acc.md = 'no'                       -- protected acc
    end
    if AST.iter'Sync'() then
        acc.md = 'no'                       -- protected acc
    end
]]
    if not exists then
        acc.cls = CLS()                     -- cls that acc resides
    end
    local n = AST.iter(iter)()             -- child Block from PAR
    if n then
        n.ana.accs[#n.ana.accs+1] = acc
    end
    return acc
end

function CHG (acc, md)
    if AST.iter'Thread'() then
        return
    end
    acc.md = md
end

F = {
-- accs need to be I-indexed (see CHK_ACC)
    Dcl_cls_pre = function (me)
        me.ana.accs = {}
    end,
    ParOr_pre = function (me)
        for _, sub in ipairs(me) do
            sub.ana.accs = {}
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',

    ParOr_pos = function (me)
        -- insert all my subs on my parent Par
        if AST.iter(AST.pred_par) then -- requires ParX_pos
            for _, sub in ipairs(me) do
                for _,acc in ipairs(sub.ana.accs) do
    -- check par/enter only against immediate pars
                    if acc.md ~= 'par' then
    -- check ParOr esc only against immediate pars
                    if not (acc.md=='esc' and acc.id.tag=='ParOr') then
    -- check Loop esc only against nested pars
                    --if not (acc.md=='esc' and acc.id.tag=='Loop'
                            --and acc.id.depth>me.depth) then
                        INS(acc, true)
                    --end
                    end
                    end
                end
            end
        end
    end,
    ParAnd_pos  = 'ParOr_pos',
    ParEver_pos = 'ParAnd_pos',

    Spawn = function (me)
        local sz = #me.cls.ana.accs -- avoid ipairs due to "spawn myself"
        for i=1, sz do
            INS(me.cls.ana.accs[i], true)
        end
    end,

-- TODO: usar o Dcl_var p/ isso
--[=[
    Orgs = function (me)
        -- insert cls accs on my parent ParOr
        for _, var in ipairs(me.vars) do
            for _,acc in ipairs(var.cls.ana.accs) do
                INS(acc, true)
            end
        end
    end,
]=]

    EmitExt = function (me)
        local _, e1, e2 = unpack(me)
        if e1.evt.pre == 'input' then
            return
        end
        INS {
            path = me.ana.pre,
            id  = e1.evt.id,    -- like functions (not table events)
            md  = 'cl',
            tp  = TP.fromstr'@',
            any = false,
            err = ERR(me, 'event `'..e1.evt.id..'´')
        }
--[[
        if e2 then
            local tp = TP.deptr(e1.evt.ins, true)
            if e2.accs and tp then
                e2.accs[1][4] = (e2.accs[1][2] ~= 'no')   -- &x does not become 
                    "any"
                e2.accs[1][2] = (me.c and me.c.mod=='@pure' and 'rd') or 'wr'
                e2.accs[1][3] = tp
            end
        end
]]
    end,

    Op2_call = function (me)
        local _, f, exps = unpack(me)
        CHG(f.lst.acc, 'cl')
        me.acc = f.lst.acc
        for _, exp in ipairs(exps) do
            if exp.tp.ptr>0 then
                local v = exp.lst
                if v and v.acc then   -- ignore constants
--DBG(exp.tag, exp.lst)
                    v.acc.any = exp.lval    -- f(&x) // a[N] f(a) // not "any"
                    CHG(v.acc, (me.c and me.c.mod=='@pure' and 'rd') or 'wr')
                    v.acc.tp = TP.copy(exp.tp)
                    v.acc.tp.ptr = v.acc.tp.ptr - 1     -- f may deref exp
                end
            end
        end

        -- TODO: never tested
--[[
        me.acc = INS {
            path = me.ana.pre,
            id  = f,
            md  = 'cl',
            tp  = TP.fromstr'@',
            any = true,
            err = 'call to `'..f.id..'´ (line '..me.ln[2]..')',
        }
]]
    end,

    EmitInt = function (me)
        local _, e1, e2 = unpack(me)
        CHG(e1.lst.acc, 'tr')
        e1.lst.acc.node = me        -- emtChk
        me.emtChk = false
    end,

    SetExp = function (me)
        local _,_,to = unpack(me)
        CHG(to.lst.acc, 'wr')
    end,
    AwaitInt = function (me)
        CHG(me[1].lst.acc, 'aw')
        F.AwaitExt(me)  -- flow
    end,

    ['Op2_idx'] = function (me)
        if not (me.lst.var and me.lst.var.tp.arr) then
            me.lst.acc.any = true
        end
        me.lst.acc.tp = me.tp  -- deptr'd
    end,
    ['Op1_*'] = function (me)
        if not me.lst.acc then
            assert(me.lst.const)
            return  -- constants
        end

        me.lst.acc.any = true
        me.lst.acc.tp = me.tp  -- deptr'd

        -- TODO: HACK_3
        -- ignore cast to tceu_org
        if me[2].tag=='Op1_cast' and me[2][1][1]=='_tceu_org' then
            me.lst.acc.tp = me[2][2].tp  -- change to uncast type
        end
    end,
    ['Op1_&'] = function (me)
        CHG(me.lst.acc, 'no')
    end,

    ['Op2_.'] = function (me)
        if me.org then
            me.lst.acc.org = me.org.lst
        end
    end,

    Global = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = 'Global',
            md  = 'rd',
            tp  = me.tp,
            any = true,
            err = ERR(me, 'variable `global´'),
        }
    end,

    Outer = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = me,
            md  = 'rd',
            tp  = me.tp,
            any = true,
            err = ERR(me, 'variable `outer´'),
        }
    end,

    This = function (me)
        if AST.iter'Dcl_constr'() then
            return  -- org being created cannot be in parallel
        end
        me.acc = INS {
            path = me.ana.pre,
            id  = me,
            md  = 'rd',
            tp  = me.tp,
            any = true,
            err = ERR(me, 'variable `this´'),
        }
    end,

    Var = function (me)
        local tag = me.__par.tag=='RefVarList' and me.__par.__par.tag
        if tag=='Async' or tag=='Thread' then
            return  -- <async (v)> is not an access
        end
        me.acc = INS {
            path = me.ana.pre,
            id  = me.var,
            md  = 'rd',
            tp  = me.var.tp,
            any = false,
            err = ERR(me, 'variable/event `'..me.var.id..'´'),
        }
        if string.sub(me.var.id,1,4) == '_tup' then
            -- TODO: ignore tuple assignments for now "(a,b)=await A"
            me.acc.md = 'no'
        end
    end,

    Nat = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = me[1],
            md  = 'rd',
            tp  = TP.fromstr'@',
            any = false,
            err = ERR(me, 'symbol `'..me[1]..'´'),
        }
    end,

    -- FLOW --

    Break = function (me, TAG, PRE)
        TAG = TAG or 'Loop'
        PRE = PRE or me.ana.pre
        local top = AST.iter(TAG)()
        INS {
            path = PRE,
            id  = top,
            md  = 'esc',
            err = ERR(me, 'escape'),
        }
    end,
    Escape = function (me)
        F.Break(me, 'SetBlock')
    end,
    Node = function (me)
        local top = me.__par and me.__par.tag
        if top == 'ParOr' then
            if not me.ana.pos[false] then
                F.Break(me, 'ParOr', me.ana.pos)
            end
        end

        if top=='ParOr' or top=='ParAnd' or top=='ParEver' then
            if not me.ana.pre[false] then
                me.parChk = false           -- only chk if ND flw
                INS {
                    path = me.ana.pre,
                    id   = me,--.__par,
                    md   = 'par',
                    err  = ERR(me,'par enter'),
                }
            end
        end
    end,

    AwaitExt = function (me)
        INS {
            path = me.ana.pos,
            id  = me,--AST.iter(TAG)(),
            md  = 'awk',
            err = ERR(me, 'awake'),
        }
    end,
    AwaitT = 'AwaitExt',
    --AwaitInt = <see above>,
}

AST.visit(F)

------------------------------------------------------------------------------

local ND = {
    acc = { par={},awk={},esc={},
        cl  = { cl=2, tr=2,     wr=2,     rd=2,     aw=2  },
        tr  = { cl=2, tr=1,     wr=false, rd=false, aw=1  },
        wr  = { cl=2, tr=false, wr=2,     rd=2,     aw=false },
        rd  = { cl=2, tr=false, wr=2,     rd=false, aw=false },
        aw  = { cl=2, tr=1,     wr=false, rd=false, aw=false },
        no  = {},   -- never ND ('ref')
    },

    flw = { cl={},tr={},wr={},rd={},aw={},no={},
        par = { par=false, awk=false, esc=1 },
        awk = { par=false, awk=false, esc=1 },
        esc = { par=1,     awk=1,     esc=1 },
    },
}

local ALL = nil     -- holds all emits starting from top-most PAR

--[[
    ana = {
        acc = 1,  -- false positive
    },
    ana = {
        isForever = true,
        n_unreachs = 1,
    },
]]

-- {path [A]=true, [a]=true } => {ret [A]=true, [aX]=true,[aY]=true }
-- {T [a]={[X]=true,[Y]=true} } (emits2pres)
local function int2exts (path, NO_emts, ret)
    ret = ret or {}

    local more = false                  -- converged
    for int in pairs(path) do
        if type(int)=='table' and int[1].pre=='event' then
            for emt_acc in pairs(ALL) do
                if int[1]==emt_acc.id and (not NO_emts[emt_acc]) then
                    for ext in pairs(emt_acc.path) do
                        if not ret[ext] then
                            more = true         -- not converged yet
                            ret[ext] = true     -- insert new ext
                        end
                    end
                end
            end
        else
            ret[int] = true             -- already an ext
        end
    end
    if more then
        return int2exts(ret, NO_emts, ret, cache) -- not converged
    else
        if next(ret)==nil then
            ret[false] = true   -- include "never" if empty
        end
        return ret
    end
end

function par_rem (path, NO_par)
    for id in pairs(path) do
        if NO_par[id] then
            path[id] = nil
        end
    end
    if next(path)==nil then
        path[true] = true       -- include "tight" became empty
    end
    return path
end

function par_level1 (path1, path2)
    for id1 in pairs(path1) do
        for id2 in pairs(path2) do
            if (id1 == false) then
            elseif (id1 == id2) or
                     (type(id1) == 'table') and (type(id2) == 'table') and
                     (id1[1] == id2[1])
            then
                return true
            end
        end
    end
end

--local CACHE = setmetatable({},
    --{__index=function(t,k) t[k]={} return t[k] end})

function CHK_ACC (accs1, accs2, NO_par, NO_emts)
    local cls = CLS()

    -- "acc": i/j are concurrent, and have incomp. acc
    -- accs need to be I-indexed
    for _, acc1 in ipairs(accs1) do
        local path1 = int2exts(acc1.path, NO_emts)
              path1 = par_rem(path1, NO_par)
        for _, acc2 in ipairs(accs2) do
            local path2 = int2exts(acc2.path, NO_emts)
                  path2 = par_rem(path2, NO_par)

            local isLvl1 = par_level1(path1,path2)

-- FLOW (only in safety level-1)
            if isLvl1 and ND.flw[acc1.md][acc2.md] then
                if AST.isParent(acc1.id, acc2.id)
                or AST.isParent(acc2.id, acc1.id)
                then
                    if OPTS.safety > 0 then
                        DBG('WRN : abortion : '..
                                acc1.err..' vs '..acc2.err)
                    end
                    ANA.ana.abrt = ANA.ana.abrt + 1
                    if acc1.md == 'par' then
                        acc1.id.parChk = true
                    end
                    if acc2.md == 'par' then
                        acc2.id.parChk = true
                    end
                end
            end

-- ACC (in both safety levels, ignore aw/tr for level-2)
--DBG(acc1.md,acc2.md, OPTS.safety, ND.acc[acc1.md],ND.acc[acc2.md])
            if par_level1(path1,path2) and ND.acc[acc1.md][acc2.md] or
               OPTS.safety==2 and ND.acc[acc1.md][acc2.md]==2 then
                -- this.x vs this.x (both accs bounded to cls)
                local cls_ = (acc1.cls == cls) or
                             (acc2.cls == cls)

                -- a.x vs this.x
                local _nil = {}
                local o1 = (acc1.org or acc2.org)
                o1 = o1 and o1.acc or _nil
                local o2 = (acc2.org or acc1.org)
                o2 = o2 and o2.acc or _nil

                -- orgs are compatible?
                local org_ = (o1 == o2)
                          or o1.any
                          or o2.any

                -- orgs are compatible?
                local org_ = o1.id == o2.id
                          or o1.any
                          or o2.any

                -- ids are compatible?
                local id_ = acc1.id == acc2.id
                         or acc1.md=='cl' and acc2.md=='cl'
                         or acc1.any and TP.contains(acc1.tp,acc2.tp)
                         or acc2.any and TP.contains(acc2.tp,acc1.tp)

                -- C's are det?
                local c1 = ENV.c[acc1.id]
                c1 = c1 and (c1.mod=='@pure' or c1.mod=='const')
                local c2 = ENV.c[acc2.id]
                c2 = c2 and (c2.mod=='@pure' or c2.mod=='const')
                local c_ = c1 or c2
                        or (ENV.dets[acc1.id] and ENV.dets[acc1.id][acc2.id])

    --DBG(id_, c_,c1,c2, acc1.any,acc2.any)
--[[
DBG'==============='
DBG(acc1.cls.id, acc1, acc1.id, acc1.md, TP.toc(acc1.tp), acc1.any, acc1.err)
for k in pairs(path1) do
DBG('path1', acc1.path, type(k)=='table' and k[1].id or k)
end
DBG(acc2.cls.id, acc2, acc2.id, acc2.md, TP.toc(acc2.tp), acc2.any, acc2.err)
for k in pairs(path2) do
DBG('path2', acc2.path, type(k)=='table' and k[1].id or k)
end
DBG'==============='
]]
                if cls_ and org_ and id_ and (not c_)
                then
                    if OPTS.safety > 0 then
                        DBG('WRN : nondeterminism : '..acc1.err
                                ..' vs '..acc2.err)
                    end
                    ANA.ana.acc = ANA.ana.acc + 1
                end
            end
        end
    end
end

function _chk (n, id)
    for k in pairs(n) do
        if type(k)=='table' and k[1]==id then
            return true
        end
    end
    return false
end

-- TODO: join with CHK_ACC
-- emits vs rets/ors/breaks (the problem is that emits are considered in par)
function CHK_EXCPT (s1, s2, isOR)
    for _, ana in ipairs(s1.ana.accs) do
        if ana.md == 'tr' then
            if _chk(s2.ana.pos,ana.id) and isOR or -- terminates w/ same event
               s2.ana.pos[false] --or       -- ~terminates (return/break)
               --s2.ana.pos[true]                 -- terminates tight
            then
                if OPTS.warn_exception then
                    DBG('WRN : exception : line '..s2.ln[2]..' vs '..ana.err)
                end
                ANA.ana.excpt = ANA.ana.excpt + 1
                ana.node.emtChk = true
            end
        end
    end
end

G = {
-- take all emits from top-level PAR
    ParOr_pre = function (me)
        if ALL then
            return
        end
        ALL = {}
        for _, sub in ipairs(me) do
            for _,acc in ipairs(sub.ana.accs) do
                if acc.md == 'tr' then
                    ALL[acc] = true
                end
            end
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',

-- look for nondeterminism
    ParOr = function (me)
        for i=1, #me do
            for j=i+1, #me do

                -- holds invalid emits
                local NO_emts = {}
                for _,acc in ipairs(me[i].ana.accs) do
                    if acc.md == 'tr' then
                        NO_emts[acc] = true -- same trail (happens bef or aft)
                    end
                end
                for _,acc in ipairs(me[j].ana.accs) do
                    if acc.md == 'tr' then
                        NO_emts[acc] = true -- same trail (happens bef or aft)
                    end
                end
                for acc in pairs(ALL) do
                    if ANA.CMP(acc.path, me.ana.pre) then
                        NO_emts[acc] = true -- instantaneous emit
                    end
                end

                CHK_ACC(me[i].ana.accs, me[j].ana.accs,
                        me.ana.pre,
                        --ANA.union(me.ana.pre,me.ana.pos),
                        NO_emts)
                CHK_EXCPT(me[i], me[j], me.tag=='ParOr')
                CHK_EXCPT(me[j], me[i], me.tag=='ParOr')
            end
        end
    end,
    ParAnd  = 'ParOr',
    ParEver = 'ParOr',

-- TODO: workaround
    -- Loop can only be repeated after nested PARs evaluate CHK_*
    Loop = function (me)
        -- pre = pre U pos
        if not me[1].ana.pos[false] then
            ANA.union(me[1], next(me.ana.pre), me[1].ana.pos)
        end
    end,
}

AST.visit(G)

end

    
do
function MAX_all (me, t)
    t = t or me
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            me.trails_n = MAX(me.trails_n, sub.trails_n)
        end
    end
end

F = {
    Node_pre = function (me)
        me.trails_n = 1
    end,
    Node_pos = function (me)
        if not F[me.tag] then
            MAX_all(me)
        end
    end,

    If = function (me)
        local c, t, f = unpack(me)
        MAX_all(me, {t,f})
    end,

    Dcl_cls = function (me)
        MAX_all(me)

        -- pointer to next org or parent/trail
        -- [ IN__ORG_UP/DOWN ]
        if me ~= MAIN then
            me.trails_n = me.trails_n + 1
        end

        ASR(me.trails_n < 256, me, 'too many trails')
    end,

    Block = function (me)
        MAX_all(me)

        if me.fins then
            -- implicit await in parallel
            me.trails_n = me.trails_n + 1
        end

        -- [ CLR | ORG_STATS_I | ORG_POOL_I | ... | STMTS | FIN ]
        -- clear trail
        -- pointer to contiguous static orgs
        -- pointers to each of the pools
        -- statements
        -- finalization
        -- STATS and POOL must interleave to respect execution order:
        -- var  T a;
        -- pool T ts;
        -- var  T b;
        -- First execute a, then all ts, then b.

        me.has_orgs = false
        for i=1, #me.vars do
            local var = me.vars[i]
            if var.cls then
                me.has_orgs = true
                me.trails_n = me.trails_n + 1   -- ORG_POOL_I/ORG_STATS_I
                var.trl_orgs_first = true       -- avoids repetition in initialization of STATS

                -- for STATS, unify all skipping all non-pool vars
                if var.pre ~= 'pool' then
                    for j=i+1, #me.vars do
                        local var2 = me.vars[j]
                        if var2.pre == 'pool' then
                            break
                        else
                            i = i + 1   -- skip on outer loop
                        end
                    end
                end
            end
        end
        if me.has_orgs then
            me.trails_n = me.trails_n + 1           -- CLR
        end
    end,

    ParAnd  = 'ParOr',
    ParEver = 'ParOr',
    ParOr = function (me)
        me.trails_n = 0
        for _, sub in ipairs(me) do
            me.trails_n = me.trails_n + sub.trails_n
        end
    end,
}

AST.visit(F)

-------------------------------------------------------------------------------

function pred (n)
    return n.trails
end

G = {
    Root_pre = 'Dcl_cls_pre',
    Dcl_cls_pre = function (me)
        me.trails  = { 0, me.trails_n -1 }     -- [0, N]
    end,

    Node = function (me)
        if me.trails then
            return
        end
        me.trails  = AST.iter(pred)().trails
    end,

    Block_pre = function (me)
        local stmts = unpack(me)

        -- [ 1, 1, S, 1 ] (clr, org0, stmts, fin)

        me.trails = me.trails or AST.iter(pred)().trails

        local t0 = me.trails[1]

        -- [ CLR | ORG_STATS | ORG_POOL_I | STMTS | FIN ]
        -- clear trail
        -- pointer to all static orgs
        -- pointers to each of the pools
        -- statements
        -- finalization

        if me.has_orgs then
            t0 = t0 + 1                             -- CLR
        end
        for i=1, #me.vars do
            local var = me.vars[i]
            if var.cls then
                var.trl_orgs = { t0, t0 }   -- ORG_POOL_I/ORG_STATS_I
                t0 = t0 + 1

                -- for STATS, unify all skipping all non-pool vars
                if var.pre ~= 'pool' then
                    for j=i+1, #me.vars do
                        local var2 = me.vars[j]
                        if var2.pre == 'pool' then
                            break
                        else
                            if var2.cls then
                                var2.trl_orgs = { t0-1, t0-1 }   -- ORG_STATS_I
                            end
                            i = i + 1   -- skip on outer loop
                        end
                    end
                end
            end
        end

        -- BLOCK
        stmts.trails = { t0, t0+stmts.trails_n-1 }
            t0 = t0 + stmts.trails_n    -- stmts

        -- FINS (must be the last to proper nest fins)
        if me.fins then
            me.trl_fins  = { t0, t0 }
                t0 = t0 + 1             -- fin
        end
    end,

    _Par_pre = function (me)
        me.trails = AST.iter(pred)().trails

        for i, sub in ipairs(me) do
            sub.trails = {}
            if i == 1 then
                sub.trails[1] = me.trails[1]
            else
                local pre = me[i-1]
                sub.trails[1] = pre.trails[1] + pre.trails_n
            end
            sub.trails[2] = sub.trails[1] + sub.trails_n  - 1
        end
    end,

    ParOr_pre   = '_Par_pre',
    ParAnd_pre  = '_Par_pre',
    ParEver_pre = '_Par_pre',
}

AST.visit(G)

end

    
do
LBLS = {
    list = {},      -- { [lbl]={}, [i]=lbl }
    code_enum = '',
    code_fins = '',
}

function new (lbl)
    if lbl[2] then
        lbl.id = lbl[1]
    else
        lbl.id = CLS().id..'_'..lbl[1]..'_'..#LBLS.list
    end
    lbl.id = string.gsub(lbl.id, '%*','')
    lbl.id = string.gsub(lbl.id, '%.','')
    lbl.id = string.gsub(lbl.id, '%$','')
    lbl.id = string.gsub(lbl.id, '%%','')
    LBLS.list[lbl] = true
    lbl.n = #LBLS.list                   -- starts from 0
    LBLS.list[#LBLS.list+1] = lbl

    for n in AST.iter() do
        if n.lbls_all then
            n.lbls_all[lbl] = true
        end
    end

    return lbl
end

F = {
    Node_pre = function (me)
        me.lbls = { #LBLS.list }
    end,
    Node = function (me)
        me.lbls[2] = #LBLS.list-1
    end,

    Root_pre = function (me)
        --new{'CEU_INACTIVE', true}
    end,
    Root = function (me)
        -- 0, 1,-1, tot,-tot
        -- <0 = off (for internal events)
        TP.types.tceu_nlbl.len  = TP.n2bytes(1+2 + #LBLS.list*2)

        -- enum of labels
        for i, lbl in ipairs(LBLS.list) do
            LBLS.code_enum = LBLS.code_enum..'    '
                                ..lbl.id..' = '..lbl.n..',\n'
        end

        -- labels which are finalizers
        local t = {}
        for _, lbl in ipairs(LBLS.list) do
            t[#t+1] = string.find(lbl.id,'__fin') and assert(lbl.__depth) or 0
        end
        LBLS.code_fins = table.concat(t,',')
    end,

    Block = function (me)
        local blk = unpack(me)

        if me.fins then
            me.lbl_fin     = new{'Block__fin', __depth=me.__depth}
            me.lbl_fin_cnt = new{'Block_fin_cnt'}
        end
    end,

    Dcl_cls = function (me)
        if me.is_ifc then
            return
        end

        me.lbl = new{'Class_'..me.id, true}
-- TODO (-RAM)
        --if i_am_instantiable then
            me.lbl_clr = new{'Class_free_'..me.id}
        --end
    end,
    Spawn = function (me)
        me.lbls_cnt = { new{me.tag..'_cont'} }
    end,
    Free  = function (me)
        me.lbl_clr = new{'Free_clr'}
    end,

    SetBlock_pre = function (me)
        me.lbl_out = new{'Set_out',  prio=me.__depth}
    end,

    _Par_pre = function (me)
        me.lbls_in = {}
        for i, sub in ipairs(me) do
            if i > 1 then
                me.lbls_in[i] = new{me.tag..'_sub_'..i}
            end
        end
    end,
    ParEver_pre = function (me)
        F._Par_pre(me)
        me.lbl_out = new{'ParEver_out'}
    end,
    ParOr_pre = function (me)
        F._Par_pre(me)
        me.lbl_out = new{'ParOr_out',  prio=me.__depth}
    end,
    ParAnd_pre = function (me)
        F._Par_pre(me)
        me.lbl_tst = new{'ParAnd_chk'}
        me.lbl_out = new{'ParAnd_out'}
    end,

    Thread = 'Async',
    Async = function (me)
        me.lbl = new{'Async'}
    end,

    Loop_pre = function (me)
        if AST.iter'Async'() then
            me.lbl_asy = new{'Async_cnt'}
        end
    end,

    EmitExt = function (me)
        -- only async needs to break up (avoids stack growth)
        if AST.iter'Async'() then
            me.lbl_cnt = new{'Async_cont'}
        end
    end,
    EmitT = function (me)
        -- only async needs to break up (avoids stack growth)
        if AST.iter'Async'() then
            me.lbl_cnt = new{'Async_cont'}
        end
    end,
    EmitInt = function (me)
        me.lbl_cnt = new{'EmitInt_cont'}
    end,
    Dcl_var = function (me)
        if me.var.cls then
            me.lbls_cnt = {}
            for i=1, (me.var.tp.arr and me.var.tp.arr.sval or 1) do
                me.lbls_cnt[i] = new{'Start_cnt'}
            end
        end
    end,

    AwaitS = function (me)
        me.lbl = new{'Awake_MANY'}
    end,
    AwaitT = function (me)
        me.lbl = new{'Awake_DT'}
    end,
    AwaitExt = function (me)
        local e = unpack(me)
        me.lbl = new{'Awake_'..(e.evt or e.var.evt).id}
    end,
    AwaitInt = 'AwaitExt',

    ParOr_pos = function (me)
        if me.needs_clr then
            me.lbl_clr = new{'Clear'}
        end
    end,
    Block_pos    = 'ParOr_pos',
    Loop_pos     = 'ParOr_pos',
    SetBlock_pos = 'ParOr_pos',
}

AST.visit(F)

end

    
do
local VARS = {}

if not ANA then
    return          -- isTmp=false for all vars
end

F = {
    Dcl_var_pre = function (me)
        local var = me.var

        if var.cls then
            VARS = {}       -- org dcls eliminate all current possible tmps
            return
        end

        if var.pre~='var' or var.cls or var.inTop then
            return                  -- only normal vars can be tmp
        end

        VARS[var] = true
        var.isTmp = true
    end,

    Var = function (me)
        local var = me.var

        -- all threads vars are "tmp"
        if AST.iter'Thread'() then
            return
        end

        -- all function vars are "tmp"
        if AST.iter'Dcl_fun'() then
            return
        end

        -- only normal vars can be tmp
        if var.pre~='var' or var.cls then
            var.isTmp = false
            return
        end

        --[[
        --  var int i;
        --  var T[2] t with
        --      i = i + 1;      // "i" cannot be tmp
        --  end;
        --]]
        local constr = AST.par(me, 'Dcl_constr')
        if constr and (var.blk.__depth < constr.__depth) then
            local org = AST.par(me, 'Dcl_var')
            if org then
                local _, tp = unpack(org)
                if tp.arr then
                    var.isTmp = false
                end
            end
        end

        local glb = ENV.clss.Global
        if var.inTop or
            (var.blk==ENV.clss.Main.blk_ifc and glb and glb.is_ifc and
             glb.blk_ifc.vars[var.id])
        then
            var.isTmp = false
            return                  -- vars in interfaces cannot be tmp
        end

        local dcl = AST.iter'Dcl_var'()
        if dcl and dcl[1]==var.id then
            return                  -- my declaration is not an access
        end

        if me.__par.tag == 'SetBlock' then
            return                  -- set is performed on respective `return´
        end

        local v = VARS[var]

        local op = AST.iter'Op1_&'()
        local isRef = op and (op.base == me)

        if AST.iter'Finally'() or      -- finally executes through "call"
           AST.iter'AwaitInt'() or     -- await ptr:a (ptr is tested on awake)
           isRef or                     -- reference may escape
           var.tp.arr                   -- array may escape: TODO conservative
                                        -- (arrays as parameters)
        then
            var.isTmp = false
            VARS[var] = nil
            return
        end

        -- Not tmp if defined in the same block of an org:
        --      var T t;
        --      var int ret = 1;
        -- becomes
        --      var int ret;
        --      start t
        --      ret = 1;
        for _,oth in pairs(var.blk.vars) do
            if oth.cls then
                v = false
            end
        end

        if v == true then
            VARS[var] = me.ana.pre
            return                  -- first access
        end

        if not (v and ANA.CMP(v,me.ana.pre)) then
            var.isTmp = false       -- found a Par or Await in the path
            return
        end
    end,

    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        if e1.fst.var then
            e1.fst.var.isTmp = false    -- assigned to a pointer
        end
    end,

    EmitNoTmp = 'EmitInt',
    EmitInt = function (me)
        VARS = {}   -- NO: run in different ceu_call
    end,
    EmitExt = function (me)
        local op, ext, param = unpack(me)
        local evt = ext.evt
        if evt.pre == 'input' then
            VARS = {}
        end
    end,

    Spawn_pre = function (me)
        VARS = {}   -- NO: start organism
    end,

    Loop_pre = function (me)
        local awaits = false
        AST.visit(
            {
                AwaitT = function (me)
                    awaits = true
                end,
                AwaitInt = 'AwaitT',
                AwaitExt = 'AwaitT',
                AwaitN   = 'AwaitT',
                AwaitS   = 'AwaitT',
                EmitInt  = 'AwaitT',
                Async    = 'AwaitT',
                Thread   = 'AwaitT',
                Spawn    = 'AwaitT',
            },
            me)

        if ((not awaits) and (not AST.iter(AST.pred_async)())) or
            me.isAwaitUntil then
            return      -- OK: (tight loop outside Async) or (await ... until)
        end
        VARS = {}       -- NO: loop in between Dcl/Accs is dangerous
        --[[
            -- x is on the stack but may be written in two diff reactions
            -- a non-ceu code can reuse the stack in between
            input int E;
            var int x;
            loop do
                var int tmp = await E;
                if tmp == 0 then
                    break;
                end
                x = tmp;
            end
            return x;
        ]]
    end,
--[[
]]

    ParOr_pre = function (me)
        for var, v in pairs(VARS) do
            if v ~= true then
                VARS[var] = nil     -- remove previously accessed vars
            end
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',
    ParOr   = 'ParOr_pre',
    ParAnd  = 'ParOr_pre',
    ParEver = 'ParOr_pre',

    -- TODO: should pre's be already different?
    Async_pre = 'ParOr_pre',
    Async     = 'ParOr_pre',
}

AST.visit(F)

end

    
do
MEM = {
    clss  = '',
}

function SPC ()
    return string.rep(' ',AST.iter()().__depth*2)
end

function pred_sort (v1, v2)
    return (v1.len or TP.types.word.len) > (v2.len or TP.types.word.len)
end

F = {
    Host = function (me)
        -- unescape `##´ => `#´
        local src = string.gsub(me[1], '^%s*##',  '#')
              src = string.gsub(src,   '\n%s*##', '\n#')
        CLS().native = CLS().native .. [[

#line ]]..me.ln[2]..' "'..me.ln[1]..[["
]] .. src
    end,

    Dcl_cls_pre = function (me)
        me.struct = [[
typedef struct CEU_]]..me.id..[[ {
  struct tceu_org org;
  tceu_trl trls_[ ]]..me.trails_n..[[ ];
]]
        me.native = ''
        me.funs = ''
    end,
    Dcl_cls_pos = function (me)
        if me.is_ifc then
            me.struct = 'typedef void '..TP.toc(me.tp)..';\n'
            -- interface full declarations must be delayed to after its impls.  
            local struct = [[
typedef union CEU_]]..me.id..[[_delayed {
]]
            for k, v in pairs(me.matches) do
                if v then
                    struct = struct..'\t'..TP.toc(k.tp)..' '..k.id..';\n'
                end
            end
            struct = struct .. [[
} CEU_]]..me.id..[[_delayed;
]]
            -- TODO: HACK_4: delayed declaration until use
            me.struct_delayed = struct .. '\n'
        else
            me.struct  = me.struct..'\n} '..TP.toc(me.tp)..';\n'
        end

        if me.id ~= 'Main' then
            MEM.clss = MEM.clss .. me.native .. '\n'
        end
        MEM.clss = MEM.clss .. me.struct .. '\n'

        MEM.clss = MEM.clss .. me.funs .. '\n'
--DBG('===', me.id, me.trails_n)
--DBG(me.struct)
--DBG('======================')
    end,

    Dcl_fun = function (me)
        local _, _, ins, out, id, blk = unpack(me)
        local cls = CLS()

        -- input parameters (void* _ceu_go->org, int a, int b)
        local dcl = { 'tceu_app* _ceu_app', 'tceu_org* __ceu_org' }
        for _, v in ipairs(ins) do
            local _, tp, id = unpack(v)
            dcl[#dcl+1] = TP.toc(tp)..' '..(id or '')
        end
        dcl = table.concat(dcl,  ', ')

        -- TODO: static?
        me.id = 'CEU_'..cls.id..'_'..id
        me.proto = [[
]]..TP.toc(out)..' '..me.id..' ('..dcl..[[)
]]
        if OPTS.os and ENV.exts[id] and ENV.exts[id].pre=='output' then
            -- defined elsewhere
        else
            cls.funs = cls.funs..'static '..me.proto..';\n'
        end
    end,

    Stmts_pre = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'union {\n'
    end,
    Stmts_pos = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'};\n'
    end,

    Block_pos = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'};\n'
    end,
    Block_pre = function (me)
        local cls = CLS()

        cls.struct = cls.struct..SPC()..'struct { /* BLOCK ln='..me.ln[2]..' */\n'

        if me.fins then
            for i=1, #me.fins do
            cls.struct = cls.struct .. SPC()
                            ..'u8 __fin_'..me.n..'_'..i..': 1;\n'
            end
        end

        for _, var in ipairs(me.vars) do
            local len
            --if var.isTmp or var.pre=='event' then  --
            if var.isTmp then --
                len = 0
            elseif var.pre == 'event' then --
                len = 1   --
            elseif var.pre=='pool' and (type(var.tp.arr)=='table') then
                len = 10    -- TODO: it should be big
            elseif var.cls then
                len = 10    -- TODO: it should be big
                --len = (var.tp.arr or 1) * ?
            elseif var.tp.arr then
                len = 10    -- TODO: it should be big
--[[
                local _tp = TP.deptr(var.tp)
                len = var.tp.arr * (TP.deptr(_tp) and TP.types.pointer.len
                             or (ENV.c[_tp] and ENV.c[_tp].len
                                 or TP.types.word.len)) -- defaults to word
]]
            elseif var.tp.ptr>0 or var.tp.ref then
                len = TP.types.pointer.len
            else
                len = ENV.c[var.tp.id].len
            end
            var.len = len
        end

        -- sort offsets in descending order to optimize alignment
        -- TODO: previous org metadata
        local sorted = { unpack(me.vars) }
        if me ~= CLS().blk_ifc then
            table.sort(sorted, pred_sort)   -- TCEU_X should respect lexical order
        end

        for _, var in ipairs(sorted) do
            local tp = TP.toc(var.tp)

            if var.inTop then
                var.id_ = var.id
                    -- id's inside interfaces are kept (to be used from C)
            else
                var.id_ = var.id .. '_' .. var.n
                    -- otherwise use counter to avoid clash inside struct/union
            end

            if CLS().id == var.tp.id then
                tp = 'struct '..tp  -- for types w/ pointers for themselves
            end

            if var.pre=='var' and (not var.isTmp) then
                local dcl = [[
#line ]]..var.ln[2]..' "'..var.ln[1]..[["
]]
                if var.tp.arr then
                    local tp = string.sub(tp,1,-2)  -- remove leading `*´
                    ASR(var.tp.arr.cval, me, 'invalid constant')
                    dcl = dcl .. tp..' '..var.id_..'['..var.tp.arr.cval..']'
                else
                    dcl = dcl .. tp..' '..var.id_
                end
                cls.struct = cls.struct..SPC()..'  '..dcl..';\n'
            elseif var.pre=='pool' and (type(var.tp.arr)=='table') then
                local pool_cls = ENV.clss[var.tp.id]
                if pool_cls.is_ifc then
                    -- TODO: HACK_4: delayed declaration until use
                    MEM.clss = MEM.clss .. pool_cls.struct_delayed .. '\n'
                    pool_cls.struct_delayed = ''
                    cls.struct = cls.struct .. [[
CEU_POOL_DCL(]]..var.id_..',CEU_'..var.tp.id..'_delayed,'..var.tp.arr.sval..[[)
]]
                           -- TODO: bad (explicit CEU_)
                else
                    cls.struct = cls.struct .. [[
CEU_POOL_DCL(]]..var.id_..',CEU_'..var.tp.id..','..var.tp.arr.sval..[[)
]]
                           -- TODO: bad (explicit CEU_)
                end
            end

            -- pointers ini/end to list of orgs
            if var.cls then
                cls.struct = cls.struct .. SPC() ..
                   'tceu_org_lnk __lnks_'..me.n..'_'..var.trl_orgs[1]..'[2];\n'
                    -- see val.lua for the (complex) naming
            end
        end
    end,

    ParOr_pre = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'struct {\n'
    end,
    ParOr_pos = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'};\n'
    end,
    ParAnd_pre = 'ParOr_pre',
    ParAnd_pos = 'ParOr_pos',
    ParEver_pre = 'ParOr_pre',
    ParEver_pos = 'ParOr_pos',

    ParAnd = function (me)
        local cls = CLS()
        for i=1, #me do
            cls.struct = cls.struct..SPC()..'u8 __and_'..me.n..'_'..i..': 1;\n'
        end
    end,

    AwaitT = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'s32 __wclk_'..me.n..';\n'
    end,

--[[
    AwaitS = function (me)
        for _, awt in ipairs(me) do
            if awt.__ast_isexp then
            elseif awt.tag=='Ext' then
            else
                awt.off = alloc(CLS().mem, 4)
            end
        end
    end,
]]

    Thread_pre = 'ParOr_pre',
    Thread = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'CEU_THREADS_T __thread_id_'..me.n..';\n'
        cls.struct = cls.struct..SPC()..'s8*       __thread_st_'..me.n..';\n'
    end,
    Thread_pos = 'ParOr_pos',
}

AST.visit(F)

end

    
do
local t2n = {
     us = 10^0,
     ms = 10^3,
      s = 10^6,
    min = 60*10^6,
      h = 60*60*10^6,
}

local _ceu2c = { ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

function V (me)
    ASR(me.val, me, 'invalid expression')

    local ref = me.tp and me.tp.ref and me.tp.id
    if me.byRef and
        (not (ENV.clss[me.tp.id] or ref and ENV.clss[ref]))
    then
                    -- already by ref
        local ret = '&'..me.val
        return string.gsub(ret, '%&([^)])%*', '%1')
                -- &((*(...))) => (((...)))
    else
        return me.val
    end
end

function CUR (me, id)
    if id then
        return '(('..TP.toc(CLS().tp)..'*)_ceu_go->org)->'..id
    else
        return '(('..TP.toc(CLS().tp)..'*)_ceu_go->org)'
    end
end

F =
{
    Block_pre = function (me)
        local cls = CLS()
        for _, var in ipairs(me.vars) do
            if var.pre == 'var' then
                if var.isTmp then
                    var.val = '__ceu_'..var.id..'_'..var.n
                else
                    var.val = CUR(me, var.id_)
                end
                if var.tp.arr then
                    -- normalize all arrays acesses to pointers to arr[0]
                    -- (because of interface accesses that must be done through a pointer)
                    var.val = '(&'..var.val..'[0])'
                elseif var.cls then
                    -- normalize all org acesses to pointers to it
                    -- (because of interface accesses that must be done through a pointer)
                    var.val = '(&'..var.val..')'
                else
                    if var.tp.ref then
                        if ENV.clss[var.tp.id] then
                            -- orgs vars byRef, do nothing
                            -- (normalized to pointer)
                        else
                            -- normal vars byRef
                            var.val = '(*('..var.val..'))'
                        end
                    end
                end
            elseif var.pre == 'pool' then
                -- normalize all pool acesses to pointers to it
                -- (because of interface accesses that must be done through a pointer)
                var.val_dcl = '&'..CUR(me, var.id_)
                var.val = '(&'..CUR(me, var.id_)..')'
            elseif var.pre == 'function' then
                var.val = 'CEU_'..cls.id..'_'..var.id
            elseif var.pre == 'isr' then
                var.val = 'CEU_'..cls.id..'_'..var.id
            elseif var.pre == 'event' then
                var.val = nil
            elseif var.pre == 'output' then
                var.val = nil
            elseif var.pre == 'input' then
                var.val = nil
            else
                error 'not implemented'
            end
            if var.trl_orgs then
                -- ORG_STATS (shared for sequential), ORG_POOL (unique for each)
                var.trl_orgs.val = CUR(me, '__lnks_'..me.n..'_'..var.trl_orgs[1])
            end
        end
        if me.fins then
            for i, fin in ipairs(me.fins) do
                fin.val = CUR(me, '__fin_'..me.n..'_'..i)
            end
        end
    end,

    ParAnd = function (me)
        me.val = CUR(me, '__and_'..me.n)
    end,

    Global = function (me)
        me.val = '(_ceu_app->data)'
    end,

    Outer = function (me)
            me.val = '_ceu_go->org'
            --me.val = '(*(('..TP.toc(me.tp)..'*)'..me.val..'))'
            me.val = '(('..TP.toc(me.tp)..'*)'..me.val..')'
    end,

    This = function (me)
        if AST.iter'Dcl_constr'() then
            me.val = '__ceu_org'    -- set when calling constr
            --me.val = '(*(('..TP.toc(me.tp)..'*)'..me.val..'))'
            me.val = '(('..TP.toc(me.tp)..'*)'..me.val..')'
        else
            me.val = '_ceu_go->org'
            --me.val = '(*(('..TP.toc(me.tp)..'*)'..me.val..'))'
            me.val = '(('..TP.toc(me.tp)..'*)'..me.val..')'
        end
    end,

    Var = function (me)
        me.val = me.var.val
    end,

    SetExp = function (me)
        local _, fr, to = unpack(me)
        V(fr)     -- error on reads of internal events
    end,

    -- SetExp is inside and requires .val
    Spawn_pre = function (me)
        local id,_,_ = unpack(me)
        me.val = '((CEU_'..id..'*)__ceu_new)'
                                        -- defined by _Spawn (code.lua)
    end,

    IterIni = function (me)
        local fr_exp = unpack(me)
        ASR(fr_exp.lst.var, me, 'not a pool')
        local var = fr_exp.lst.var
        assert(var.trl_orgs)
        local idx = fr_exp.ifc_idx or var.trl_orgs[1]
                    -- converted to interface access or original
        local org = fr_exp.org and V(fr_exp.org) or '_ceu_go->org'
        org = '((tceu_org*)'..org..')'
        me.val = [[
( (]]..org..[[->trls[ ]]..idx..[[ ].lnks[0].nxt->n == 0) ?
    NULL :    /* marks end of linked list */
    ]]..org..[[->trls[ ]]..idx..[[ ].lnks[0].nxt )
]]
    end,
    IterNxt = function (me)
        local fr_var = unpack(me)
        me.val = '(('..V(fr_var)..'->nxt->n==0) ? NULL : '..V(fr_var)..'->nxt)'
    end,

    Thread = function (me)
        me.thread_id = CUR(me, '__thread_id_'..me.n)
        me.thread_st = CUR(me, '__thread_st_'..me.n)
        me.val = '(*('..me.thread_st..') > 0)'
    end,

    EmitExt = function (me)
        local op, ext, param = unpack(me)

        local DIR, dir, ptr, mode

        if ext.evt.pre == 'input' then
            DIR = 'IN'
            dir = 'in'
            if op == 'call' then
                ptr = '_ceu_app->data'
            else
                ptr = '_ceu_app'
            end
        else
            DIR = 'OUT'
            dir = 'out'
            ptr = '_ceu_app'
        end

        local tup = ext.evt.ins.tup
        if op=='call' or dir=='in' or
                (not tup) or (#tup == 1) then
            mode = 'val'
        else
            mode = 'buf'
        end

        local t1 = { }
        if ext.evt.pre=='input' and op=='call' then
            t1[#t1+1] = '_ceu_app'  -- to access `app´
            t1[#t1+1] = ptr         -- to access `this´
        end

        local t2 = { ptr, 'CEU_'..DIR..'_'..ext.evt.id }

        if param then
            local isPtr = ext.evt.ins.ptr>0
            local val
            if isPtr then
                val = '(void*)'..V(param)
            else
                val = V(param)
            end
            t1[#t1+1] = val

            if tup and #tup>1 then
                if mode == 'val' then
                    t2[#t2+1] = 'CEU_EVTP((void*)'..val..')'
                else
                    t2[#t2+1] = 'sizeof('..TP.toc(ext.evt.ins)..')'
                    t2[#t2+1] = '(byte*)'..val
                end
            else
                assert(mode == 'val')
                if isPtr then
                    t2[#t2+1] = 'CEU_EVTP('..val..')'
                else
                    t2[#t2+1] = 'CEU_EVTP((int)'..val..')'
                end
            end
        else
            if mode == 'val' then
                t2[#t2+1] = 'CEU_EVTP((void*)NULL)'
            else
                t2[#t2+1] = '0'
                t2[#t2+1] = '(byte*)NULL'
            end
        end
        t2 = table.concat(t2, ', ')
        t1 = table.concat(t1, ', ')

        local ret = ''
        if OPTS.os and op=='call' then
            -- when the call crosses the process,
            -- the return val must be unpacked from tceu_evtp
            if me.__ast_set then
                if TP.toc(ext.evt.out) == 'int' then
                    ret = '.v'
                else
                    ret = '.ptr'
                end
            end
        end

        local op = (op=='emit' and 'emit') or 'call'

        me.val = '\n'..[[
#if defined(ceu_]]..dir..'_'..op..'_'..ext.evt.id..[[)
    ceu_]]..dir..'_'..op..'_'..ext.evt.id..'('..t1..[[)

#elif defined(ceu_]]..dir..'_'..op..'_'..mode..[[)
    ceu_]]..dir..'_'..op..'_'..mode..'('..t2..')'..ret..[[

#else
    #error ceu_]]..dir..'_'..op..[[_* is not defined
#endif
]]
    end,

    AwaitInt = 'AwaitExt',
    AwaitExt = function (me)
        local e1 = unpack(me)
        local tp = (e1.evt or e1.var.evt).ins
        if tp.ptr>0 then
            me.val = '(('..TP.toc(me.tp)..')_ceu_go->evtp.ptr)'
        elseif tp.ref then
            me.val = '(*(('..TP.toc(me.tp)..')_ceu_go->evtp.ptr))'
                    -- byRef from awake SetExp removes the `*´
        elseif tp.tup then
            me.val = '(('..TP.toc(me.tp)..'*)_ceu_go->evtp.ptr)'
        else
            me.val = '(_ceu_go->evtp.v)'
            --me.val = '*(('..TP.toc(e1.evt.ins)..'*)_ceu_go->evtp.ptr)'
        end
    end,
    AwaitT = function (me)
        local exp = unpack(me)
        local suf = (exp.tm and '_') or ''
        me.val      = '_ceu_app->wclk_late'..suf
        me.val_wclk = CUR(me, '__wclk_'..me.n)
    end,
--[[
    AwaitS = function (me)
        me.val = '__ceu_'..me.n..'_AwaitS'
    end,
]]

    Op2_call = function (me)
        local _, f, exps = unpack(me)
        local ps = {}
        if f.var and f.var.fun then
            -- (tceu_app*, tceu_org*, ...)
            ps[#ps+1] = '_ceu_app'
            if f.org then
                ps[#ps+1] = V(f.org)   -- only native
            else
                ps[#ps+1] = CUR(me)
            end
            ps[#ps] = '(tceu_org*)'..ps[#ps]
        end
        for i, exp in ipairs(exps) do
            ps[#ps+1] = V(exp)
        end
        me.val = V(f)..'('..table.concat(ps,',')..')'
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
        me.val = V(arr)..'['..V(idx)..']'
        if me.tp.ptr==0 and ENV.clss[me.tp.id] then
            me.val = '(&'..me.val..')'
                -- class accesses must be normalized to references
        end
    end,

    Op2_any = function (me)
        local op, e1, e2 = unpack(me)
        me.val = '('..V(e1)..ceu2c(op)..V(e2)..')'
    end,
    ['Op2_-']   = 'Op2_any',
    ['Op2_+']   = 'Op2_any',
    ['Op2_%']   = 'Op2_any',
    ['Op2_*']   = 'Op2_any',
    ['Op2_/']   = 'Op2_any',
    ['Op2_|']   = 'Op2_any',
    ['Op2_&']   = 'Op2_any',
    ['Op2_<<']  = 'Op2_any',
    ['Op2_>>']  = 'Op2_any',
    ['Op2_^']   = 'Op2_any',
    ['Op2_==']  = 'Op2_any',
    ['Op2_!=']  = 'Op2_any',
    ['Op2_>=']  = 'Op2_any',
    ['Op2_<=']  = 'Op2_any',
    ['Op2_>']   = 'Op2_any',
    ['Op2_<']   = 'Op2_any',
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',

    Op1_any = function (me)
        local op, e1 = unpack(me)
        me.val = '('..ceu2c(op)..V(e1)..')'
    end,
    ['Op1_~']   = 'Op1_any',
    ['Op1_-']   = 'Op1_any',
    ['Op1_+']   = 'Op1_any',
    ['Op1_not'] = 'Op1_any',

    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
        local cls = e1.tp.ptr==1 and ENV.clss[e1.tp.id]
        if cls then
            me.val = V(e1) -- class accesses should remain normalized to references
        else
            me.val = '('..ceu2c(op)..V(e1)..')'
        end
    end,
    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        if ENV.clss[e1.tp.id] and e1.tp.ptr==0 then
            me.val = V(e1) -- class accesses are already normalized to references
        else
            me.val = '('..ceu2c(op)..V(e1)..')'
        end
    end,

    ['Op2_.'] = function (me)
        if me.org then
            local cls = me.org.tp.ptr==0 and ENV.clss[me.org.tp.id]
            local gen = '((tceu_org*)'..me.org.val..')'
            if cls and cls.is_ifc then
                if me.var.pre == 'var'
                or me.var.pre == 'pool' then
                    if me.var.tp.arr then
                        me.val = [[(
(]]..TP.toc(me.var.tp)..[[) (
        ((byte*)]]..me.org.val..[[) + _CEU_APP.ifcs_flds[]]..gen..[[->cls][
            ]]..ENV.ifcs.flds[me.var.ifc_id]..[[
        ]
))]]
                    else
                        me.val = [[(*(
(]]..TP.toc(me.var.tp)..[[*) (
        ((byte*)]]..me.org.val..[[) + _CEU_APP.ifcs_flds[]]..gen..[[->cls][
            ]]..ENV.ifcs.flds[me.var.ifc_id]..[[
        ]
            )
))]]
                    end
                    if me.var.pre == 'pool' then
                        me.ifc_idx = '(_CEU_APP.ifcs_trls['..gen..'->cls]['
                                        ..ENV.ifcs.trls[me.var.ifc_id]
                                   ..'])'
                    end
                elseif me.var.pre == 'function' then
                    me.val = [[(*(
(]]..TP.toc(me.var.tp)..[[*) (
        _CEU_APP.ifcs_funs[]]..gen..[[->cls][
            ]]..ENV.ifcs.funs[me.var.ifc_id]..[[
        ]
            )
))]]
                elseif me.var.pre == 'event' then
                    me.val = nil    -- cannot be used as variable
                    me.ifc_idx = '(_CEU_APP.ifcs_evts['..gen..'->cls]['
                                    ..ENV.ifcs.evts[me.var.ifc_id]
                               ..'])'
                else
                    error 'not implemented'
                end
            else
                if me.c then
                    me.val = me.c.id_
                elseif me.var.pre == 'var' then
                    me.val = me.org.val..'->'..me.var.id_
                    if me.var.tp.arr then
                        -- normalize all arrays acesses to pointers to arr[0]
                        -- (because of interface accesses that must be done through a pointer)
                        me.val = '(&'..me.val..'[0])'
                    elseif me.var.cls then
                        -- normalize all org acesses to pointers to it
                        -- (because of interface accesses that must be done through a pointer)
                        me.val = '(&'..me.val..')'
                    end
                elseif me.var.pre == 'pool' then
                    -- normalize all pool acesses to pointers to it
                    -- (because of interface accesses that must be done through a pointer)
                    me.val = '(&'..me.org.val..'->'..me.var.id_..')'
                elseif me.var.pre == 'event' then
                    me.val = nil    -- cannot be used as variable
                    --me.org.val = '(&'..me.org.val..')' -- always via reference
                elseif me.var.pre == 'function' then
                    me.val = me.var.val
                else
                    error 'not implemented'
                end
            end
        else
            local op, e1, id = unpack(me)
            me.val  = '('..V(e1)..ceu2c(op)..id..')'
        end
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        local val = V(exp)

        local cls = tp.ptr==1 and ENV.clss[tp.id]
        if cls then
            if cls.is_ifc then
                -- TODO: out of bounds acc
                val = '(('..val..' == NULL) ? NULL : '..
                        '((_CEU_APP.ifcs_clss[((tceu_org*)'..val..')->cls]'
                            ..'['..cls.n..']) ?'..val..' : NULL)'..
                      ')'
            else
                val = '(('..val..' == NULL) ? NULL : '..
                        '((((tceu_org*)'..val..')->cls == '..cls.n..') ? '
                        ..val..' : NULL)'..
                      ')'
            end
        end

        me.val = '(('..TP.toc(tp)..')'..val..')'
    end,

    WCLOCKK = function (me)
        local h,min,s,ms,us, tm = unpack(me)
        me.us  = us*t2n.us + ms*t2n.ms + s*t2n.s + min*t2n.min + h*t2n.h
        me.val = '((s32)'..me.us..')'
        me.tm  = tm
        ASR(me.us>0 and me.us<=2000000000, me, 'constant is out of range')
    end,

    WCLOCKE = function (me)
        local exp, unit, tm = unpack(me)
        me.us   = nil
        me.val  = '((s32)'.. V(exp) .. ')*' .. t2n[unit]
        me.tm  = tm
    end,

    RawExp = function (me)
        me.val = unpack(me)
    end,

    Type = function (me)
        me.val = TP.toc(me)
    end,

    Nat = function (me)
        me.val = string.sub(me[1], 2)
    end,
    SIZEOF = function (me)
        --me.val = me.sval
        local tp = unpack(me)
        me.val = 'sizeof('..tp.val..')'
    end,
    STRING = function (me)
        me.val = me[1]
    end,
    NUMBER = function (me)
        me.val = me[1]
    end,
    NULL = function (me)
        me.val = 'NULL'
    end,
}

AST.visit(F)

end

    
do
CODE = {
    has_goto  = false,   -- avoids "unused label"
    pres      = '',
    constrs   = '',
    threads   = '',
    functions = '',
    stubs     = '',     -- maps input functions to ceu_app_call switch cases
}

-- Assert that all input functions have bodies.
local INPUT_FUNCTIONS = {
    -- F1 = false,  -- input function w/o body
    -- F2 = true,   -- input functino w/  body
}

function CONC_ALL (me, t)
    t = t or me
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            CONC(me, sub)
        end
    end
end

function CONC (me, sub, tab)
    sub = sub or me[1]
    tab = string.rep(' ', tab or 0)
    me.code = me.code .. string.gsub(sub.code, '(.-)\n', tab..'%1\n')
end

function ATTR (me, to, fr)
--COMM(me, tostring(to.byRef)..' '..tostring(fr.byRef))
    LINE(me, V(to)..' = '..V(fr)..';')
end

function CASE (me, lbl)
    LINE(me, 'case '..lbl.id..':;', 0)
end

function DEBUG_TRAILS (me, lbl)
    LINE(me, [[
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
]])
end

function LINE (me, line, spc)
    spc = spc or 4
    spc = string.rep(' ', spc)
    me.code = me.code .. [[

#line ]]..me.ln[2]..' "'..me.ln[1]..[["
]] .. spc..line
end

function HALT (me, ret, cond)
    if cond then
        LINE(me, 'if ('..cond..') {')
    end
    --LINE(me, '\tgoto _CEU_NEXT_;')
    if ret then
        LINE(me, '\treturn '..ret..';')
    else
        LINE(me, '\treturn RET_HALT;')
    end
    if cond then
        LINE(me, '}')
    end
end

function GOTO (me, lbl, org)
    CODE.has_goto = true
    if org then
        LINE(me, [[
_ceu_go->org = ]]..org..[[;
]])
    end
    LINE(me, [[
_ceu_go->lbl = ]]..lbl.id..[[;
goto _CEU_GOTO_;
/*return RET_GOTO;*/
]])
end

function AWAIT_PAUSE (me, no)
    if not PROPS.has_pses then
        return
    end

    for pse in AST.iter'Pause' do
        COMM(me, 'PAUSE: '..pse.dcl.var.id)
        LINE(me, [[
if (]]..V(pse.dcl.var)..[[) {
]])
        if me.tag == 'AwaitInt' then
            LINE(me, [[
    _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
]])
        end
        LINE(me, [[
    goto ]]..no..[[;
}
]])
    end
end

function COMM (me, comm)
    LINE(me, '/* '..comm..' */', 0)
end

local _iter = function (n)
    if n.tag == 'Block' and n.needs_clr then
        return true
    end

    if n.tag == 'SetBlock' and n.needs_clr then
        return true
    end

    if n.tag == 'Loop' and n.needs_clr then
        return true
    end

    n = n.__par
    if n and (n.tag == 'ParOr') then
        return true     -- par branch
    end
end

function CLEAR (me)
    COMM(me, 'CLEAR: '..me.tag..' ('..me.ln[2]..')')

    if ANA and me.ana.pos[false] then
        return
    end
    if not me.needs_clr then
        return
    end

-- TODO: put it back!
--[[
    -- check if top will clear during same reaction
    if (not me.needs_clr_fin) and ANA then   -- fin must execute before any stmt
        local top = AST.iter(_iter)()
        if top and ANA.CMP(top.ana.pos, me.ana.pos) then
            return  -- top will clear
        end
    end
]]

    --LINE(me, 'ceu_trails_clr('..me.trails[1]..','..me.trails[2]..
                                --', _ceu_go->org);')

    LINE(me, [[
/* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ ]]..me.trails[1]..[[ ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = ]]..me.lbl_clr.id..[[;
}
return ceu_out_clear(_ceu_go, ]]..(me.trails[1]+1)..','..[[
                     &_ceu_go->org->trls[ ]]..(me.trails[2]+1)..[[ ]);

case ]]..me.lbl_clr.id..[[:;
]])
end

F = {
    Node_pre = function (me)
        me.code = '/* NODE: '..me.tag..' '..me.n..' */\n'
    end,

    Do         = CONC_ALL,
    Finally    = CONC_ALL,

    Dcl_constr = function (me)
        CONC_ALL(me)
        CODE.constrs = CODE.constrs .. [[
static void _ceu_constr_]]..me.n..[[ (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
]] .. me.code .. [[
}
]]
    end,

    Stmts = function (me)
        LINE(me, '{')   -- allows C declarations for Spawn
        CONC_ALL(me)
        LINE(me, '}')
    end,

    Root = function (me)
        for _, cls in ipairs(ENV.clss_cls) do
            CONC(me, cls)
        end

        -- functions and threads receive __ceu_org as parameter
        --   and do not require _ceu_go
        CODE.functions = string.gsub(CODE.functions, '_ceu_go%-%>org', '__ceu_org')
        CODE.threads   = string.gsub(CODE.threads,   '_ceu_go%-%>org', '__ceu_org')

        -- assert that all input functions have bodies
        for evt, v in pairs(INPUT_FUNCTIONS) do
            ASR(v, evt.ln, 'missing body')
        end
    end,

    BlockI = CONC_ALL,
    BlockI_pos = function (me)
        -- Interface constants are initialized from outside
        -- (another _ceu_go_org), need to use __ceu_org instead.
        me.code_ifc = string.gsub(me.code, '_ceu_go%-%>org', '__ceu_org')
        me.code = ''
    end,

    Dcl_fun = function (me)
        local _, _, ins, out, id, blk = unpack(me)
        if blk then
            if me.var.fun.isExt then
                CODE.functions = CODE.functions ..
                    '#define ceu_in_call_'..id..' '..me.id..'\n'

                local ps = {}
                if #ins > 1 then
                    for i, _ in ipairs(ins) do
                        ps[#ps+1] = ', (('..ins.tp..'*)param.ptr)->_'..i
                    end
                elseif #ins == 1 then
                    local _,tp,_ = unpack(ins[1])
                    if TP.isNumeric(tp) then
                        ps[#ps+1] = ', param.v'
                    else
                        ps[#ps+1] = ', param.ptr'
                    end
                else
                    -- no parameters
                end
                ps = table.concat(ps)

                local ret_value, ret_void
                if TP.toc(out) == 'void' then
                    ret_value = '('
                    ret_void  = 'return CEU_EVTP((void*)NULL);'
                else
                    ret_value = 'return CEU_EVTP('
                    ret_void  = ''
                end

                CODE.stubs = CODE.stubs .. [[
case CEU_IN_]]..id..[[:
#line ]]..me.ln[2]..' "'..me.ln[1]..[["
    ]]..ret_value..me.id..'(_ceu_app, _ceu_app->data'..ps..[[));
]]..ret_void
            end
            CODE.functions = CODE.functions ..
                me.proto..'{'..blk.code..'}'..'\n'
        end

        -- assert that all input functions have bodies
        local evt = ENV.exts[id]
        if me.var.fun.isExt and evt and evt.pre=='input' then
            INPUT_FUNCTIONS[evt] = INPUT_FUNCTIONS[evt] or blk or false
        end
    end,
    Return = function (me)
        local exp = unpack(me)
        LINE(me, 'return '..(exp and V(exp) or '')..';')
    end,

    Dcl_cls = function (me)
        if me.is_ifc then
            CONC_ALL(me)
            return
        end
        if me.has_pre then
            CODE.pres = CODE.pres .. [[
static void _ceu_pre_]]..me.n..[[ (tceu_app* _ceu_app, tceu_org* __ceu_org) {
]] .. me.blk_ifc[1][1].code_ifc .. [[
}
]]
        end

        CASE(me, me.lbl)

        -- TODO: move to _ORG? (MAIN does not call _ORG)
        LINE(me, [[
#ifdef CEU_IFCS
_ceu_go->org->cls = ]]..me.n..[[;
#endif
]])

        CONC_ALL(me)

        if ANA and me.ana.pos[false] then
            return      -- never reachable
        end

        -- might need "free"

        -- TODO: this posts a "CLEAR" that will eventually execute the "free"
        -- inside the scheduler. However, we could call the "free" from here
        -- because all trails are already clean at this point.
        LINE(me, [[
#ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif
]])

        -- stop
        if me == MAIN then
            HALT(me, 'RET_END')
        else
            HALT(me)
        end
    end,

    -- TODO: C function?
    _ORG = function (me, t)
        COMM(me, 'start org: '..t.id)

        --[[
class T with
    <PRE>           -- 1    org: me.lbls_pre[i].id
    var int v = 0;
do
    <BODY>          -- 3    org: me.lbls_body[i].id
end

<...>               -- 0    par:

var T t with
    <CONSTR>        -- 2    org: no lbl (cannot call anything)
end;

<CONT>              -- 4    par: me.lbls_cnt[i].id
]]

        -- ceu_out_org, _ceu_constr_
        local org = t.arr and '((tceu_org*) &'..t.val..'[i]'..')'
                           or '((tceu_org*) '..t.val..')'
        LINE(me, [[
/* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<]]..(t.arr and t.arr.sval or 1)..[[; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ]]..org..','..t.cls.trails_n..','..t.cls.lbl.id..[[,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                ]]..t.isDyn..[[,
#endif
]]
                ..t.par_org..', '
                ..t.par_trl_idx..[[);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */
]])
        if t.cls.has_pre then
            LINE(me, [[
        _ceu_pre_]]..t.cls.n..[[(_ceu_app, ]]..org..[[);
]])
        end
        if t.constr then
            LINE(me, [[
        _ceu_constr_]]..t.constr.n..[[(_ceu_app, ]]..org..[[, _ceu_go);
]])
        end
        LINE(me, [[
    }
}
]])

        -- TODO: move to the loop above (requires persistent "i")
        -- ceu_org_spawn
        for i=1, (t.arr and t.arr.sval or 1) do
            local org = t.arr and '((tceu_org*) &'..t.val..'['..(i-1)..']'..')'
                               or '((tceu_org*) '..t.val..')'
            LINE(me, [[
/* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, ]]..me.lbls_cnt[i].id..','..org..','..t.cls.lbl.id..[[);
case ]]..me.lbls_cnt[i].id..[[:;
]])
        end
    end,

    Dcl_var = function (me)
        local _,_,_,constr = unpack(me)
        local var = me.var
        if not var.cls then
            return
        end

        F._ORG(me, {
            id      = var.id,
            isDyn   = 0,
            cls     = var.cls,
            val     = var.val,
            constr  = constr,
            arr     = var.tp.arr,
            par_org = '_ceu_go->org',
            par_trl_idx = var.trl_orgs[1],
        })
    end,

    Spawn = function (me)
        local id, pool, constr, set = unpack(me)

        LINE(me, [[
{
    tceu_org* __ceu_new;
]])
        if pool and (type(pool.var.tp.arr)=='table') then
            LINE(me, [[
    __ceu_new = (tceu_org*) ceu_pool_alloc((tceu_pool*)]]..V(pool)..[[);
]])
        else
            LINE(me, [[
    __ceu_new = (tceu_org*) ceu_out_malloc(sizeof(CEU_]]..id..[[));
]])
        end

        if set then
            CONC(me, set)   -- <ptr=Spawn T>
        end

        LINE(me, [[
    if (__ceu_new != NULL) {
]])
        if pool and (type(pool.var.tp.arr)=='table') then
            LINE(me, '__ceu_new->pool = '..V(pool)..';')
        elseif PROPS.has_news_pool or OPTS.os then
            LINE(me, '__ceu_new->pool = NULL;')
        end

        local org = '_ceu_go->org'
        if pool and pool.org then
            org = '((tceu_org*)'..V(pool.org)..')'
        end

        F._ORG(me, {
            id      = 'dyn',
            isDyn   = 1,
            cls     = me.cls,
            val     = '__ceu_new',
            constr  = constr,
            arr     = false,
            par_org = org,
            par_trl_idx = pool.ifc_idx or pool.lst.var.trl_orgs[1],
                            -- converted to interface access or original
        })
        LINE(me, [[
    }
}
]])
    end,

    Block_pre = function (me)
        local cls = CLS()
        if cls.is_ifc then
            return
        end

        if me.fins then
            LINE(me, [[
/*  FINALIZE */
_ceu_go->org->trls[ ]]..me.trl_fins[1]..[[ ].evt   = CEU_IN__CLEAR;
_ceu_go->org->trls[ ]]..me.trl_fins[1]..[[ ].lbl   = ]]..me.lbl_fin.id..[[;
_ceu_go->org->trls[ ]]..me.trl_fins[1]..[[ ].seqno = _ceu_app->seqno-1; /* awake now */
]])
            for _, fin in ipairs(me.fins) do
                LINE(me, fin.val..' = 0;')
            end
        end

        -- declare tmps & initialize pools
        LINE(me, '{')       -- close in Block_pos
        for _, var in ipairs(me.vars) do
            if var.isTmp then
                if var.tp.arr then
            local tp = TP.toc(var.tp)
                    local tp = string.sub(TP.toc(var.tp),1,-2)  -- remove leading `*´
                    LINE(me, tp..' '..var.id_..'['..var.tp.arr.cval..']')
                else
                    LINE(me, TP.toc(var.tp)..' __ceu_'..var.id..'_'..var.n)
                end
                if var.isFun then
                    -- function parameter
                    -- __ceu_a = a
                    LINE(me, ' = '..var.id)
                end
                LINE(me, ';')
            elseif var.pre=='pool' and (type(var.tp.arr)=='table') then
                local dcl = var.val_dcl
                if ENV.clss[var.tp.id].is_ifc then
                    LINE(me, [[
ceu_pool_init(]]..dcl..','..var.tp.arr.sval..',sizeof(CEU_'..var.tp.id..'_delayed),'
                                                    -- TODO: bad (explicit CEU_)
    ..'(byte**)'..dcl..'_queue, (byte*)'..dcl..[[_mem);
]])
                else
                    LINE(me, [[
ceu_pool_init(]]..dcl..','..var.tp.arr.sval..',sizeof(CEU_'..var.tp.id..'),'
                                                    -- TODO: bad (explicit CEU_)
    ..'(byte**)'..dcl..'_queue, (byte*)'..dcl..[[_mem);
]])
                end
            end

            -- initialize trails for ORG_STATS_I & ORG_POOL_I
            -- "first" avoids repetition for STATS in sequence
-- TODO: join w/ ceu_out_org (removing start from the latter?)
            if var.trl_orgs and var.trl_orgs_first then
                LINE(me, [[
/* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, ]]..var.trl_orgs[1]..[[, (tceu_org_lnk*) &]]..var.trl_orgs.val..[[);
]])
            end
        end
    end,

    Block_pos = function (me)
        local stmts = unpack(me)
        if CLS().is_ifc then
            return
        end

-- TODO: try to remove this need
        if me.trails[1] ~= stmts.trails[1] then
            LINE(me, [[
/* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ ]]..stmts.trails[1]..[[ ];
]])
        end
        CONC(me, stmts)

        if me.fins then
            GOTO(me, me.lbl_fin_cnt)
            CASE(me, me.lbl_fin)
            for i, fin in ipairs(me.fins) do
                LINE(me, [[
if (]]..fin.val..[[) {
]] .. fin.code .. [[
}
]])
            end
            HALT(me)
            CASE(me, me.lbl_fin_cnt)
        end
        CLEAR(me)
        LINE(me, '}')       -- open in Block_pre

-- TODO: remove!
        if not (ANA and me.ana.pos[false]) then
            LINE(me, [[
/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ ]]..me.trails[1]..[[ ]; */
]])
        end
    end,

    Pause = CONC_ALL,
-- TODO: meaningful name
    PauseX = function (me)
        local psed = unpack(me)
        LINE(me, [[
ceu_pause(&_ceu_go->org->trls[ ]]..me.blk.trails[1]..[[ ],
          &_ceu_go->org->trls[ ]]..me.blk.trails[2]..[[ ],
        ]]..psed..[[);
]])
    end,

    -- TODO: more tests
    Op2_call_pre = function (me)
        local _, f, exps, fin = unpack(me)
        if fin and fin.active then
            LINE(AST.iter'Stmts'(), fin.val..' = 1;')
        end
    end,
    Finalize = function (me)
        -- enable finalize
        local set,fin = unpack(me)
        if fin.active then
            LINE(me, fin.val..' = 1;')
        end
        if set then
            CONC(me, set)
        end
    end,

    SetExp = function (me)
        local _, fr, to, fin = unpack(me)
        COMM(me, 'SET: '..tostring(to[1]))    -- Var or C
        ATTR(me, to, fr)
        if to.tag=='Var' and to.var.id=='_ret' then
            LINE(me, [[
#ifdef CEU_RET
    _ceu_app->ret = ]]..V(to)..[[;
#endif
]])
        end

        -- enable finalize
        if fin and fin.active then
            LINE(me, fin.val..' = 1;')
        end
    end,

    SetBlock_pos = function (me)
        local blk,_ = unpack(me)
        CONC(me, blk)
        HALT(me)        -- must escape with `escape´
        CASE(me, me.lbl_out)
        if me.has_escape then
            CLEAR(me)
            LINE(me, [[
/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ ]] ..me.trails[1]..[[ ];
]])
        end
    end,
    Escape = function (me)
        GOTO(me, AST.iter'SetBlock'().lbl_out)
    end,

    _Par = function (me)
        -- Ever/Or/And spawn subs
        COMM(me, me.tag..': spawn subs')
        for i, sub in ipairs(me) do
            if i > 1 then
                LINE(me, [[
/* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ ]]..sub.trails[1]..[[ ];
    trl->evt = CEU_IN__STK;
    trl->lbl = ]]..me.lbls_in[i].id..[[;
    trl->stk = _ceu_go->stki;
}
]])
            end
        end
    end,

    ParEver = function (me)
        F._Par(me)
        for i, sub in ipairs(me) do
            if i > 1 then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)

            -- only if trail terminates
            if not sub.ana.pos[false] then
                HALT(me)
            end
        end
    end,

    ParOr_pos = function (me)
        F._Par(me)
        for i, sub in ipairs(me) do
            if i > 1 then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)

            if not (ANA and sub.ana.pos[false]) then
                COMM(me, 'PAROR JOIN')
                GOTO(me, me.lbl_out)
            end
        end

        if not (ANA and me.ana.pos[false]) then
            CASE(me, me.lbl_out)
            CLEAR(me)
            LINE(me, [[
/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ ]]..me.trails[1]..[[ ];
]])
        end
    end,

    ParAnd = function (me)
        -- close AND gates
        COMM(me, 'close ParAnd gates')

        for i=1, #me do
            LINE(me, V(me)..'_'..i..' = 0;')
        end

        F._Par(me)

        for i, sub in ipairs(me) do
            if i > 1 then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)
            LINE(me, V(me)..'_'..i..' = 1;')
            GOTO(me, me.lbl_tst)
        end

        -- AFTER code :: test gates
        CASE(me, me.lbl_tst)
        for i, sub in ipairs(me) do
            HALT(me, nil, '!'..V(me)..'_'..i)
        end

        LINE(me, [[
/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ ]]..me.trails[1]..[[ ];
]])
    end,

    If = function (me)
        local c, t, f = unpack(me)
        -- TODO: If cond assert(c==ptr or int)

        LINE(me, [[
if (]]..V(c)..[[) {
]]    ..t.code..[[
} else {
]]    ..f.code..[[
}
]])
    end,

    Loop_pos = function (me)
        local body = unpack(me)
        local no = '_CEU_NO_'..me.n..'_'

        LINE(me, [[
for (;;) {
]])
        CONC(me)
        local async = AST.iter'Async'()
        if async then
            LINE(me, [[
#ifdef ceu_out_pending
    if (ceu_out_pending()) {
#else
    {
#endif
]]..no..[[:
        _ceu_go->trl->evt = CEU_IN__ASYNC;
        _ceu_go->trl->lbl = ]]..me.lbl_asy.id..[[;
]])
            HALT(me, 'RET_ASYNC')
            LINE(me, [[
    }
    case ]]..me.lbl_asy.id..[[:;
]])
            AWAIT_PAUSE(me, no)
        end
        LINE(me, [[
}
]])
        if me.has_break and ( not (AST.iter(AST.pred_async)()
                                or AST.iter'Dcl_fun'()) )
        then
            CLEAR(me)
            LINE(me, [[
/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ ]]..me.trails[1]..[[ ];
]])
        end
    end,

    Break = function (me)
        LINE(me, 'break;')
    end,

    CallStmt = function (me)
        local call = unpack(me)
        LINE(me, V(call)..';')
    end,

    EmitExt = function (me)
        local op, ext, param = unpack(me)
        local evt = ext.evt
        local no = '_CEU_NO_'..me.n..'_'

        if evt.pre~='input' or op~='emit' then
            if not me.__ast_set then
                LINE(me, V(me)..';')    -- already on <v = emit E>
            end
            return
        end

        -- emit INPUT

        -- only async's need to split in two (to avoid stack growth)
        if AST.iter'Async'() then
            LINE(me, [[
]]..no..[[:
_ceu_go->trl->evt = CEU_IN__ASYNC;
_ceu_go->trl->lbl = ]]..me.lbl_cnt.id..[[;
]])
        end

        if AST.iter'Thread'() then
            -- HACK_2: never terminates
            error'not supported'
        else
            LINE(me, V(me)..[[;
#if defined(CEU_RET) || defined(CEU_OS)
if (! _ceu_app->isAlive)
    return RET_END;
#endif
]])
        end

        if AST.iter'Async'() then
            HALT(me, 'RET_ASYNC')
            LINE(me, [[
case ]]..me.lbl_cnt.id..[[:;
]])
            AWAIT_PAUSE(me, no)
        end
    end,

    EmitT = function (me)
        local exp = unpack(me)
        local no = '_CEU_NO_'..me.n..'_'

        local suf = (exp.tm and '_') or ''

        -- only async's need to split in two (to avoid stack growth)
        if AST.iter'Async'() then
            LINE(me, [[
]]..no..[[:
_ceu_go->trl->evt = CEU_IN__ASYNC;
_ceu_go->trl->lbl = ]]..me.lbl_cnt.id..[[;
]])
        end

        local emit = [[
{
    ceu_out_go(_ceu_app, CEU_IN__WCLOCK]]..suf..[[, CEU_EVTP((s32)(]]..V(exp)..[[)));
    while (
#if defined(CEU_RET) || defined(CEU_OS)
            _ceu_app->isAlive &&
#endif
            _ceu_app->wclk_min]]..suf..[[<=0) {
        ceu_out_go(_ceu_app, CEU_IN__WCLOCK]]..suf..[[, CEU_EVTP((s32)0));
    }
#if defined(CEU_RET) || defined(CEU_OS)
    if (! _ceu_app->isAlive)
        return RET_END;
#endif
}
]]
        if AST.iter'Thread'() then
            emit = 'CEU_ATOMIC( '..emit..' )\n'
        end

        LINE(me, [[
#ifdef CEU_WCLOCKS
    ]]..emit..[[
#endif
]])

        if AST.iter'Async'() then
            HALT(me, 'RET_ASYNC')
            LINE(me, [[
case ]]..me.lbl_cnt.id..[[:;
]])
            AWAIT_PAUSE(me, no)
        end
    end,

    EmitInt = function (me)
        local _, int, exp = unpack(me)

        -- [ ... | me=stk | ... | oth=stk ]
        LINE(me, [[
_ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = ]]..me.lbl_cnt.id..[[;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = ]]..(int.ifc_idx or int.var.evt.idx)..[[;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ]]..((int.org and int.org.val) or '_ceu_go->org')..[[;
#endif
]])
        if exp then
            local field = exp.tp.ptr>0 and 'ptr' or 'v'
            LINE(me, [[
_ceu_go->evtp.]]..field..' = '..V(exp)..[[;
]])
        end
        LINE(me, [[
#ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case ]]..me.lbl_cnt.id..[[:;
]])
    end,

    AwaitN = function (me)
        HALT(me)
    end,

    AwaitT = function (me)
        local exp = unpack(me)
        local no = '_CEU_NO_'..me.n..'_'
        local suf = (exp.tm and '_') or ''

        LINE(me, [[
ceu_out_wclock]]..suf..[[(_ceu_app, (s32)]]..V(exp)..[[, &]]..me.val_wclk..[[, NULL);
]]..no..[[:
    _ceu_go->trl->evt = CEU_IN__WCLOCK]]..suf..[[;
    _ceu_go->trl->lbl = ]]..me.lbl.id..[[;
]])
        HALT(me)

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])

        AWAIT_PAUSE(me, no)
        LINE(me, [[
    if (!ceu_out_wclock]]..suf..[[(_ceu_app, _ceu_go->evtp.dt, NULL, &]]..me.val_wclk..[[) )
        goto ]]..no..[[;
]])
        DEBUG_TRAILS(me)
    end,

    AwaitInt = function (me)
        local int = unpack(me)
        local org = (int.org and int.org.val) or '_ceu_go->org'
        local no = '_CEU_NO_'..me.n..'_'

        LINE(me, [[
]]..no..[[:
    _ceu_go->trl->evt = ]]..(int.ifc_idx or int.var.evt.idx)..[[;
    _ceu_go->trl->lbl = ]]..me.lbl.id..[[;
]])
        if int.var.evt.id == '_ok' then
            LINE(me, [[
    _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* always ready to awake */
]])
        end
        HALT(me)

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])
        LINE(me, [[
#ifdef CEU_ORGS
    if ((tceu_org*)]]..org..[[ != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto ]]..no..[[;
    }
#endif
]])
        AWAIT_PAUSE(me, no)
        DEBUG_TRAILS(me)
    end,

    AwaitExt = function (me)
        local e = unpack(me)
        local no = AST.iter'Pause'() and '_CEU_NO_'..me.n..'_:'
                    or ''
        LINE(me, [[
]]..no..[[
    _ceu_go->trl->evt = CEU_IN_]]..e.evt.id..[[;
    _ceu_go->trl->lbl = ]]..me.lbl.id..[[;
]])
        HALT(me)

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])
        AWAIT_PAUSE(me, string.sub(no,1,-2))  -- remove `:´
        DEBUG_TRAILS(me)
    end,

--[=[
    AwaitS = function (me)
        local LBL_OUT = '__CEU_'..me.n..'_AWAITS'
        local set = AST.iter'SetAwait'()

        for _, awt in ipairs(me) do
            if awt.tag=='WCLOCKK' or awt.tag=='WCLOCKE' then
                LINE(me, [[
ceu_trails_set_wclock(_ceu_app, PTR_cur(u32*,]]..awt.off..'),(s32)'..V(awt)..[[);
]])
            end
        end

        local no = '_CEU_NO_'..me.n..'_'
        LINE(me, [[
]]..no..[[:
    _ceu_go->trl->evt = CEU_IN__ANY;
    _ceu_go->trl->lbl = ]]..me.lbl.id..[[;
]])
        HALT(me)

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])

        AWAIT_PAUSE(me, no)
        if set then
            LINE(me, '{ int __ceu_'..me.n..'_AwaitS;')
        end
        for i, awt in ipairs(me) do
            if awt.tag == 'Ext' then
                LINE(me, [[
                    if (_ceu_go->evt == CEU_IN_]]..awt.evt.id..[[) {
                ]])
            elseif awt.__ast_isexp then
                local org = (awt.org and awt.org.val) or '_ceu_go->org'
                LINE(me, [[
                    if ( (_ceu_go->evt == ]]..(awt.off or awt.evt.off)..[[)
                    #ifdef CEU_ORGS
                        && (]]..org..[[ != _ceu_go->evtp.org)
                    #endif
                    ) {
                ]])
            else -- WCLOCK
                LINE(me, [[
                    if ( (_ceu_go->evt == CEU_IN__WCLOCK)
                    &&   (!ceu_wclocks_not(PTR_cur(s32*,]]..awt.off..
                            [[), _ceu_go->evtp.dt)) ) {
                ]])
            end
            if set then
                LINE(me, V(me)..' = '..(i-1)..';')
            end
            LINE(me, 'goto '..LBL_OUT..';}')    -- close my if
        end

        HALT(me)
        LINE(me, LBL_OUT..':;')
        DEBUG_TRAILS(me)
        F._SetAwait(me)
        if set then
            LINE(me, '}')
        end
    end,
]=]

    Async = function (me)
        local vars,blk = unpack(me)
        local no = '_CEU_NO_'..me.n..'_'

        if vars then
            for i=1, #vars, 2 do
                local isRef, n = vars[i], vars[i+1]
                if not isRef then
                    ATTR(me, n.new, n.var)      -- copy async parameters
                end
            end
        end

        LINE(me, [[
]]..no..[[:
_ceu_go->trl->evt = CEU_IN__ASYNC;
_ceu_go->trl->lbl = ]]..me.lbl.id..[[;
]])
        HALT(me, 'RET_ASYNC')

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])
        AWAIT_PAUSE(me, no)
        CONC(me, blk)
    end,

    SetThread = CONC,

    Thread_pre = function (me)
        me.lbl_out = '_CEU_THREAD_OUT_'..me.n
    end,

    Thread = function (me)
        local vars,blk = unpack(me)

-- TODO: transform to SetExp
        if vars then
            for i=1, #vars, 2 do
                local isRef, n = vars[i], vars[i+1]
                if not isRef then
                    ATTR(me, n.new, n.var)      -- copy async parameters
                end
            end
        end

        -- spawn thread
        LINE(me, [[
/* TODO: test it! */
]]..me.thread_st..[[  = ceu_out_malloc(sizeof(s8));
*]]..me.thread_st..[[ = 0;  /* ini */
{
    tceu_threads_p p = { _ceu_app, _ceu_go->org, ]]..me.thread_st..[[ };
    int ret =
        CEU_THREADS_CREATE(&]]..me.thread_id..[[, _ceu_thread_]]..me.n..[[, &p);
    if (ret == 0)
    {
        _ceu_app->threads_n++;
        assert( CEU_THREADS_DETACH(]]..me.thread_id..[[) == 0 );

        /* wait for "p" to be copied inside the thread */
        CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);

        while (1) {
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
            int ok = (*(p.st) >= 1);   /* cpy ok? */
            if (ok)
                break;
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
        }

        /* proceed with sync execution (already locked) */
        *(p.st) = 2;    /* lck: now thread may also execute */
]])

        -- await termination
        local no = '_CEU_NO_'..me.n..'_'
        LINE(me, [[
]]..no..[[:
        _ceu_go->trl->evt = CEU_IN__THREAD;
        _ceu_go->trl->lbl = ]]..me.lbl.id..[[;
]])
        HALT(me)

        -- continue
        LINE(me, [[
case ]]..me.lbl.id..[[:;
        if (_ceu_go->evtp.thread != ]]..me.thread_id..[[) {
            goto ]]..no..[[; /* another thread is terminating: await again */
        }
    }
}
]])
        DEBUG_TRAILS(me)

        -- thread function
        CODE.threads = CODE.threads .. [[
static void* _ceu_thread_]]..me.n..[[ (void* __ceu_p)
{
    /* start thread */

    /* copy param */
    tceu_threads_p _ceu_p = *((tceu_threads_p*) __ceu_p);
    tceu_app* _ceu_app  = _ceu_p.app;
    tceu_org* __ceu_org = _ceu_p.org;

    /* now safe for sync to proceed */
    CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
    *(_ceu_p.st) = 1;
    CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);

    /* ensures that sync reaquires the mutex and terminates
     * the current reaction before I proceed
     * otherwise I could lock below and reenter sync
     */
    while (1) {
        CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
        int ok = (*(_ceu_p.st) >= 2);   /* lck ok? */
        CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
        if (ok)
            break;
    }

    /* body */
    ]]..blk.code..[[

    /* goto from "sync" and already terminated */
    ]]..me.lbl_out..[[:

    /* terminate thread */
    {
        tceu_evtp evtp;
        evtp.thread = CEU_THREADS_SELF();
        /*pthread_testcancel();*/
        CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
    /* only if sync is not active */
        if (*(_ceu_p.st) < 3) {             /* 3=end */
            *(_ceu_p.st) = 3;
            ceu_out_go(_ceu_app, CEU_IN__THREAD, evtp);   /* keep locked */
                /* HACK_2:
                 *  A thread never terminates the program because we include an
                 *  <async do end> after it to enforce terminating from the
                 *  main program.
                 */
        } else {
            ceu_out_free(_ceu_p.st);  /* fin finished, I free */
            _ceu_app->threads_n--;
        }
        CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
    }

    /* more correct would be two signals:
     * (1) above, when I finish
     * (2) finalizer, when sync finishes
     * now the program may hang if I never reach here
    CEU_THREADS_COND_SIGNAL(&_ceu_app->threads_cond);
     */
    return NULL;
}
]]
    end,

    RawStmt = function (me)
        if me.thread then
            me[1] = [[
if (*]]..me.thread.thread_st..[[ < 3) {     /* 3=end */
    *]]..me.thread.thread_st..[[ = 3;
    /*assert( pthread_cancel(]]..me.thread.thread_id..[[) == 0 );*/
} else {
    ceu_out_free(]]..me.thread.thread_st..[[); /* thr finished, I free */
    _ceu_app->threads_n--;
}
]]
        end

        LINE(me, me[1])
    end,

    Lua = function (me)
        local nargs = #me.params
        local nrets = (me.ret and 1) or 0
        LINE(me, [[
{
    int err = luaL_loadstring(_ceu_app->lua, ]]..string.format('%q',me.lua)..[[);
    if (! err) {
]])

        for _, p in ipairs(me.params) do
            if TP.isNumeric(p.tp) then
                LINE(me, [[
        lua_pushnumber(_ceu_app->lua,]]..V(p)..[[);
]])
            elseif p.tp.id=='char' and p.tp.ptr==1 then
                LINE(me, [[
        lua_pushstring(_ceu_app->lua,]]..V(p)..[[);
]])
            else
                error 'not implemented'
            end
        end

        LINE(me, [[
        err = lua_pcall(_ceu_app->lua, ]]..nargs..','..nrets..[[, 0);
        if (! err) {
]])
        if me.ret then
            if TP.isNumeric(me.ret.tp) or me.ret.tp=='bool' then
                LINE(me, [[
            int ret;
            if (lua_isnumber(_ceu_app->lua,-1)) {
                ret = lua_tonumber(_ceu_app->lua,-1);
            } else if (lua_isboolean(_ceu_app->lua,-1)) {
                ret = lua_toboolean(_ceu_app->lua,-1);
            } else {
                err = 1;
            }
            ]]..V(me.ret)..[[ = ret;
            lua_pop(_ceu_app->lua, 1);
]])
            elseif me.ret.tp.id=='char' and me.ret.tp.arr then
                ASR(me.ret.var and me.ret.var.tp.arr, me,
                    'invalid attribution (requires a buffer)')
                LINE(me, [[
            if (lua_isstring(_ceu_app->lua,-1)) {
                const char* ret = lua_tostring(_ceu_app->lua,-1);
                strncpy(]]..V(me.ret)..[[, ret, ]]..me.ret.var.tp.arr.sval..[[);
            } else {
                err = 1;
            }
            lua_pop(_ceu_app->lua, 1);
]])
            else
                error 'not implemented'
            end
        end

        LINE(me, [[
            if (! err) {
                goto _CEU_LUA_OK_]]..me.n..[[;
            }
        }
    }
/* ERROR */
    lua_error(_ceu_app->lua); /* TODO */

/* OK */
_CEU_LUA_OK_]]..me.n..[[:;
}
]])
    end,

    Sync = function (me)
        local thr = AST.iter'Thread'()
        LINE(me, [[
CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
if (*(_ceu_p.st) == 3) {        /* 3=end */
    CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
    goto ]]..thr.lbl_out..[[;   /* exit if ended from "sync" */
} else {                        /* othrewise, execute block */
]])
        CONC(me)
        LINE(me, [[
    CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
}
]])
    end,

    Atomic = function (me)
        LINE(me, 'CEU_ISR_ON();')
        CONC(me)
        LINE(me, 'CEU_ISR_OFF();')
    end,
}

AST.visit(F)

end

    --AST.dump(AST.root)
end

local function SUB (str, from, to)
    assert(to, from)
    local i,e = string.find(str, from, 1, true)
    if i then
        return SUB(string.sub(str,1,i-1) .. to .. string.sub(str,e+1),
                   from, to)
    else
        return str
    end
end

local HH, CC

-- TEMPLATE.H
do
    HH = FILES.template_h
    HH = SUB(HH, '#include "ceu_os.h"', FILES.ceu_os_h)

    local tps = { [0]='void', [1]='8', [2]='16', [4]='32' }
    HH = SUB(HH, '=== TCEU_NLBL ===',   's'..tps[TP.types.tceu_nlbl.len])
    HH = SUB(HH, '=== TCEU_NCLS ===',   's'..tps[TP.types.tceu_ncls.len])
    HH = SUB(HH, '=== CEU_NTRAILS ===', MAIN.trails_n)
    --HH = SUB(HH, '=== CLSS_DEFS ===',  MEM.clss)

    -- DEFINES
    do
        local str = ''
        local t = {
            -- props.lua
            has_exts    = 'CEU_EXTS',
            has_wclocks = 'CEU_WCLOCKS',
            has_ints    = 'CEU_INTS',
            has_asyncs  = 'CEU_ASYNCS',
            has_threads = 'CEU_THREADS',
            has_orgs    = 'CEU_ORGS',
            has_news    = 'CEU_NEWS',
            has_news_pool   = 'CEU_NEWS_POOL',
            has_news_malloc = 'CEU_NEWS_MALLOC',
            has_ifcs    = 'CEU_IFCS',
            has_clear   = 'CEU_CLEAR',
            has_pses    = 'CEU_PSES',
            has_ret     = 'CEU_RET',
            has_lua     = 'CEU_LUA',
            has_orgs_watching = 'CEU_ORGS_WATCHING',
            -- code.lua
            has_goto    = 'CEU_GOTO',
        }
        for k, s in pairs(t) do
            if PROPS[k] or CODE[k] then
                str = str .. '#define ' .. s .. '\n'
            end
        end

        -- TODO: goto OPTS
        --str = str .. '#define CEU_DEBUG_TRAILS\n'
        --str = str .. '#define CEU_NOLINES\n'

        if OPTS.os then
            str = str .. [[
#ifndef CEU_OS
#define CEU_OS
#endif
]]
        end

        if OPTS.timemachine then
            str = str .. [[
#ifndef CEU_TIMEMACHINE
#define CEU_TIMEMACHINE
#endif
]]
        end

        if OPTS.run_tests then
            str = str .. '#define CEU_RUNTESTS\n'
        end

        local h = OPTS.out_h
        if OPTS.out_h == '-' then
            h = '_STDIN_H'
        end

        HH = SUB(HH, '=== DEFS_H ===',
                     string.upper(string.gsub(h,'%.','_')))
        HH = SUB(HH, '=== DEFINES ===', str)
    end


    -- EVENTS
    do
        -- inputs: [max_evt+1...) (including _FIN,_WCLOCK,_ASYNC)
        --          cannot overlap w/ internal events
        local str = ''
        local t = {}
        local ins  = 0
        local outs = 0

        -- TODO
        str = str..'#define CEU_IN__NONE 0\n'

        for i, evt in ipairs(ENV.exts) do
            if evt.pre == 'input' then
                ins = ins + 1
                local s = '#define CEU_IN_'..evt.id..' '..(256-ins)
                if OPTS.verbose and i > 9 then
                    DBG('', s)
                end
                str = str..s..'\n'
            else
                outs = outs + 1
                local s = '#define CEU_OUT_'..evt.id..' '..outs
                if OPTS.verbose then
                    DBG('', s)
                end
                str = str..s..'\n'
            end
            assert(evt.pre=='input' or evt.pre=='output')
            ASR(ins+outs < 255, me, 'too many events')
        end
        --str = str..'#define CEU_IN_n  '..ins..'\n'
        str = str..'#define CEU_OUT_n '..outs..'\n'

        HH = SUB(HH, '=== EVENTS ===', str)
    end

    -- FUNCTIONS called
    do
        local str = ''
        for id in pairs(ENV.calls) do
            if id ~= '$anon' then
                str = str..'#define CEU_FUN'..id..'\n'
            end
        end
        HH = SUB(HH, '=== FUNCTIONS ===', str)
    end

    -- TUPLES
    do
        local str = ''
        for _,T in pairs(TP.types) do
            if T.tup and #T.tup>0 then
                str = str .. 'typedef struct {\n'
                for i, t in ipairs(T.tup) do
                    local tmp = TP.toc(t)
                    if ENV.clss[t.id] then
                        -- T* => void*
                        -- T** => void**
                        tmp = 'void'..string.match(tmp,'(%*+)')
                    end
                    str = str..'\t'..tmp..' _'..i..';\n'
                end
                str = str .. '} '..TP.toc(T)..';\n'
            end
        end
        HH = SUB(HH, '=== TUPLES ===', str)
    end
end

-- TEMPLATE.C
do
    CC = FILES.template_c

    CC = SUB(CC, '=== FILENAME ===', OPTS.input)
    --CC = SUB(CC, '^#line.-\n', '')

    CC = SUB(CC, '=== LABELS_ENUM ===', LBLS.code_enum)

    CC = SUB(CC, '=== CLSS_DEFS ===',  MEM.clss)   -- TODO: move to HH

    CC = SUB(CC, '=== CONSTRS_C ===',   CODE.constrs)
    CC = SUB(CC, '=== PRES_C ===',      CODE.pres)
    CC = SUB(CC, '=== THREADS_C ===',   CODE.threads)
    CC = SUB(CC, '=== FUNCTIONS_C ===', CODE.functions)
    CC = SUB(CC, '=== STUBS ===',       CODE.stubs)
    CC = SUB(CC, '=== NATIVE ===',      MAIN.native)
    CC = SUB(CC, '=== CODE ===',        AST.root.code)

    -- IFACES
    if PROPS.has_ifcs then
        local CLSS = {}
        local FLDS = {}
        local EVTS = {}
        local FUNS = {}
        local TRLS = {}
        for _, cls in ipairs(ENV.clss_cls) do
            local clss = {}
            local flds = {}
            local evts = {}
            local funs = {}
            local trls = {}
            for i=1, #ENV.ifcs.flds do
                flds[i] = 0
            end
            for i=1, #ENV.ifcs.evts do
                evts[i] = 0
            end
            for i=1, #ENV.ifcs.funs do
                funs[i] = 'NULL'
            end
            for i=1, #ENV.ifcs.trls do
                trls[i] = 0
            end
            for _, var in ipairs(cls.blk_ifc.vars) do
                if var.pre == 'event' then
                    local i = ENV.ifcs.evts[var.ifc_id]
                    if i then
                        evts[i+1] = var.evt.idx
                    end
                elseif var.pre=='var' or var.pre=='pool' then
                    if var.pre=='var' or (type(var.tp.arr)=='table') then
                                        -- malloc pools are not vars
                        local i = ENV.ifcs.flds[var.ifc_id]
                        if i then
                            flds[i+1] = 'offsetof(CEU_'..cls.id..','..(var.id_ or var.id)..')'
                        end
                    end
                    if var.pre == 'pool' then
                        local i = ENV.ifcs.trls[var.ifc_id]
                        if i then
                            trls[i+1] = var.trl_orgs[1]
                        end
                    end
                elseif var.pre == 'function' then
                    local i = ENV.ifcs.funs[var.ifc_id]
                    if i then
                        funs[i+1] = '(void*)'..var.val
                    end
                else
                    error 'not implemented'
                end
            end

            -- IFCS_CLSS
            for _,ifc in ipairs(ENV.clss_ifc) do
                clss[#clss+1] = cls.matches[ifc] and 1 or 0
            end

            CLSS[#CLSS+1] = '\t\t{'..table.concat(clss,',')..'}'
            FLDS[#FLDS+1] = '\t\t{'..table.concat(flds,',')..'}'
            EVTS[#EVTS+1] = '\t\t{'..table.concat(evts,',')..'}'
            FUNS[#FUNS+1] = '\t\t{'..table.concat(funs,',')..'}'
            TRLS[#TRLS+1] = '\t\t{'..table.concat(trls,',')..'}'
        end
        CC = SUB(CC, '=== CEU_NCLS ===',     #ENV.clss_cls)
        CC = SUB(CC, '=== IFCS_NIFCS ===',   #ENV.clss_ifc)
        CC = SUB(CC, '=== IFCS_NFLDS ===',   #ENV.ifcs.flds)
        CC = SUB(CC, '=== IFCS_NEVTS ===',   #ENV.ifcs.evts)
        CC = SUB(CC, '=== IFCS_NFUNS ===',   #ENV.ifcs.funs)
        CC = SUB(CC, '=== IFCS_NTRLS ===',   #ENV.ifcs.trls)
        CC = SUB(CC, '=== IFCS_CLSS ===',    table.concat(CLSS,',\n'))
        CC = SUB(CC, '=== IFCS_FLDS ===',    table.concat(FLDS,',\n'))
        CC = SUB(CC, '=== IFCS_EVTS ===',    table.concat(EVTS,',\n'))
        CC = SUB(CC, '=== IFCS_FUNS ===',    table.concat(FUNS,',\n'))
        CC = SUB(CC, '=== IFCS_TRLS ===',    table.concat(TRLS,',\n'))
    end

    if not OPTS.os then
        FILES.ceu_os_c = SUB(FILES.ceu_os_c,
                                      '#include "ceu_os.h"',
                                      FILES.ceu_os_h)
        CC = SUB(CC, '#include "ceu_types.h"',
                             FILES.ceu_types_h)
        CC = SUB(CC, '#include "ceu_os.h"',
                             FILES.ceu_os_h..'\n'..FILES.ceu_os_c)
    end

    -- TODO: move above (if not OPTS.os) when pool* becomes sys_calls
    FILES.ceu_pool_c = SUB(FILES.ceu_pool_c, '#include "ceu_pool.h"', '')
    CC = SUB(CC, '#include "ceu_pool.h"',
                         FILES.ceu_pool_h..'\n'..FILES.ceu_pool_c)

    if OPTS.out_s ~= 'CEU_SIZE' then
        CC = SUB(CC, 'CEU_SIZE', OPTS.out_s)
    end
    if OPTS.out_f ~= 'ceu_app_init' then
        CC = SUB(CC, 'ceu_app_init', OPTS.out_f)
    end
end

if OPTS.verbose then
    local T = {
        --mem  = AST.root.mem.max,
        evts = ENV.max_evt+#ENV.exts,
        lbls = #LBLS.list,

        trls    = AST.root.trails_n,

        exts    = PROPS.has_exts,
        wclocks = PROPS.has_wclocks,
        ints    = PROPS.has_ints,
        asyncs  = PROPS.has_asyncs,
        orgs    = PROPS.has_orgs,
        news    = PROPS.has_news,
        ifcs    = PROPS.has_ifcs,
        ret     = PROPS.has_ret,
    }
    local t = {}
    for k, v in pairs(T) do
        if v == true then
            t[#t+1] = k
        elseif v then
            t[#t+1] = k..'='..v
        end
    end
    table.sort(t)
    DBG('[ '..table.concat(t,' | ')..' ]')
end

-- OUTPUT

if OPTS.out_h and OPTS.out_h~='-' then
    local f = assert(io.open(OPTS.out_h,'w'))
    f:write(HH)
    f:close()
end
CC = SUB(CC, '=== OUT_H ===', HH)

local out
if OPTS.out_c == '-' then
    out = io.stdout
else
    out = assert(io.open(OPTS.out_c,'w'))
end
out:write([[
/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * Céu is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
]] .. CC)
out:close()
